/**
 * \file
 *
 * \brief AUTOSAR Dem
 *
 * This file contains the implementation of the AUTOSAR
 * module Dem.
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2013 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
#if (!defined DEM_INT_H)
#define DEM_INT_H

/* This file contains or includes all internal configuration dependant
 * identifiers of the AUTOSAR module Dem. */

/*==================[inclusions]============================================*/
/* !LINKSTO dsn.Dem.IncludeStr,1 */

#include <Std_Types.h>                            /* AUTOSAR standard types */

/** \brief Dem-internal marker for RTE-related declarations in
 ** \verbatim Dem.h\endverbatim
 **
 ** Note: \verbatim Dem_Int_Cfg.h\endverbatim includes user-specific h-files,
 **        which in turn might include \verbatim Dem.h\endverbatim also. */
#define DEM_INTERNAL

#include <Dem.h>                              /* Module public declarations */
#include <Dem_Int_Stc.h>             /* Module internal static declarations */
#include <Dem_Int_Cfg.h>                 /* Internal generated declarations */

#if (DEM_INCLUDE_RTE == STD_ON)
#define RTE_PTR2ARRAYBASETYPE_PASSING
#include <Rte_Dem.h>                                /* API generated by RTE */
#endif

#if (DEM_DEV_ERROR_DETECT == STD_ON)
#include <Det.h>                                     /* Det Error Reporting */
#endif

/*==================[macros]================================================*/

#if (DEM_DEV_ERROR_DETECT == STD_ON)

#if (defined DEM_INSTANCE_ID)
#error DEM_INSTANCE_ID is already defined
#endif
#define DEM_INSTANCE_ID     0U

#endif /* DEM_DEV_ERROR_DETECT */




/*------------------------[Defensive programming]----------------------------*/

#if (defined DEM_PRECONDITION_ASSERT)
#error DEM_PRECONDITION_ASSERT is already defined
#endif
#if (DEM_PRECONDITION_ASSERT_ENABLED == STD_ON)
/** \brief Report an assertion violation to Det
 **
 ** \param[in] Condition Condition which is violated
 ** \param[in] ApiId Service ID of the API function */
#define DEM_PRECONDITION_ASSERT(Condition, ApiId) \
  DET_PRECONDITION_ASSERT((Condition), DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))
#else
#define DEM_PRECONDITION_ASSERT(Condition, ApiId)
#endif

#if (defined DEM_POSTCONDITION_ASSERT)
#error DEM_POSTCONDITION_ASSERT is already defined
#endif
#if (DEM_POSTCONDITION_ASSERT_ENABLED == STD_ON)
/** \brief Report an assertion violation to Det
 **
 ** \param[in] Condition Condition which is violated
 ** \param[in] ApiId Service ID of the API function */
#define DEM_POSTCONDITION_ASSERT(Condition, ApiId) \
  DET_POSTCONDITION_ASSERT((Condition), DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))
#else
#define DEM_POSTCONDITION_ASSERT(Condition, ApiId)
#endif

#if (defined DEM_INVARIANT_ASSERT)
#error DEM_INVARIANT_ASSERT is already defined
#endif
#if (DEM_INVARIANT_ASSERT_ENABLED == STD_ON)
/** \brief Report an assertion violation to Det
 **
 ** \param[in] Condition Condition which is violated
 ** \param[in] ApiId Service ID of the API function */
#define DEM_INVARIANT_ASSERT(Condition, ApiId) \
  DET_INVARIANT_ASSERT((Condition), DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))
#else
#define DEM_INVARIANT_ASSERT(Condition, ApiId)
#endif

#if (defined DEM_STATIC_ASSERT)
# error DEM_STATIC_ASSERT is already defined
#endif
#if (DEM_STATIC_ASSERT_ENABLED == STD_ON)
/** \brief Report an static assertion violation to Det
 **
 ** \param[in] Condition Condition which is violated */
# define DEM_STATIC_ASSERT(expr) DET_STATIC_ASSERT(expr)
#else
# define DEM_STATIC_ASSERT(expr)
#endif

#if (defined DEM_UNREACHABLE_CODE_ASSERT)
#error DEM_UNREACHABLE_CODE_ASSERT is already defined
#endif
#if (DEM_UNREACHABLE_CODE_ASSERT_ENABLED == STD_ON)
/** \brief Report an unreachable code assertion violation to Det
 **
 ** \param[in] ApiId Service ID of the API function */
#define DEM_UNREACHABLE_CODE_ASSERT(ApiId) \
  DET_UNREACHABLE_CODE_ASSERT(DEM_MODULE_ID, DEM_INSTANCE_ID, (ApiId))
#else
#define DEM_UNREACHABLE_CODE_ASSERT(ApiId)
#endif

#if (defined DEM_INTERNAL_API_ID)
#error DEM_INTERNAL_API_ID is already defined
#endif
/** \brief API ID of module internal functions to be used in assertions */
#define DEM_INTERNAL_API_ID DET_INTERNAL_API_ID


/*------------------[Dem-specific internal Std_ReturnType values]-----------*/

#if (defined DEM_E_DET_REPORT)
#error DEM_E_DET_REPORT is already defined
#endif
/** \brief Indicate DET error to calling API
 **
 ** Dem-specific internal ::Std_ReturnType value used by
 ** Dem_InternalSetEventStatus()
 */
#define DEM_E_DET_REPORT   3U

/*------------------[Development error macros]----------------------*/

#if (DEM_DEV_ERROR_DETECT == STD_ON)

#if (defined DEM_REPORT_ERROR)
#error DEM_REPORT_ERROR already defined
#endif
/** \brief Macro for DET calls in Dem development-error-detection sections */
#define DEM_REPORT_ERROR(ApiId, ErrorId) \
  (void)Det_ReportError(DEM_MODULE_ID, 0U, (ApiId), (ErrorId))

#endif /* DEM_DEV_ERROR_DETECT */

/*------------------[General Helper-macros]---------------------------------*/

#if (defined DEM_DTC_STATUS_MASKS)
#error DEM_DTC_STATUS_MASKS already defined
#endif
/** \brief DTC status masks */
#define DEM_DTC_STATUS_MASKS    Dem_NvData.DTCStatusMask

#if (defined DEM_OVFIND_FLAGS)
#error DEM_OVFIND_FLAGS  already defined
#endif
/** \brief Flags to indicate whether event memory is full or not */
#define DEM_OVFIND_FLAGS     Dem_NvData.EvMemOvfIndFlags

#if (defined DEM_INDICATOR_CYC_COUNTER)
#error DEM_INDICATOR_CYC_COUNTER already defined
#endif
/** \brief indicator cycle counter */
#define DEM_INDICATOR_CYC_COUNTER    Dem_NvData.IndicatorCycleCounter

#if (defined DEM_INDICATORCOUNTER_ROLE_FAILURE_CYCLE_COUNTER)
#error DEM_INDICATORCOUNTER_ROLE_FAILURE_CYCLE_COUNTER already defined
#endif
/** \brief indicator cycle counter role is failure cycle counter */
#define DEM_INDICATORCOUNTER_ROLE_FAILURE_CYCLE_COUNTER 0U

#if (defined DEM_INDICATORCOUNTER_ROLE_HEALING_CYCLE_COUNTER)
#error DEM_INDICATORCOUNTER_ROLE_HEALING_CYCLE_COUNTER already defined
#endif
/** \brief indicator cycle counter role is healing cycle counter */
#define DEM_INDICATORCOUNTER_ROLE_HEALING_CYCLE_COUNTER 1U

#if (defined DEM_INDICATOR_CYC_COUNTER_ROLE)
#error DEM_INDICATOR_CYC_COUNTER_ROLE already defined
#endif
/** \brief Flags to indicate indicator cycle counter role */
#define DEM_INDICATOR_CYC_COUNTER_ROLE    Dem_NvData.IndicatorCycleCounterRole

#if (defined DEM_INDICATOR_CYC_COUNTER_WIR_STATUS)
#error DEM_INDICATOR_CYC_COUNTER_WIR_STATUS already defined
#endif
/** \brief Flags to indicate indicator cycle counter WIR status */
#define DEM_INDICATOR_CYC_COUNTER_WIR_STATUS \
  Dem_NvData.IndicatorCycleCounterWIRStatus

#if (DEM_USE_AGING == STD_ON)
#if (defined DEM_AGING_ALLOWED)
#error DEM_AGING_ALLOWED already defined
#endif
/** \brief Aging enabled for an event */
#define DEM_AGING_ALLOWED(EventId)  (Dem_GbiNumAgingCycles(EventId) > 0U)
#endif

#if (defined DEM_IS_OVFIND_SET)
#error DEM_IS_OVFIND_SET  already defined
#endif
/** \brief Is bit set in OverflowFlags */
#define DEM_IS_OVFIND_SET(originIdx) \
  (DEM_IS_BIT_SET(DEM_OVFIND_FLAGS, (uint8) (1U << (originIdx)) ))

#if (defined DEM_NUMFF)
#error DEM_NUMFF already defined
#endif
/** \brief Get NumFF for an event memory entry */
#define DEM_NUMFF(EvMemEntry, MaxNumFF) \
  (((EvMemEntry)->OccCtr > (MaxNumFF)) ? (MaxNumFF) : (EvMemEntry)->OccCtr)

#if (defined DEM_ERRORQUEUE_GET_EVST)
#error DEM_ERRORQUEUE_GET_EVST already defined
#endif
/** \brief Get event status from error-queue entry */
#define DEM_ERRORQUEUE_GET_EVST(ErrorQueueEntry) \
  ((uint8)((ErrorQueueEntry) >> 15U))

#if (defined DEM_ERRORQUEUE_GET_EVID)
#error DEM_ERRORQUEUE_GET_EVID already defined
#endif
/** \brief Get event Id from error-queue entry */
#define DEM_ERRORQUEUE_GET_EVID(ErrorQueueEntry) \
  ((uint16)((ErrorQueueEntry) & (uint16)0x7FFFU))

#if (defined DEM_IS_EV_ST_BIT_SET)
#error DEM_IS_EV_ST_BIT_SET already defined
#endif
/** \brief Is any bit set from mask in DTC status of event */
#define DEM_IS_EV_ST_BIT_SET(EventId, Mask) \
  DEM_IS_BIT_SET(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_IS_EV_ST_BIT_TNCTOC_SET)
#error DEM_IS_EV_ST_BIT_TNCTOC_SET already defined
#endif
/** \brief Check if TNCTOC bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_TNCTOC_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_DTCSTATUSBIT_TNCTOC)

#if (defined DEM_IS_EV_ST_BIT_TFTOC_SET)
#error DEM_IS_EV_ST_BIT_TFTOC_SET already defined
#endif
/** \brief Check if TNCTOC bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_TFTOC_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_DTCSTATUSBIT_TFTOC)

#if (defined DEM_IS_EV_ST_BIT_CDTC_SET)
#error DEM_IS_EV_ST_BIT_CDTC_SET already defined
#endif
/** \brief Check if CDTC bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_CDTC_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_DTCSTATUSBIT_CDTC)

#if (defined DEM_IS_EV_ST_BIT_WIR_SET)
#error DEM_IS_EV_ST_BIT_WIR_SET already defined
#endif
/** \brief Check if WIR bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_WIR_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_DTCSTATUSBIT_WIR)

#if (defined DEM_IS_EV_ST_BIT_TF_SET)
#error DEM_IS_EV_ST_BIT_TF_SET already defined
#endif
/** \brief Check if WIR bit set in DTC status of event */
#define DEM_IS_EV_ST_BIT_TF_SET(EventId) \
  DEM_IS_EV_ST_BIT_SET((EventId), DEM_DTCSTATUSBIT_TF)

#if (defined DEM_SET_EV_ST_MASK)
#error DEM_SET_EV_ST_MASK already defined
#endif
/** \brief Set bits in DTCStatusMask */
#define DEM_SET_EV_ST_MASK(EventId, Mask) \
  DEM_SET_MASK(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_CLR_EV_ST_MASK)
#error DEM_CLR_EV_ST_MASK already defined
#endif
/** \brief Clear bits in DTCStatusMask */
#define DEM_CLR_EV_ST_MASK(EventId, Mask) \
  DEM_CLR_MASK_8(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_CHNG_EV_ST_MASK)
#error DEM_CHNG_EV_ST_MASK already defined
#endif
/** \brief Change bits in DTCStatusMask */
#define DEM_CHNG_EV_ST_MASK(EventId, Set_Mask, Clr_Mask) \
  do                                                     \
  {                                                      \
    DEM_SET_EV_ST_MASK((EventId), (Set_Mask));           \
    DEM_CLR_EV_ST_MASK((EventId), (Clr_Mask));           \
  } while (0)

#if (defined DEM_ATOMIC_SET_EV_ST_MASK)
#error DEM_ATOMIC_SET_EV_ST_MASK already defined
#endif
/** \brief Atomic Set bits in DTCStatusMask
 *   Note: Must not be used within critical sections. */
#define DEM_ATOMIC_SET_EV_ST_MASK(EventId, Mask) \
  DEM_ATOMIC_SET_MASK(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_ATOMIC_CLR_EV_ST_MASK)
#error DEM_ATOMIC_CLR_EV_ST_MASK already defined
#endif
/** \brief Atomic Clear bits in DTCStatusMask
 *   Note: Must not be used within critical sections. */
#define DEM_ATOMIC_CLR_EV_ST_MASK(EventId, Mask) \
  DEM_ATOMIC_CLR_MASK(DEM_DTC_STATUS_MASKS[(EventId)], (Mask))

#if (defined DEM_ATOMIC_CHNG_EV_ST_MASK)
#error DEM_ATOMIC_CHNG_EV_ST_MASK already defined
#endif
/** \brief Atomic Change bits in DTCStatusMask
 *   Note: Must not be used within critical sections. */
#define DEM_ATOMIC_CHNG_EV_ST_MASK(EventId, Set_Mask, Clr_Mask) \
  DEM_ATOMIC_CHNG_MASK(DEM_DTC_STATUS_MASKS[(EventId)], (Set_Mask), (Clr_Mask))

/*------------------[Event description element offsets & masks]-------------*/

/* Independent values: offset, mask (only depends on static value widths) */

/* 1st 32 bits of event description layout */

#if (defined DEM_UDS_DTC_OFFSET)
#error DEM_UDS_DTC_OFFSET already defined
#endif
/** \brief Offset of DTC value in 1st element of event desc */
#define DEM_UDS_DTC_OFFSET           0U

#if (defined DEM_UDS_DTC_MASK)
#error DEM_UDS_DTC_MASK already defined
#endif
/** \brief Mask of DTC value in 1st element of event desc */
#define DEM_UDS_DTC_MASK             ((1UL << DEM_UDS_DTC_WIDTH) - 1UL)


#if (defined DEM_DTCORIGIN_OFFSET)
#error DEM_DTCORIGIN_OFFSET already defined
#endif
/** \brief Offset of DTC origin in 1st element of event desc */
#define DEM_DTCORIGIN_OFFSET         (DEM_UDS_DTC_OFFSET + DEM_UDS_DTC_WIDTH)

#if (defined DEM_DTCORIGIN_MASK)
#error DEM_DTCORIGIN_MASK already defined
#endif
/** \brief Mask of DTC origin in 1st element of event desc */
#define DEM_DTCORIGIN_MASK           ((1UL << DEM_DTCORIGIN_WIDTH) - 1UL)


#if (defined DEM_DTCGROUP_OFFSET)
#error DEM_DTCGROUP_OFFSET already defined
#endif
/** \brief Offset of DTC group in 1st element of event desc */
#define DEM_DTCGROUP_OFFSET          (DEM_DTCORIGIN_OFFSET + DEM_DTCORIGIN_WIDTH)

#if (defined DEM_DTCGROUP_MASK)
#error DEM_DTCGROUP_MASK already defined
#endif
/** \brief Mask of DTC group in 1st element of event desc */
#define DEM_DTCGROUP_MASK            ((1UL << DEM_DTCGROUP_WIDTH) - 1UL)


#if (defined DEM_IMMEDIATESTORAGE_OFFSET)
#error DEM_IMMEDIATESTORAGE_OFFSET already defined
#endif
/** \brief Offset of Immediate storage status in 2nd element of event desc */
#define DEM_IMMEDIATESTORAGE_OFFSET  (DEM_DTCGROUP_OFFSET + DEM_DTCGROUP_WIDTH)

#if (defined DEM_IMMEDIATESTORAGE_MASK)
#error DEM_IMMEDIATESTORAGE_MASK already defined
#endif
/** \brief Mask of Immediate storage status in 2nd element of event desc */
#define DEM_IMMEDIATESTORAGE_MASK    ((1UL << DEM_IMMEDIATESTORAGE_WIDTH) - 1UL)

/* 2nd 32 bits of event description layout */

#if (defined DEM_DTCSEVERITY_OFFSET)
#error DEM_DTCSEVERITY_OFFSET already defined
#endif
/** \brief Offset of DTC severity in 2nd element of event desc */
#define DEM_DTCSEVERITY_OFFSET       0U

#if (defined DEM_DTCSEVERITY_MASK)
#error DEM_DTCSEVERITY_MASK already defined
#endif
/** \brief Mask of DTC severity in 2nd element of event desc */
#define DEM_DTCSEVERITY_MASK         ((1UL << DEM_DTCSEVERITY_WIDTH) - 1UL)


#if (defined DEM_ENABLEPRESTORAGE_OFFSET)
#error DEM_ENABLEPRESTORAGE_OFFSET already defined
#endif
/** \brief Offset of Prestorage status in 2nd element of event desc */
#define DEM_ENABLEPRESTORAGE_OFFSET  (DEM_DTCSEVERITY_OFFSET + DEM_DTCSEVERITY_WIDTH)

#if (defined DEM_ENABLEPRESTORAGE_MASK)
#error DEM_ENABLEPRESTORAGE_MASK already defined
#endif
/** \brief Mask of Prestorage status in 2nd element of event desc */
#define DEM_ENABLEPRESTORAGE_MASK    ((1UL << DEM_ENABLEPRESTORAGE_WIDTH) - 1UL)


#if (defined DEM_FFCLASSIDX_OFFSET)
#error DEM_FFCLASSIDX_OFFSET already defined
#endif
/** \brief Offset of FF class index in 2nd element of event desc */
#define DEM_FFCLASSIDX_OFFSET        (DEM_ENABLEPRESTORAGE_OFFSET + DEM_ENABLEPRESTORAGE_WIDTH)

/* Dependent values: offset, mask (depends on configurable value width) */

#if (defined DEM_FFCLASSIDX_MASK)
#error DEM_FFCLASSIDX_MASK already defined
#endif
/** \brief Mask of FF class index in 2nd element of event desc */
#define DEM_FFCLASSIDX_MASK          ((1UL << DEM_FFCLASSIDX_WIDTH) - 1UL)


#if (defined DEM_FFRECINFO_OFFSET)
#error DEM_FFRECINFO_OFFSET already defined
#endif
/** \brief Offset of maximum FF number (if record numeration type is calculated)
 ** or index to freeze frame record numeration class (if record numeration
 ** type is configured) in 2nd element of event desc
 */
#define DEM_FFRECINFO_OFFSET         (DEM_FFCLASSIDX_OFFSET + DEM_FFCLASSIDX_WIDTH)

#if (defined DEM_FFRECINFO_MASK)
#error DEM_FFRECINFO_MASK already defined
#endif
/** \brief Mask of maximum FF number (if record numeration type is calculated)
 ** or index to freeze frame record numeration class (if record numeration
 ** type is configured) in 2nd element of event desc
 */
#define DEM_FFRECINFO_MASK           ((1UL << DEM_FFRECINFO_WIDTH) - 1UL)


#if (defined DEM_EDCLASSIDX_OFFSET)
#error DEM_EDCLASSIDX_OFFSET already defined
#endif
/** \brief Offset of ED class index in 2nd element of event desc */
#define DEM_EDCLASSIDX_OFFSET        (DEM_FFRECINFO_OFFSET + DEM_FFRECINFO_WIDTH)

#if (defined DEM_EDCLASSIDX_MASK)
#error DEM_EDCLASSIDX_MASK already defined
#endif
/** \brief Mask of ED class index in 2nd element of event desc */
#define DEM_EDCLASSIDX_MASK          ((1UL << DEM_EDCLASSIDX_WIDTH) - 1UL)


#if (defined DEM_OPCYCLEIDX_OFFSET)
#error DEM_OPCYCLEIDX_OFFSET already defined
#endif
/** \brief Offset of Operation cycle index in 2nd element of event desc */
#define DEM_OPCYCLEIDX_OFFSET        (DEM_EDCLASSIDX_OFFSET + DEM_EDCLASSIDX_WIDTH)

#if (defined DEM_OPCYCLEIDX_MASK)
#error DEM_OPCYCLEIDX_MASK already defined
#endif
/** \brief Mask of Operation cycle index in 2nd element of event desc */
#define DEM_OPCYCLEIDX_MASK          ((1UL << DEM_OPCYCLEIDX_WIDTH) - 1UL)


#if (defined DEM_AGINGCYCLES_OFFSET)
#error DEM_AGINGCYCLES_OFFSET already defined
#endif
/** \brief Offset of Aging cycle in 2nd element of event desc */
#define DEM_AGINGCYCLES_OFFSET     (DEM_OPCYCLEIDX_OFFSET + DEM_OPCYCLEIDX_WIDTH)

#if (defined DEM_AGINGCYCLES_MASK)
#error DEM_AGINGCYCLES_MASK already defined
#endif
/** \brief Mask of Aging cycle in 2nd element of event desc */
#define DEM_AGINGCYCLES_MASK       ((1UL << DEM_AGINGCYCLES_WIDTH) - 1UL)


#if (defined DEM_EVENTKIND_OFFSET)
#error DEM_EVENTKIND_OFFSET already defined
#endif
/** \brief Offset of Event kind in 2nd element of event desc */
#define DEM_EVENTKIND_OFFSET       (DEM_AGINGCYCLES_OFFSET + DEM_AGINGCYCLES_WIDTH)

#if (defined DEM_EVENTKIND_MASK)
#error DEM_EVENTKIND_MASK already defined
#endif
/** \brief Mask of Event kind in 2nd element of event desc */
#define DEM_EVENTKIND_MASK         ((1UL << DEM_EVENTKIND_WIDTH) - 1UL)


#if (defined DEM_EVENTFAILURECLASSIDX_OFFSET)
#error DEM_EVENTFAILURECLASSIDX_OFFSET already defined
#endif
/** \brief Offset of Event failure class index in 2nd element of event desc */
#define DEM_EVENTFAILURECLASSIDX_OFFSET  (DEM_EVENTKIND_OFFSET + DEM_EVENTKIND_WIDTH)

#if (defined DEM_EVENTFAILURECLASSIDX_MASK)
#error DEM_EVENTFAILURECLASSIDX_MASK already defined
#endif
/** \brief Mask of Event failure class index in 2nd element of event desc */
#define DEM_EVENTFAILURECLASSIDX_MASK    ((1UL << DEM_EVENTFAILURECLASSIDX_WIDTH) - 1UL)

/* check if size of 2nd part of event description layout is maximal 32 bits */
#if ( (DEM_EVENTFAILURECLASSIDX_OFFSET + DEM_EVENTFAILURECLASSIDX_WIDTH) > 32U )
#error Event-Configuration-Layout Part Nr. 2 needs too much space.
#endif

/* 3rd 32 bits of event description layout */

#if (defined DEM_ENCONDIDX_OFFSET)
#error DEM_ENCONDIDX_OFFSET already defined
#endif
/** \brief Offset of Enable condition index in 3rd element of event desc */
#define DEM_ENCONDIDX_OFFSET         0U

#if (defined DEM_ENCONDIDX_MASK)
#error DEM_ENCONDIDX_MASK already defined
#endif
/** \brief Mask of Enable condition index in 3rd element of event desc */
#define DEM_ENCONDIDX_MASK           ((1UL << DEM_ENCONDIDX_WIDTH) - 1UL)


#if (defined DEM_NUMENCOND_OFFSET)
#error DEM_NUMENCOND_OFFSET already defined
#endif
/** \brief Offset of number of Enable conditions in 3rd element of event desc */
#define DEM_NUMENCOND_OFFSET         (DEM_ENCONDIDX_OFFSET + DEM_ENCONDIDX_WIDTH)

#if (defined DEM_NUMENCOND_MASK)
#error DEM_NUMENCOND_MASK already defined
#endif
/** \brief Mask of number of Enable conditions in 3rd element of event desc */
#define DEM_NUMENCOND_MASK           ((1UL << DEM_NUMENCOND_WIDTH) - 1UL)


#if (defined DEM_INDICATORUSED_OFFSET)
#error DEM_INDICATORUSED_OFFSET already defined
#endif
/** \brief Offset of Indicator status in 3rd element of event desc */
#define DEM_INDICATORUSED_OFFSET     (DEM_NUMENCOND_OFFSET + DEM_NUMENCOND_WIDTH)

#if (defined DEM_INDICATORUSED_MASK)
#error DEM_INDICATORUSED_MASK already defined
#endif
/** \brief Mask of Indicator status in 3rd element of event desc */
#define DEM_INDICATORUSED_MASK       ((1UL << DEM_INDICATORUSED_WIDTH) - 1UL)


#if (defined DEM_PRIORITY_OFFSET)
#error DEM_PRIORITY_OFFSET already defined
#endif
/** \brief Offset of Internal priority in 3rd element of event desc */
#define DEM_PRIORITY_OFFSET          (DEM_INDICATORUSED_OFFSET + DEM_INDICATORUSED_WIDTH)

#if (defined DEM_PRIORITY_MASK)
#error DEM_PRIORITY_MASK already defined
#endif
/** \brief Mask of Internal priority in 3rd element of event desc */
#define DEM_PRIORITY_MASK            ((1UL << DEM_PRIORITY_WIDTH) - 1UL)


#if (defined DEM_DEBOUNCEALGO_OFFSET)
#error DEM_DEBOUNCEALGO_OFFSET already defined
#endif
/** \brief Offset of Debounce algorithm in 3rd element of event desc */
#define DEM_DEBOUNCEALGO_OFFSET      (DEM_PRIORITY_OFFSET + DEM_PRIORITY_WIDTH)

#if (defined DEM_DEBOUNCEALGO_MASK)
#error DEM_DEBOUNCEALGO_MASK already defined
#endif
/** \brief Mask of Debounce algorithm in 3rd element of event desc */
#define DEM_DEBOUNCEALGO_MASK        ((1UL << DEM_DEBOUNCEALGO_WIDTH) - 1UL)


#if (defined DEM_DEBOUNCEIDX_OFFSET)
#error DEM_DEBOUNCEIDX_OFFSET already defined
#endif
/** \brief Offset of Debounce algorithm index in 3rd element of event desc */
#define DEM_DEBOUNCEIDX_OFFSET       (DEM_DEBOUNCEALGO_OFFSET + DEM_DEBOUNCEALGO_WIDTH)

#if (defined DEM_DEBOUNCEIDX_MASK)
#error DEM_DEBOUNCEIDX_MASK already defined
#endif
/** \brief Mask of Debounce algorithm index in 3rd element of event desc */
#define DEM_DEBOUNCEIDX_MASK         ((1UL << DEM_DEBOUNCEIDX_WIDTH) - 1UL)


#if (defined DEM_DTCFUNCTIONALUNIT_OFFSET)
#error DEM_DTCFUNCTIONALUNIT_OFFSET already defined
#endif
/** \brief Offset of DTC functional unit in 3rd element of event desc */
#define DEM_DTCFUNCTIONALUNIT_OFFSET (DEM_DEBOUNCEIDX_OFFSET + DEM_DEBOUNCEIDX_WIDTH)

#if (defined DEM_DTCFUNCTIONALUNIT_MASK)
#error DEM_DTCFUNCTIONALUNIT_MASK already defined
#endif
/** \brief Mask of DTC functional unit in 3rd element of event desc */
#define DEM_DTCFUNCTIONALUNIT_MASK   ((1UL << DEM_DTCFUNCTIONALUNIT_WIDTH) - 1UL)


#if (defined DEM_AGINGCYCLEIDX_OFFSET)
#error DEM_AGINGCYCLEIDX_OFFSET already defined
#endif
/** \brief Offset of Aging cycle index in 3rd element of event desc */
#define DEM_AGINGCYCLEIDX_OFFSET        (DEM_DTCFUNCTIONALUNIT_OFFSET + DEM_DTCFUNCTIONALUNIT_WIDTH)

#if (defined DEM_AGINGCYCLEIDX_MASK)
#error DEM_AGINGCYCLEIDX_MASK already defined
#endif
/** \brief Mask of Aging cycle index in 3rd element of event desc */
#define DEM_AGINGCYCLEIDX_MASK          ((1UL << DEM_AGINGCYCLEIDX_WIDTH) - 1UL)

/* check if size of 3rd part of event description layout is maximal 32 bits */
#if ( (DEM_AGINGCYCLEIDX_OFFSET + DEM_AGINGCYCLEIDX_WIDTH) > 32U )
#error Event-Configuration-Layout Part Nr. 3 needs too much space.
#endif

/*--------------------------------------------------------------------------*/

#if (defined DEM_MAX_EVENTID)
#error DEM_MAX_EVENTID already defined
#endif
/** \brief largest event Id configured in Dem */
#define DEM_MAX_EVENTID            (DEM_NUMBER_OF_EVENTS - 1U)

#if (defined DEM_NVM_SID_WriteBlock)
#error DEM_NVM_SID_WriteBlock already defined
#endif
/** \brief Service Id of NvM_WriteBlock() */
#define DEM_NVM_SID_WriteBlock      0x07U

/*--------------------------------------------------------------------------*/

#if (defined DEM_NVM_IDLE)
#error DEM_NVM_IDLE already defined
#endif
/** \brief Dem Nvm state: No dataset processed */
#define DEM_NVM_IDLE    0U

#if (defined DEM_NVM_PREPARE)
#error DEM_NVM_PREPARE already defined
#endif
/** \brief Dem Nvm state: Event memory entry being transferred to gate */
#define DEM_NVM_PREPARE 1U

#if (defined DEM_NVM_WAITING)
#error DEM_NVM_WAITING already defined
#endif
/** \brief Dem Nvm state: One gate entry ready to be written */
#define DEM_NVM_WAITING 2U

#if (defined DEM_NVM_PENDING)
#error DEM_NVM_PENDING already defined
#endif
/** \brief Dem Nvm state: Writing gate entry */
#define DEM_NVM_PENDING 3U


#if (defined DEM_GATE_UNUSED)
#error DEM_GATE_UNUSED already defined
#endif
/** \brief Dem gate entry state: Gate entry not in use */
#define DEM_GATE_UNUSED   0U

#if (defined DEM_GATE_READY)
#error DEM_GATE_READY already defined
#endif
/** \brief Dem gate entry state: Gate locked and ready to receive data */
#define DEM_GATE_READY    1U

#if (defined DEM_GATE_PREPARED)
#error DEM_GATE_PREPARED already defined
#endif
/** \brief Dem gate entry state: Gate entry prepared, ready to be written */
#define DEM_GATE_PREPARED 2U

#if (defined DEM_GATE_LOCKED)
#error DEM_GATE_LOCKED already defined
#endif
/** \brief Dem gate entry state: Gate locked by another process */
#define DEM_GATE_LOCKED   3U


#if (defined DEM_NVM_NO_FORCE)
#error DEM_NVM_NO_FORCE already defined
#endif
/** \brief Nv storage limit: Do not force immediate storage */
#define DEM_NVM_NO_FORCE FALSE

#if (defined DEM_NVM_FORCE)
#error DEM_NVM_FORCE already defined
#endif
/** \brief Nv storage limit: Force immediate storage
 **
 ** Immediate storage will be performed for events with immediate storage
 ** disabed, also if limit was reached already. */
#define DEM_NVM_FORCE    TRUE

/*==================[type definitions]======================================*/

/*------------------[pointer types]-----------------------------------------*/

/** \brief Pointer to ::Dem_EventMemoryEntryType */
typedef P2VAR(Dem_EventMemoryEntryType, TYPEDEF, DEM_VAR_NOINIT)
  Dem_EventMemoryEntryPtrType;

/** \brief Pointer to const ::Dem_EventMemoryEntryType */
typedef P2CONST(Dem_EventMemoryEntryType, TYPEDEF, DEM_VAR_NOINIT)
  Dem_EventMemoryEntryPtrConstType;

/*------------------[definitions for debouncing]----------------------------*/

/** \brief Configuration description of counter based debouncing algorithm */
typedef struct
{
  uint16  CountDecStepSize;   /**< step size for decrementation (PREPASSED) */
  uint16  CountIncStepSize;   /**< step size for incrementation (PREFAILED) */
  sint16  CounterPassedThreshold;          /**< threshold for Passed status */
  sint16  CounterFailedThreshold;          /**< threshold for Failed status */
  sint16  JumpDownValue;                               /**< Jump-down value */
  sint16  JumpUpValue;                                   /**< Jump-up value */
  boolean JumpDown;                           /**< Jump-down enabled switch */
  boolean JumpUp;                               /**< Jump-up enabled switch */
#if ( (DEM_OPCYC_NVSTORAGE == STD_ON) &&(DEM_NUM_DEBOUNCE_COUNTER_PERM > 0) )
  boolean PermCtrStorage; /**< non-volatile debounce counter storage switch */
#endif
} Dem_DebounceCounterCfgType;

/** \brief Configuration description of time based debouncing algorithm */
typedef struct
{
  uint32          TimeFailedThreshold;
                         /**< "event failed" timeout in main function ticks */
  uint32          TimePassedThreshold;
                         /**< "event passed" timeout in main function ticks */
  Dem_EventIdType EventId;            /**< event id for backwards reference */
} Dem_DebounceTimeCfgType;

/** \brief Status information for time based debouncing algorithm */
typedef struct
{
  uint32              InternalTimer;
     /**< remaining timer value in main function ticks, 0=timer not running */
  Dem_EventStatusType Direction;                       /**< timer direction */
} Dem_DebounceTimeStatusType;

/** \brief Configuration description of frequency based debouncing algorithm */
typedef struct
{
  uint32          TimeWindowDuration;
                        /**< duration of time window in main function ticks */
  uint16          ThresholdBeforeEvFailed;
                       /**< threshold for "failed" counter decreased by one */
  uint16          ThresholdBeforeEvPassed;
                       /**< threshold for "passed" counter decreased by one */
  Dem_EventIdType EventId;            /**< event id for backwards reference */
} Dem_DebounceFrequencyCfgType;

/** \brief Status information for frequency based debouncing algorithm */
typedef struct
{
  uint32              InternalTimer;
     /**< remaining timer value in main function ticks, 0=timer not running */
  uint16              PassedCounter;         /**< value of "passed" counter */
  uint16              FailedCounter;         /**< value of "failed" counter */
  Dem_EventStatusType Status;                        /**< debouncing status */
} Dem_DebounceFrequencyStatusType;

/*------------------[definitions for Warning indicators]--------------------*/

/** \brief This type is used as index type for the indicator links
 **
 ** Used to access ::Dem_IndicatorLink[].
 **
 ** Its size is derived from the number of warning indicator-links
 */
#if (DEM_NUM_INDICATOR_LINKS < 256U)
typedef uint8 Dem_IndicatorLnkIdxType;
#elif (DEM_NUM_INDICATOR_LINKS < 65536U)
typedef uint16 Dem_IndicatorLnkIdxType;
#else
typedef uint32 Dem_IndicatorLnkIdxType;
#endif

/** \brief This type is used as index type for the configuration healing
 **  cycle-counter information table
 **
 ** Used to access ::Dem_HealingCycleCounterInfo[].
 **
 ** Its size is derived from the number of unique healing cycles and
 ** threshold pair configured
 */
#if (DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS < 256U)
typedef uint8 Dem_HealingCycleCounterInfoIdxType;
#elif (DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS < 65536U)
typedef uint16 Dem_HealingCycleCounterInfoIdxType;
#else
#error Too many healing cycles configured.
#endif

/** \brief This type is used as index type for the configuration failure
 ** cycle-counter information table
 **
 ** Used to access ::Dem_FailureCycleCounterInfo[].
 **
 ** Its size is derived from the number of unique failure cycles and
 ** threshold pair configured
 */
#if (DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS < 256U)
typedef uint8 Dem_FailureCycleCounterInfoIdxType;
#elif (DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS < 65536U)
typedef uint16 Dem_FailureCycleCounterInfoIdxType;
#else
#error Too many failure cycles configured.
#endif

/** \brief This type is used as index type for indicator cycle counter data arrays
 **
 ** Used to access ::IndicatorCycleCounter[], IndicatorCycleCounterRole[] and
 ** IndicatorCycleCounterWIRStatus[].
 **
 ** Its size is derived from the number of warning indicator-link
 */
#if (DEM_NUM_INDICATOR_LINKS < 256U)
typedef uint8 Dem_CounterDataIdxType;
#elif (DEM_NUM_INDICATOR_LINKS < 65536U)
typedef uint16 Dem_CounterDataIdxType;
#else
typedef uint32 Dem_CounterDataIdxType;
#endif

/** \brief Type defining the indicator counter threshold */
typedef uint8 Dem_CounterThresholdType;

/** \brief Type defining the operation cycle reference */
typedef uint8 Dem_OperationCycleRefType;

/** \brief indicator cycle counter role type type */
typedef boolean Dem_IndicatorCounterDataRoleType;

/** \brief Type used for the warning indicator configuration description */
typedef struct
{
  Dem_EventIdType Number;
                        /**< Number of events assigned to this indicator */
  uint32          StartIdx;
             /**< Index in Dem_IndicatorLink[], where the links for this
               * indicators begin - may be invalid if Number is 0 */
} Dem_IndicatorDescType;

/** \brief Type used for the warning indicator-link configuration list */
typedef struct
{
  Dem_EventIdType         EventId;
                    /**< Event Id to which this indicator is linked to */
  Dem_IndicatorStatusType            Behaviour;
     /**< Indicator behaviour (which does not use ::DEM_INDICATOR_OFF) */
  Dem_CounterDataIdxType             CounterDataIdx;
                                 /**< Index in IndicatorCycleCounter[] */
  Dem_HealingCycleCounterInfoIdxType HealingCycleCounterInfoIdx;
                           /**< Index in Dem_HealingCycleCounterInfo[] */
  Dem_FailureCycleCounterInfoIdxType FailureCycleCounterInfoIdx;
                           /**< Index in Dem_FailureCycleCounterInfo[] */
} Dem_IndicatorLinkType;

/** \brief Type used for the warning indicator cycle-counter info table */
typedef struct
{
  Dem_OperationCycleRefType  OperationCycleRef;
                           /**< Reference for failure/healing cycle source */
  Dem_CounterThresholdType   Threshold;
              /**< Threshold for indicator (failure/healing) cycle counter */
} Dem_CounterInfoType;

/*------------------[callback types]----------------------------------------*/

/** \brief Type defining the C/RTE-callback properties of an event */
typedef uint8 Dem_CbPropertyType;

/** \brief Identifier type for the callback functions */
typedef Dem_EventIdType Dem_CbIndexType;

/** \brief Type defining the callback function lookup tables */
typedef struct
{
  Dem_EventIdType  EventId;                     /**< event */
  Dem_CbIndexType CallbackIdx; /**< Index of the callback */
} Dem_CbLookupTableType;

/** \brief Function pointer type for generic "InitMonitor callback" function
 **
 ** This prototype is identical for C- and RTE-callbacks. */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrInitMonitorType) (
  Dem_InitMonitorReasonType InitMonitorReason);

/** \brief Function pointer type for generic "TriggerOnEventStatus C-callback"
 ** function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_CbFuncPtrTrigOnEvStType) (
  Dem_EventIdType             EventId,
  Dem_EventStatusExtendedType EventStatusOld,
  Dem_EventStatusExtendedType EventStatusNew);

/** \brief Function pointer type for generic "TriggerOnEventStatus RTE-
 ** callback" function */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_RteFuncPtrTrigOnEvStType) (
  Dem_EventStatusExtendedType EventStatusOld,
  Dem_EventStatusExtendedType EventStatusNew);

/** \brief Function pointer type for generic "TriggerOnDTCStatus callback"
 ** function
 **
 ** This prototype is identical for C- and RTE-callbacks. */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrTrigOnDTCStType) (
  uint32 DTC,
  uint8  DTCStatusOld,
  uint8  DTCStatusNew);

/** \brief Function pointer type for generic "TriggerOnEventData C-callback"
 ** function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_CbFuncPtrTrigOnEvDatType ) (
  Dem_EventIdType EventId);

/** \brief Function pointer type for generic "TriggerOnEventData RTE-callback"
 ** function */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_RteFuncPtrTrigOnEvDatType ) (
  void);

/** \brief Function pointer type for generic "GetFaultDetectionCounter
 ** callback" function
 **
 ** This prototype is identical for C- and RTE-callbacks. */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrGetFDCType) (
  P2VAR(Dem_FaultDetectionCounterType, AUTOMATIC, DEM_APPL_DATA)
    FaultDetectionCounter);

/** \brief Function pointer type for generic "ClearEventAllowed callback"
 ** function
 **
 ** This prototype is identical for C- and RTE-callbacks. */
typedef
  P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrClearEventAllowedType) (
    P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) Allowed);

/** \brief Function pointer type for generic "ReadDataElement C-callback"
 ** function */
typedef
  P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_CbFuncPtrReadDataElementType) (
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Buffer);

/** \brief Function pointer type for generic "ReadDataElement RTE-callback"
 ** function */
typedef
  P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_RteFuncPtrReadDataElementType) (
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Data);

/** \brief Function pointer type for generic "Reset Counters" function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_DebounceResetFctPtrType) (
  Dem_EventIdType EventId);

/** \brief Function pointer type for generic "DebounceEvent" function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_DebounceEventFctPtrType) (
  Dem_EventIdType                                      EventId,
  CONSTP2VAR(Dem_EventStatusType, AUTOMATIC, DEM_APPL_DATA) EventStatus);

/** \brief Function pointer type for generic "GetFDC" function */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_DebounceGetFDCFctPtrType) (
  Dem_EventIdType                                                EventId,
  CONSTP2VAR(Dem_FaultDetectionCounterType, AUTOMATIC, DEM_APPL_DATA) FDC);

/*--------------------------------------------------------------------------*/

/** \brief Type for debouncing function pointer table entries */
typedef struct
{
  Dem_DebounceResetFctPtrType  ResetFct;
               /**< reset status (Dem_ClearDTC, Dem_SetOperationCycleState) */
  Dem_DebounceEventFctPtrType  DebounceEventFct;
            /**< debounce event (Dem_ReportErrorStatus, Dem_SetEventStatus) */
  Dem_DebounceGetFDCFctPtrType GetFDCFct;
                                  /**< return fault detection counter value */
} Dem_DebounceFctPtrTableType;

/** \brief This type is used as index type for the enable condition links
 **
 ** Used to access ::Dem_EnCondLink[].
 **
 ** Its size is derived from the different enable condition 'groups' (assigned
 ** to the events).
 */
#if (DEM_NUM_ENCOND_LINKS < 256U)
typedef uint8 Dem_EnCondLnkIdxType;
#elif (DEM_NUM_ENCOND_LINKS < 65536U)
typedef uint16 Dem_EnCondLnkIdxType;
#else
#error Too many enable conditions assigned.
#endif

/** \brief Status of the DTC Filter */
typedef struct
{
  Dem_DTCStatusMaskType      DTCStatusMask;  /**< Filter mask on DTC status */
  Dem_DTCKindType            DTCKind;                      /**< Kind of DTC */
  Dem_DTCFormatType          DTCFormat;             /**<output-format of DTC*/
  Dem_DTCOriginType          DTCOrigin;                  /**< Origin of DTC */
  Dem_FilterWithSeverityType FilterWithSeverity;
                                            /**< Use severity for filtering */
  Dem_DTCSeverityType        DTCSeverityMask;  /**< Severity to filter with */
  Dem_FilterForFDCType       FilterForFDC;       /**< Use FDC for filtering */
  Dem_EvIdMaxType            NextEventId;    /**< Index of DTC to read next */
} Dem_DTCFilterType;

/*------------------[Immediate storag event memory entry block types]-------*/

/** \brief Global gate status type referring NvM write status */
typedef uint8 Dem_NvMGateStatusType;

/** \brief Locate gate status type referring data preparation status */
typedef uint8 Dem_NvMGatePrepStatusType;

typedef CONSTP2VAR(Dem_NvMGatePrepStatusType, AUTOMATIC, AUTOMATIC)
  Dem_NvMGatePrepStatusPtrType;

/** \brief Local NvM status referring each individual gate entry */
typedef struct {
  /** NvM gate write status */
  Dem_NvMGateStatusType Status;
  /** Event memory entry index of related event */
  uint8 PendingEntryIdx;
} Dem_NvMStatusType;

/*------------------[ClearDTC non-volatile behavior types]------------------*/

/** \brief Run state type of an asynchronous ClearDTC processing */
typedef uint8 Dem_ClearDtcRunStateType;

/** \brief Status of an asynchronous ClearDTC processing */
typedef struct
{
  /** Write state of Dem status block (containing the event status bytes) */
  Dem_NvMGateStatusType EventStatusWrite;
#if (DEM_CLEAR_DTC_BEHAVIOR == DEM_CLRRESP_NONVOLATILE_TRIGGER)
  /** Flag to re-trigger status block from its NvM single block callback */
  boolean RetriggerEventStatusWrite;
#endif
#if (DEM_CLEAR_DTC_BEHAVIOR == DEM_CLRRESP_NONVOLATILE_FINISH)
  /** Write state of event entry block(s) */
  Dem_NvMGateStatusType EventMemWrite;
  /** Global ClearDTC run state */
  Dem_ClearDtcRunStateType RunState;
  /** Origin of entries to be cleared */
  uint8 OriginIdx;
#endif
} Dem_ClearDtcStatusType;

/*--------------------------------------------------------------------------*/

/** \brief Structure collecting information for delayed status notifications */
typedef struct
{
  /** Notification data "OnEventStatusChanged" for a replaced event */
  Dem_EventStatusChangedMsgType ReplacedEventMsg;
#if ( (DEM_USE_CB_TRIG_ON_EVST == STD_ON) || \
      (DEM_USE_CB_TRIG_ON_DTCST == STD_ON) )
  /** Notification data "OnEventStatusChanged" for a new event */
  Dem_EventStatusChangedMsgType ProcessedEventMsg;
#endif
#if ((DEM_USE_CB_TRIG_ON_EVDAT == STD_ON) && \
     ((DEM_NUM_EDSEGS > 0U) || (DEM_NUM_FFSEGS > 0U)))
  /** Notification data "EventDataChanged" for a new event */
  Dem_EventIdType TriggerOnEventData;
#endif
} Dem_EventNotificationDataType;

/** \brief Pointer to a Dem_EventNotificationData */
typedef P2VAR(Dem_EventNotificationDataType, AUTOMATIC, AUTOMATIC)
  Dem_EventNotificationDataPtrType;

/*==================[external function declarations]========================*/

#define DEM_START_SEC_CODE
#include <MemMap.h>

#if (DEM_MAX_NUMBER_PRESTORED_FF > 0U)
/** \brief Function to get the index of a prestored freeze frame
 **
 ** This is done by searching in the event description array.
 **
 ** ATTENTION: If an event ID where prestorage of freeze frames is disabled
 ** is given, the index of the last event where prestorage is enabled is
 ** returned.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Index of the prestored freeze frame
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GetPFFIndex(
  Dem_EventIdType EventId);
#endif

#if (DEM_NUM_INDICATOR_LINKS > 0U)
/** \brief Function to get the index of a WIR On-Criteria fulfilled flag
 **
 ** This is done by searching in the event description array.
 **
 ** ATTENTION: If an event ID where indicator is not configured
 ** is given, the index of the last event where indicator is configured is
 ** returned.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Index of the WIR On-Criteria fulfilled flag
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GetWIROnCriteriaFulfilledFlagsIdx(
  Dem_EventIdType EventId);
#endif

#if (DEM_NUM_BSWEVENT_INDICATOR_USED > 0U)
/** \brief Function to get the index of a BSW event WIR status flag
 **
 ** This is done by searching in the event description array.
 **
 ** ATTENTION: If an event ID where indicator is not configured
 ** is given, the index of the last (BSW)event where indicator is configured is
 ** returned.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Index of the BSW event WIR status flag
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GetBSWEventWIRStatusFlagsIndex(
  const Dem_EventIdType EventId);
#endif

/** \brief Function to get the event Id of the given DTC
 **
 ** \param[in] DTC
 ** \param[in] DTCFormat
 ** \param[in] DTCOrigin
 ** \param[out] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Status of the operation of type ::Dem_ReturnGetEvIdByDTCType
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_ReturnGetEvIdByDTCType, DEM_CODE) Dem_GetEvIdByDTC(
  Dem_DTCType                                     DTC,
  Dem_DTCFormatType                               DTCFormat,
  Dem_DTCOriginType                               DTCOrigin,
  CONSTP2VAR(Dem_EventIdType, AUTOMATIC, DEM_VAR) EventId);

/** \brief Function to search for an entry in the event memory by the given
 ** event Id
 **
 ** This functions checks up the right event memory and starts the search. All
 ** entries in this memory are checked.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[out] FoundEntry
 **
 ** \return Result of the searching
 ** \retval TRUE  entry was found
 ** \retval FALSE no entry exists
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_SearchForEntry(
  Dem_EventIdType                                               EventId,
  CONSTP2VAR(Dem_EventMemoryEntryPtrType, AUTOMATIC, AUTOMATIC) FoundEntry,
  CONSTP2VAR(Dem_SizeEvMemEntryType, AUTOMATIC, AUTOMATIC)      FoundEntryIdx);

/** \brief Clear an event memory entry
 **
 ** This function clears an event memory entry including its freeze frames and
 ** extended data.
 **
 ** \param[in] EvMemEntry  Pointer to entry which shall be cleared.
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ClearEventEntry(
  const Dem_EventMemoryEntryPtrType EvMemEntry);

/** \brief Function to get the size of the event memory entry data
 ** (IntVal's + ED + FFs)
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return Size of entry data
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeEntryDataType, DEM_CODE) Dem_SizeOfEntryData(
  const Dem_EventIdType EventId);

/** \brief Function to get a pointer to the internal value entry data of an
 ** event memory entry
 **
 ** \param[in] EvMemEntry
 **
 ** \return Pointer to the internal value entry data
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_EntryDataPtrType, DEM_CODE) Dem_IntValEntryData(
  const Dem_EventMemoryEntryPtrConstType EvMemEntry);

#if (DEM_NUM_EDSEGS > 0U)
/** \brief Function to get a pointer to the ED entry data of an event memory
 ** entry
 **
 ** ED class must not be the ::Dem_NullEDClass for this event.
 **
 ** \param[in] EvMemEntry
 **
 ** \return Pointer to the ED entry data
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_EntryDataPtrType, DEM_CODE) Dem_EDEntryData(
  const Dem_EventMemoryEntryPtrConstType EvMemEntry);
#endif

#if (DEM_NUM_FFSEGS > 0U)
/** \brief Function to get a pointer to the specified FF-record entry data of
 ** an event memory entry
 **
 ** FF class must not be the ::Dem_NullFFClass for this event.
 **
 ** \param[in] EvMemEntry
 ** \param[in] FFClass
 ** \param[in] FFIndex
 **
 ** \return Pointer to the FF-record entry data
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_EntryDataPtrType, DEM_CODE) Dem_FFEntryData(
  const Dem_EventMemoryEntryPtrConstType              EvMemEntry,
  CONSTP2CONST(Dem_FFClassType, AUTOMATIC, DEM_CONST) FFClass,
  const Dem_FFIdxType                                 FFIndex);

#if (DEM_FREEZE_FRAME_REC_NUMERATION_TYPE == DEM_FF_RECNUM_CONFIGURED)
/** \brief Function to check if the requested freeze frame record number is
 ** valid
 **
 ** \param[in] EventId
 ** \param[in] RecordNumber
 **
 ** \return Boolean value indicating whether the requested freeze frame record
 **         number is valid
 ** \retval TRUE  the requested freeze frame record number is valid
 ** \retval FALSE the requested freeze frame record number is invalid
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_CheckFFRecNumValid(
  const Dem_EventIdType EventId,
  const uint8           RecordNumber);

/** \brief Function to check if the freeze frame record for the requested
 ** freeze frame record number is stored for the event
 **
 ** \param[in] EvMemEntry
 ** \param[in] RecordNumber
 **
 ** \return Index of the requested freeze frame record number if the record is
 **         stored, number of stored freeze frame records otherwise
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint8, DEM_CODE) Dem_CheckFFRecNumStored(
  const Dem_EventMemoryEntryPtrConstType EvMemEntry,
  const uint8                            RecordNumber);
#endif /* DEM_FREEZE_FRAME_REC_NUMERATION_TYPE == DEM_FF_RECNUM_CONFIGURED */
#endif /* DEM_NUM_FFSEGS > 0U */

/** \brief Error-Queue-Access-Function to invalidate specific entries
 **
 ** This function invalidates (set entry to ::DEM_EVENT_ID_INVALID) all
 ** entries with the specified event Id.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InvalidateErrorQueueEntry(
  Dem_EventIdType EventId);

/** \brief Error-Queue-Access-Function to read the latest entry
 **
 ** This function always reads and removed the next entry from the
 ** error-queue.
 **
 ** \param[out] QueueEntry
 **
 ** \return Boolean value indication success
 ** \retval TRUE entry read from error-queue
 ** \retval FALSE no entry read from error-queue as the error-queue is empty
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_ReadErrorQueueEntry(
  CONSTP2VAR(Dem_ErrorQueueEntryType, AUTOMATIC, AUTOMATIC) QueueEntry);

/** \brief Error-Queue-Access-Function to write the next entry
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 **
 ** \return Boolean value indication success
 ** \retval TRUE  an event Id was inserted to the error-queue
 ** \retval FALSE the error-queue was full
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_WriteErrorQueueEntry(
  const Dem_EventIdType     EventId,
  const Dem_EventStatusType EventStatus);

#if (DEM_NUM_FAILURECYCLES > 0U)
/** \brief This function updates the event failure counter if event memory
 ** entry exists, creates or updates the failure counter buffer otherwise
 **
 ** \param[in] EventId     1 < EventId <= DEM_MAX_EVENTID
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_IncrementFailureCounter(
  const Dem_EventIdType EventId);

#if (DEM_EVENTFAILURECOUNTER_BUFFER_SIZE > 0U)
/** \brief Function to search for an empty entry in event failure counter buffer
 **
 ** \param[out] FailureCounterBufferIdx
 **
 ** \return Result of the searching
 ** \retval TRUE  entry was found
 ** \retval FALSE no entry exists
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_SearchForEmptyFailureCounterBufferEntry(
  CONSTP2VAR(uint8, AUTOMATIC, DEM_VAR) FailureCounterBufferIdx);
#endif /* (DEM_EVENTFAILURECOUNTER_BUFFER_SIZE > 0U) */
#endif /* (DEM_NUM_FAILURECYCLES > 0U) */

/** \brief Internal function to report event status
 **
 ** This helper function is called by the APIs Dem_ReportErrorstatus(),
 ** Dem_SetEventStatus() and Dem_MainFunction().
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 **
 ** \return E_NOT_OK if EventStatus is invalid or error-queue is full, E_OK
 **         otherwise
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_InternalSetEventStatus(
  Dem_EventIdType     EventId,
  Dem_EventStatusType EventStatus);

#if (DEM_NUM_ENCOND_LINKS > 0U)
/** \brief Function to check whether an event is enabled or not
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 **
 ** \return TRUE if EventId is enabled. FALSE otherwise.
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_EventReportingEnabled(
  Dem_EventIdType EventId);
#endif

/** \brief Function to process the debouncing of an event
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 ** \param[out] debounceResult
 **
 ** \return TRUE if debouncing has qualified the event, FALSE otherwise.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_DebounceEvent(
  Dem_EventIdType                                       EventId,
  CONSTP2VAR(Dem_EventStatusType, AUTOMATIC, AUTOMATIC) EventStatus,
  CONSTP2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC)      debounceResult);

/** \brief Process event status reports for SWC events
 **
 ** This function is called by Dem_InternalSetEventStatus() to further
 ** process event status reports, individually for SWC events.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 ** \param[out] SetSwcEventStatusResult
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InternalSetSwcEventStatus(
  Dem_EventIdType                                  EventId,
  Dem_EventStatusType                              EventStatus,
  CONSTP2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) SetSwcEventStatusResult);

/** \brief Process event status reports for BSW events
 **
 ** This function is called by Dem_InternalSetEventStatus() to further
 ** process event status reports, individually for SWC events.
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 ** \param[out] SetBswEventStatusResult
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_InternalSetBswEventStatus(
  Dem_EventIdType                                  EventId,
  Dem_EventStatusType                              EventStatus,
  CONSTP2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) SetBswEventStatusResult);

/** \brief Function to update the status-byte of the event
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[in] EventStatus
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_UpdateEventStatusOnQualification(
  Dem_EventIdType     EventId,
  Dem_EventStatusType EventStatus);

/** \brief Error-Queue-Access-Function to get the most recent
 ** entry status of an event Id in the error queue
 **
 ** \param[in] EventId  0 < EventId <= DEM_MAX_EVENTID
 ** \param[out] PreviousEntryStatus
 **
 ** \return Boolean value indicating presence of event Id in error-queue
 ** \retval TRUE  an event Id was already present in the error-queue
 ** \retval FALSE event Id was not present in the error-queue
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(boolean, DEM_CODE) Dem_CheckErrorQueueEntry(
  const Dem_EventIdType                                 EventId,
  CONSTP2VAR(Dem_EventStatusType, AUTOMATIC, AUTOMATIC) PreviousEntryStatus);

#if (DEM_NUM_FFSEGS > 0U)
/** \brief Function to get the size of a freeze frame by the given freeze
 ** frame class
 **
 ** \param[in] FFClass
 **
 ** \return Size of the freeze frame class
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeFFType, DEM_CODE) Dem_SizeOfFF(
  CONSTP2CONST(Dem_FFClassType, AUTOMATIC, DEM_CONST) FFClass);

/** \brief Function to get the size of a freeze frame by the given freeze
 ** frame segment
 **
 ** \param[in] FFSegment
 **
 ** \return Size of the freeze frame segment
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeFFType, DEM_CODE) Dem_SizeOfFFSegment(
  CONSTP2CONST(Dem_FFSegmentType, AUTOMATIC, DEM_CONST) FFSegment);

/** \brief Function to get the index of a freeze frame data segment by the
 ** given DID
 **
 ** \param[in] FFClass
 ** \param[in] DataId
 **
 ** \return Index of the freeze frame segment
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_FFSegIdxType, DEM_CODE) Dem_FindDIDIndex(
  CONSTP2CONST(Dem_FFClassType, AUTOMATIC, DEM_CONST) FFClass,
  const uint16                                        DataId);
#endif

#if (DEM_NUM_EDSEGS > 0U)
/** \brief Function to get the size of an extended data by the given extended
 ** data class
 **
 ** \param[in] EDClass
 **
 ** \return Size of the extended data class
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeEDType, DEM_CODE) Dem_SizeOfED(
  CONSTP2CONST(Dem_EDClassType, AUTOMATIC, DEM_CONST) EDClass);

/** \brief Function to get the size of an extended data by the given extended
 ** data segment
 **
 ** \param[in] EDSegment
 **
 ** \return Size of the extended data segment
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_SizeEDType, DEM_CODE) Dem_SizeOfEDSegment(
  CONSTP2CONST(Dem_EDSegmentType, AUTOMATIC, DEM_CONST) EDSegment);

/** \brief Function to get the size of internal values mapped to an extended
 ** data class
 **
 ** \param[in] EDClass
 **
 ** \return Size of mapped internal values. This along with the size returned
 **         by Dem_SizeOfED() gives the size required for storing the
 **         assembled extended data class.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint8, DEM_CODE) Dem_SizeOfMapIntValClass(
  CONSTP2CONST(Dem_EDClassType, AUTOMATIC, DEM_CONST) EDClass);

/** \brief Function to get the size of internal values mapped to an extended
 ** data segment
 **
 ** \param[in] EDSegment
 **
 ** \return Size of mapped internal values. This along with the size returned
 **         by Dem_SizeOfEDSegment() gives the size required for storing the
 **         assembled extended data segment (record).
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint8, DEM_CODE) Dem_SizeOfMapIntValSegment(
  CONSTP2CONST(Dem_EDSegmentType, AUTOMATIC, DEM_CONST) EDSegment);

/** \brief Function to assemble the extended data record to translate and
 ** transfer internal data-structures into correct output-buffer format/layout
 **
 ** \param[in] EDSegment
 ** \param[in] EDStartByte
 ** \param[in] DestBuffer
 ** \param[in] EvMemEntry
 **
 ** \return Size of the extended data segment without considering the
 **         size of mapped internal values
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint8, DEM_CODE) Dem_AssembleExtendedDataSeg(
  CONSTP2CONST(Dem_EDSegmentType, AUTOMATIC, DEM_CONST) EDSegment,
  Dem_EDStartByteType                                   EDStartByte,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)                DestBuffer,
  Dem_EventMemoryEntryPtrConstType                      EvMemEntry);

/** \brief Function to get the index of an extended data segment by the given
 ** extended data number
 **
 ** \param[in] EDClass
 ** \param[in] Number  ED record number
 **
 ** \return Index of the extended data segment
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Dem_EDSegIdxType, DEM_CODE) Dem_FindEDNumIndex(
  CONSTP2CONST(Dem_EDClassType, AUTOMATIC, DEM_CONST) EDClass,
  const uint8                                         Number);
#endif /* DEM_NUM_EDSEGS > 0U */

#if (DEM_USE_INT_VAL_AREA == STD_ON)
/** \brief Function to get the size of internal values in an event
 **
 ** \param[in] EventId
 **
 ** \return Size of internal values (mapped or unmapped). This can be used
 **         by Dem_FFEntryData(), Dem_EDEntryData() and Dem_SizeOfEntryData()
 **         as they are uneffected with whether the internal value is
 **         mapped or not.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint8, DEM_CODE) Dem_SizeOfIntValArea(
  const Dem_EventIdType EventId);
#endif

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
/** \brief Function to check if a changed entry has to be stored immediately
 **
 ** This function checks if immediate storage is required, transfers the event
 ** memory entry into gate-entry and updates the NvM gate status.
 ** If the gate cannot be prepared, it marks the event memory entry as
 ** to be written persistently during shutdown.
 **
 ** \param[in] OriginalEventId  if event memory entry is displaced then this
 **                    corresponds to the event Id of the entry which was
 **                    displaced by a new event, otherwise it corresponds to
 **                    the event Id of the updated event.
 **                    During displacement the current event Id can be
 **                    derived from the event memory entry.
 ** \param[in] EvMemEntryPtr  pointer to the selected entry
 ** \param[in] EvMemEntryIdx  index of the selected entry
 ** \param[in] ForceWrite  specifies if the entry needs to be stored
 **                    immediately independent from configuration
 ** \param[in,out] NvMGateStatus
 **/
extern FUNC(void, DEM_CODE) Dem_CheckForImmediateEntryStorage(
  Dem_EventIdType                   OriginalEventId,
  const Dem_EventMemoryEntryPtrType EvMemEntryPtr,
  Dem_SizeEvMemEntryType            EvMemEntryIdx,
  boolean                           ForceWrite,
  Dem_NvMGatePrepStatusPtrType      NvMGateStatus);

/** \brief Function to indicate that a gate entry shall be prepared
 **
 ** Depending on the NvM status, this function tries to execute a protected
 ** change of the NvM and the gate status, thus 'locking' the gate entry.
 **
 ** \param[in] OriginIdx  Event memory whose gate shall be locked
 **/
extern FUNC(Dem_NvMGatePrepStatusType, DEM_CODE)
  Dem_BeginPrepareGateEntry(uint8 OriginIdx);

/** \brief Function to indicate that the gate entry preparation has ended
 **
 ** This function executes a protected change of the NvM status. Depending on
 ** a successful gate preparation, the NvM status is changed to WAITING or
 ** IDLE.
 **
 ** \param[in] OriginIdx  Event memory whose gate is locked
 ** \param[in] NvMGateStatus
 **/
extern FUNC(void, DEM_CODE) Dem_EndPrepareGateEntry(
  uint8 OriginIdx,
  Dem_NvMGatePrepStatusType NvMGateStatus);

/** \brief Function to store given entry to the NvRAM by using the gate-entry
 **
 ** This function has to be called while the entry related to the given index
 ** is protected against modification.
 **
 ** \param[in] originIdx
 ** \param[in] entryIdx
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DEM_CODE) Dem_StoreImmediately(
  const uint8                  originIdx,
  const Dem_SizeEvMemEntryType entryIdx);

#if (DEM_CLEAR_DTC_BEHAVIOR != DEM_CLRRESP_VOLATILE)
/** \brief Function to trigger the NvM write of the event status bytes
 **
 ** This function checks if the status block can be written persistently.
 ** It calls NvM_WriteBlock() and if it fails because of an error, it
 ** reschedules the block to be written on shutdown (no retry by Dem module).
 **
 ** \return Std_ReturnType result of NvM_WriteBlock for status block
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(Std_ReturnType, DEM_CODE) Dem_TriggerNvmWriteEventStatus(void);
#endif

/** \brief Function to check a NvM gate status and trigger a new NvM write
 **
 ** This function checks all gate entries if one has been prepared to be
 ** written persistently. It calls NvM_WriteBlock() and if it fails because
 ** of an error, it reschedules the block to be written on shutdown (no retry
 ** by Dem module).
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **/
extern FUNC(void, DEM_CODE) Dem_TriggerNvmWriteGateEntry(void);

/** \brief Common NvM block callback handler
 **
 ** This function is called by each of the configured NvM block callback
 ** functions Dem_NvMGateEntry<..>BlockCallback and commonly handles all
 ** callbacks of asynchronous NvM requests.
 **
 ** \param[in] ServiceId  NvM service identifier
 ** \param[in] OriginIdx  Origin index of event memory related to callback
 **/
extern FUNC(void, DEM_CODE) Dem_NvMGateEntryBlockCallback(
  const uint8 ServiceId,
  const uint8 OriginIdx);
#endif /* DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON */

#if (DEM_USE_AGING == STD_ON)
/** \brief Clear aged event from event memory
 **
 ** \param[in] EventId
 ** \param[in] EvMemEntry
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ClearAgedEventEntry(
  const Dem_EventIdType             EventId,
  const Dem_EventMemoryEntryPtrType EvMemEntry);
#endif

/*------------------[Getter-Functions for the Event Descriptions]-----------*/

/** \brief Get DTC-value from configured callout function if ::DEM_USE_DYNAMIC_DTCS
 **  is enabled, else from ::Dem_EventDesc by using index
 **
 ** Note: returns 0, if no DTC is assigned to the event
 */
extern FUNC(uint32, DEM_CODE) Dem_GbiDTC(const Dem_EventIdType EventId);

/** \brief Get DTC kind from ::Dem_EventDesc by using index
 **
 ** Note: returns ::DEM_DTC_KIND_ALL_DTCS, always since no OBD support
 */
extern FUNC(Dem_DTCKindType, DEM_CODE) Dem_GbiDTCKind(
  const Dem_EventIdType EventId);

/** \brief Get DTC-origin from ::Dem_EventDesc by using index */
extern FUNC(Dem_DTCOriginType, DEM_CODE) Dem_GbiDTCOrigin(
  const Dem_EventIdType EventId);

/** \brief Get DTC-origin index from ::Dem_EventDesc by using index */
extern FUNC(uint8, DEM_CODE) Dem_GbiDTCOriginIdx(
  const Dem_EventIdType EventId);

/** \brief Get DTC-group-index from ::Dem_EventDesc by using index */
extern FUNC(uint8, DEM_CODE) Dem_GbiDTCGroupIdx(
  const Dem_EventIdType EventId);

/** \brief Get enable-immediate storage-flag from ::Dem_EventDesc by using
 ** index */
extern FUNC(boolean, DEM_CODE) Dem_GbiImmediateStorage(
  const Dem_EventIdType EventId);

/** \brief Get DTC-severity from ::Dem_EventDesc by using index
 **
 ** Note: returns ::DEM_SEVERITY_NO_SEVERITY, if no DTC is assigned to the event
 */
extern FUNC(Dem_DTCSeverityType, DEM_CODE) Dem_GbiDTCSeverity(
  const Dem_EventIdType EventId);

/** \brief Get DTC functional unit from ::Dem_EventDesc by using index
 **
 ** Note: returns 0, if no DTC is assigned to the event
 */
extern FUNC(uint8, DEM_CODE) Dem_GbiDTCFunctionalUnit(
  const Dem_EventIdType EventId);

/** \brief Get FF-class-index from ::Dem_EventDesc by using index */
extern FUNC(Dem_FFClassIdxType, DEM_CODE) Dem_GbiFFClassIdx(
  const Dem_EventIdType EventId);

#if (DEM_NUM_FFSEGS > 0U)
/** \brief Get maximal-FF-count from ::Dem_EventDesc by using index */
extern FUNC(Dem_FFIdxType, DEM_CODE) Dem_GbiMaxNumFFRecs(
  const Dem_EventIdType EventId);
#endif /* (DEM_NUM_FFSEGS > 0U) */
#if (DEM_FREEZE_FRAME_REC_NUMERATION_TYPE == DEM_FF_RECNUM_CONFIGURED)
/** \brief Get FF record numeration class index from ::Dem_EventDesc by using
 ** index */
extern FUNC(Dem_FFIdxType, DEM_CODE) Dem_GbiFFRecNumClassIdx(
  const Dem_EventIdType EventId);
#endif /* (DEM_FREEZE_FRAME_REC_NUMERATION_TYPE == DEM_FF_RECNUM_CONFIGURED) */

/** \brief Get ED-class-index from ::Dem_EventDesc by using index */
extern FUNC(Dem_EDClassIdxType, DEM_CODE) Dem_GbiEDClassIdx(
  const Dem_EventIdType EventId);

/** \brief Get operation-cycle-index from ::Dem_EventDesc by using index */
extern FUNC(Dem_OperationCycleIdType, DEM_CODE) Dem_GbiOpCycleIdx(
  const Dem_EventIdType EventId);

#if (DEM_USE_AGING == STD_ON)
/** \brief Get aging-cycles from ::Dem_EventDesc by using index */
extern FUNC(Dem_AgingCyclesType, DEM_CODE) Dem_GbiNumAgingCycles(
  const Dem_EventIdType EventId);
#endif

#if (DEM_NUM_AGINGCYCLES > 0U)
/** \brief Get aging-cycle-index from ::Dem_EventDesc by using index */
extern FUNC(Dem_OperationCycleIdType, DEM_CODE) Dem_GbiAgingCycleIdx(
  const Dem_EventIdType EventId);
#endif

#if (DEM_NUM_ENCOND_LINKS > 0U)
/** \brief Get enable-condition-Id start index from ::Dem_EventDesc by using index */
extern FUNC(Dem_EnCondLnkIdxType, DEM_CODE) Dem_GbiEnCondLnkIdx(
  const Dem_EventIdType EventId);

/** \brief Get number of enable-condition-Id from ::Dem_EventDesc by using index */
extern FUNC(Dem_EnableConditionIdType, DEM_CODE) Dem_GbiNumEnCond(
  const Dem_EventIdType EventId);
#endif

/** \brief Get indicator-used-flag from ::Dem_EventDesc by using index */
extern FUNC(boolean, DEM_CODE) Dem_GbiIndicatorUsed(
  const Dem_EventIdType EventId);

#if (DEM_USE_EVENT_DISPLACEMENT == STD_ON)
/** \brief Get priority from ::Dem_EventDesc by using index */
extern FUNC(Dem_PriorityType, DEM_CODE) Dem_GbiPriority(
  const Dem_EventIdType EventId);
#endif

/** \brief Get enable-prestorage-flag from ::Dem_EventDesc by using index */
extern FUNC(boolean, DEM_CODE) Dem_GbiEnablePrestorage(
  const Dem_EventIdType EventId);

/** \brief Get debounce algorithm from ::Dem_EventDesc by using index */
extern FUNC(Dem_DebounceType, DEM_CODE) Dem_GbiDebounceAlgo(
  const Dem_EventIdType EventId);

/** \brief Get debounce index from ::Dem_EventDesc by using index */
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GbiDebounceIdx(
  const Dem_EventIdType EventId);

/** \brief Get Event-kind from ::Dem_EventDesc by using index */
extern FUNC(Dem_EventKindType, DEM_CODE) Dem_GbiEventKind(
  const Dem_EventIdType EventId);

/** \brief Get Event failure class index from ::Dem_EventDesc by using index */
extern FUNC(uint8, DEM_CODE) Dem_GbiEventFailureClassIdx(
  const Dem_EventIdType EventId);

/*------------------[Interface Dem <--> SW-Components / BSW modules]--------*/

#if (DEM_USE_CB_INIT_MONITOR == STD_ON)
/** \brief Wrapper-Function to call init-monitor-for-event functions
 **
 ** Dem_CbInitMonitorForEvent shall be enabled only if
 ** either RTE callback or C callback is configured for Init Monitor.
 **
 ** This must be done by a wrapper, because it depends on configuration.
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 ** \param[in] InitMonitorKind
 **
 ** \pre This function must only be called with consistent input-data of
 ** Dem_CbProperty[] and Dem_CbLookupTableInitMonitor[].
 */
extern FUNC(void, DEM_CODE) Dem_CbInitMonitorForEvent(
  const Dem_EventIdType           EventId,
  const Dem_InitMonitorReasonType InitMonitorReason);
#endif

#if ((DEM_USE_CB_TRIG_ON_EVST == STD_ON) || (DEM_USE_CB_TRIG_ON_DTCST == STD_ON))
/** \brief Wrapper-Function to call trigger-on-event-status functions
 **
 ** Dem_CbTriggerOnEventStatus shall be enabled only if
 ** either RTE callback or C callback is configured for Trigger on Event or DTC.
 **
 ** This must be done by a wrapper, because it depends on configuration.
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 ** \param[in] OldDTCStatusMask
 ** \param[in] NewDTCStatusMask
 */
extern FUNC(void, DEM_CODE) Dem_CbTriggerOnEventStatus(
  const Dem_EventIdType       EventId,
  const Dem_DTCStatusMaskType OldDTCStatusMask,
  const Dem_DTCStatusMaskType NewDTCStatusMask);
#endif

#if (DEM_USE_CB_TRIG_ON_EVDAT == STD_ON)
/** \brief Wrapper-Function to call event-data-changed functions
 **
 ** Dem_CbTriggerOnEventData shall be enabled only if
 ** either RTE callback or C callback is configured for
 ** TriggerOnEventDataChanged, or basic RTE support is enabled.
 **
 ** This must be done by a wrapper, because it depends on configuration.
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 */
extern FUNC(void, DEM_CODE) Dem_CbTriggerOnEventData(
  const Dem_EventIdType EventId);
#endif

#if (DEM_USE_CB_CLEAR_EVENT_ALLOWED == STD_ON)
/** \brief Wrapper-Function to call ClearEventAllowed functions
 **
 ** Dem_CbClearEventAllowed shall be enabled only if
 ** either RTE callback or C callback is configured for Clear event allowed.
 **
 ** This must be done by a wrapper, because it depends on configuration.
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 ** \param[out] Allowed
 **
 ** \return E_OK if Operation was successful, E_NOT_OK otherwise
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_CbClearEventAllowed(
  const Dem_EventIdType                    EventId,
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) Allowed);
#endif

#if (DEM_USE_CB_GET_FDC == STD_ON)
/** \brief Wrapper-Function to call get-fault-detection-counter functions
 **
 ** Dem_CbGetFaultDetectionCounter shall be enabled only if
 ** either RTE callback or C callback is configured for FDC.
 **
 ** This must be done by a wrapper, because it depends on configuration.
 **
 ** \param[in] EventId  0 < EventId < DEM_NUMBER_OF_EVENTS
 ** \param[out] FDC
 **
 ** \return E_OK if FDC could be acquired, E_NOT_OK otherwise
 **
 ** \pre This function must only be called with consistent input-data of
 ** Dem_CbProperty[] and Dem_CbLookupTableGetFDC[].
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_CbGetFaultDetectionCounter(
  Dem_EventIdType                                                EventId,
  CONSTP2VAR(Dem_FaultDetectionCounterType, AUTOMATIC, DEM_APPL_DATA) FDC);
#endif

/*------------------[functions for debouncing]------------------------------*/

#if (DEM_NUM_DEBOUNCE_TIME > 0U)
/** \brief "Tick" the timers used for time based debouncing
 **
 ** Dem_DebounceTimeTimerTick shall be enabled only if
 ** time based debounced events is configured.
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_DebounceTimeTimerTick(void);
#endif /* (DEM_NUM_DEBOUNCE_TIME > 0U) */

#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
/** \brief "Tick" the timers used for frequency based debouncing
 **
 ** Dem_DebounceFrequencyTimerTick shall be enabled only if
 ** frequency based debounced events is configured..
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_DebounceFrequencyTimerTick(void);
#endif /* (DEM_NUM_DEBOUNCE_FREQUENCY > 0U) */

#define DEM_STOP_SEC_CODE
#include <MemMap.h>

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

#define DEM_START_SEC_CONST_UNSPECIFIED
#include <MemMap.h>

/** \brief Array holding the pointers to the 3 event memories */
extern CONSTP2VAR(Dem_EventMemoryEntryType, DEM_CONST, DEM_VAR_NOINIT)
  Dem_EventMem[DEM_MAXNUM_ORIGINS];

#if (DEM_NUM_ENCOND_LINKS > 0U)
/** \brief Enable Condition Id / Event Id mapping table
 **
 ** EventId -> EnCondLink[StartIdx..Num] -> EnCondStatus
 **
 ** Number of elements: ::DEM_NUM_ENCOND_LINKS / no ROM-variable
 */
extern CONST(Dem_EnableConditionIdType, DEM_CONST)
  Dem_EnCondLink[DEM_NUM_ENCOND_LINKS];
#endif

/** \brief Configuration description table for warning indicators
 **
 ** Number of elements: ::DEM_NUMBER_OF_INDICATORS / no ROM-variable
 */
#if (DEM_NUMBER_OF_INDICATORS > 0U)
extern CONST(Dem_IndicatorDescType, DEM_CONST)
  Dem_IndicatorDesc[DEM_NUMBER_OF_INDICATORS];
#endif

/** \brief Configuration link table for warning indicator-link
 **
 ** Number of elements: ::DEM_NUM_INDICATOR_LINKS / no ROM-variable
 */
#if (DEM_NUM_INDICATOR_LINKS > 0U)
extern CONST(Dem_IndicatorLinkType, DEM_CONST)
  Dem_IndicatorLink[DEM_NUM_INDICATOR_LINKS];
#endif

/** \brief Configuration table for healing cycle-counter information
 **
 ** Number of elements: ::DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS / no ROM-variable
 */
#if (DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS > 0U)
extern CONST(Dem_CounterInfoType, DEM_CONST)
  Dem_HealingCycleCounterInfo[DEM_NUM_HEALINGCYC_COUNTER_INFO_ELEMENTS];
#endif

/** \brief Configuration table for failure cycle-counter information
 **
 ** Number of elements: ::DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS / no ROM-variable
 */
#if (DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS > 0U)
extern CONST(Dem_CounterInfoType, DEM_CONST)
  Dem_FailureCycleCounterInfo[DEM_NUM_FAILURECYC_COUNTER_INFO_ELEMENTS];
#endif

/** \brief List of all events which are configured for warning indicators
 **
 ** Number of elements: ::DEM_NUM_EVENT_INDICATOR_USED / no ROM-variable
 */
#if (DEM_NUM_EVENT_INDICATOR_USED > 0U)
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_EventIndicatorUsed[DEM_NUM_EVENT_INDICATOR_USED];
#endif

/** \brief List of BSW events which are configured for warning indicators
 **
 ** Number of elements: ::DEM_NUM_BSWEVENT_INDICATOR_USED / no ROM-variable
 */
#if (DEM_NUM_BSWEVENT_INDICATOR_USED > 0U)
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_BSWEventIndicatorUsed[DEM_NUM_BSWEVENT_INDICATOR_USED];
#endif

/** \brief Configuration description table for counter based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_COUNTER / no ROM-variable
 */
#if (DEM_NUM_DEBOUNCE_COUNTER > 0U)
extern CONST(Dem_DebounceCounterCfgType, DEM_CONST)
  Dem_DebounceCounterCfg[DEM_NUM_DEBOUNCE_COUNTER];
#endif

/** \brief Configuration description table for time based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_TIME / no ROM-variable
 */
#if (DEM_NUM_DEBOUNCE_TIME > 0U)
extern CONST(Dem_DebounceTimeCfgType, DEM_CONST)
  Dem_DebounceTimeCfg[DEM_NUM_DEBOUNCE_TIME];
#endif

/** \brief Configuration description table for frequency based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_FREQUENCY / no ROM-variable
 */
#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
extern CONST(Dem_DebounceFrequencyCfgType, DEM_CONST)
  Dem_DebounceFrequencyCfg[DEM_NUM_DEBOUNCE_FREQUENCY];
#endif

/** \brief Configuration description for fault confirmation */
#if (DEM_NUM_FAILURECYCLES > 0U)
extern CONST(Dem_EventFailureCycleCfgType, DEM_CONST)
  Dem_EventFailureCycleCfg[DEM_NUM_FAILURECYCLES];
#endif

/** \brief Event callback property table */
extern CONST(Dem_CbPropertyType, DEM_CONST)
  Dem_CbProperty[DEM_NUMBER_OF_EVENTS];

#if (DEM_NUM_FFSEGS > 0U)
/** \brief Freeze frame segments (DIDs)
 **
 ** Number of elements: ::DEM_NUM_FFSEGS
 */
extern CONST(Dem_FFSegmentType, DEM_CONST) Dem_FFSegment[DEM_NUM_FFSEGS];
#endif

#if (DEM_NUM_EDSEGS > 0U)
/** \brief Extended data segments (Records)
 **
 ** Number of elements: ::DEM_NUM_EDSEGS
 */
extern CONST(Dem_EDSegmentType, DEM_CONST) Dem_EDSegment[DEM_NUM_EDSEGS];
#endif

#if (DEM_NUM_EXT_CS_DATAELEMENTS > 0U)
/** \brief Data Elements
 **
 ** Number of elements: ::DEM_NUM_EXT_CS_DATAELEMENTS
 */
extern CONST(Dem_DataElementType, DEM_CONST)
  Dem_DataElement[DEM_NUM_EXT_CS_DATAELEMENTS];
#endif

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
/** \brief Gate-entry data to be read from/ written to NvM block */
extern Dem_GateEntryDataPtrVoid Dem_GateEntryData[DEM_MAXNUM_ORIGINS];

/** \brief Struct containing gate-entry base and data to be read from /
 ** written to NvM block */
extern Dem_NvGateEntryDataPtrVoid Dem_NvGateEntryData[DEM_MAXNUM_ORIGINS];

/** \brief Array of NvM block Id's on event memories */
extern CONST(NvM_BlockIdType, DEM_CONST)
  Dem_NvDataBlockId[DEM_MAXNUM_ORIGINS];
#endif /* DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON */

/*-----------------[Generic-Functiontable]----------------------------------*/

#if (DEM_CB_TABLE_INIT_MONITOR_SIZE != 0U)
/** \brief Generic callback function pointer table for InitMonitor */
extern CONST(Dem_CbFuncPtrInitMonitorType, DEM_CONST)
  Dem_CbFuncPtrInitMonitor[DEM_CB_TABLE_INIT_MONITOR_SIZE];
#endif

#if (DEM_CB_TABLE_TRIG_ON_DTCST_SIZE != 0U)
/** \brief Generic callback function pointer table for TriggerOnDTCStatus */
extern CONST(Dem_CbFuncPtrTrigOnDTCStType, DEM_CONST)
  Dem_CbFuncPtrTrigOnDTCSt[DEM_CB_TABLE_TRIG_ON_DTCST_SIZE];
#endif

#if (DEM_CB_TABLE_GET_FDC_SIZE != 0U)
/** \brief Generic callback function pointer table for GetFaultDetectionCounter */
extern CONST(Dem_CbFuncPtrGetFDCType, DEM_CONST)
  Dem_CbFuncPtrGetFDC[DEM_CB_TABLE_GET_FDC_SIZE];
#endif

/*-----------------[C-Functiontable]----------------------------------------*/

#if (DEM_C_CALLBACK_TABLE_TRIG_ON_EVST_SIZE != 0U)
/** \brief C-Callback function pointer table for TriggerOnEventStatus */
extern CONST(Dem_CbFuncPtrTrigOnEvStType, DEM_CONST)
  Dem_CbFuncPtrTrigOnEvSt[DEM_C_CALLBACK_TABLE_TRIG_ON_EVST_SIZE];
#endif

#if (DEM_C_CB_TABLE_TRIG_ON_EVDAT_SIZE != 0U)
/** \brief C-Callback function pointer table for TriggerOnEventDataChanged */
extern CONST(Dem_CbFuncPtrTrigOnEvDatType, DEM_CONST)
  Dem_CbFuncPtrTrigOnEvDat[DEM_C_CB_TABLE_TRIG_ON_EVDAT_SIZE];
#endif

#if (DEM_C_CB_TABLE_CLEAR_EVENT_ALLOWED_SIZE != 0U)
/** \brief C-Callback function pointer table for ClearEventAllowed */
extern CONST(Dem_CbFuncPtrClearEventAllowedType, DEM_CONST)
  Dem_CbFuncPtrClearEventAllowed[DEM_C_CB_TABLE_CLEAR_EVENT_ALLOWED_SIZE];
#endif

/*-----------------[RTE-Functiontable]--------------------------------------*/

#if (DEM_RTE_CALLBACK_TABLE_TRIG_ON_EVST_SIZE != 0U)
/** \brief RTE-Callback function pointer table for TriggerOnEventStatus */
extern CONST(Dem_RteFuncPtrTrigOnEvStType, DEM_CONST)
  Dem_RteFuncPtrTrigOnEvSt[DEM_RTE_CALLBACK_TABLE_TRIG_ON_EVST_SIZE];
#endif

#if (DEM_RTE_CB_TABLE_TRIG_ON_EVDAT_SIZE != 0U)
/** \brief RTE-Callback function pointer table for TriggerOnEventDataChanged */
extern CONST(Dem_RteFuncPtrTrigOnEvDatType, DEM_CONST)
  Dem_RteFuncPtrTrigOnEvDat[DEM_RTE_CB_TABLE_TRIG_ON_EVDAT_SIZE];
#endif

#if (DEM_RTE_CB_TABLE_CLEAR_EVENT_ALLOWED_SIZE != 0U)
/** \brief RTE-Callback function pointer table for ClearEventAllowed */
extern CONST(Dem_CbFuncPtrClearEventAllowedType, DEM_CONST)
  Dem_RteFuncPtrClearEventAllowed[DEM_RTE_CB_TABLE_CLEAR_EVENT_ALLOWED_SIZE];
#endif

/*-----------------[Generic-Lookuptable]------------------------------------*/

#if (DEM_LOOKUP_TABLE_INIT_MONITOR_SIZE != 0U)
/** \brief Generic callback function lookup table for InitMonitor */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_CbLookupTableInitMonitor[DEM_LOOKUP_TABLE_INIT_MONITOR_SIZE];
#endif

#if (DEM_LOOKUP_TABLE_GET_FDC_SIZE != 0U)
/** \brief Generic callback function lookup table for GetFaultDetectionCounter */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_CbLookupTableGetFDC[DEM_LOOKUP_TABLE_GET_FDC_SIZE];
#endif

/*-----------------[C-Lookuptable]------------------------------------------*/

#if (DEM_C_LOOKUP_TABLE_TRIG_ON_EVST_SIZE != 0U)
/** \brief C-Callback function lookup table for TriggerOnEventStatus */
extern CONST(Dem_CbLookupTableType, DEM_CONST)
  Dem_CbLookupTableTrigOnEvSt[DEM_C_LOOKUP_TABLE_TRIG_ON_EVST_SIZE];
#endif

#if (DEM_C_LOOKUP_TABLE_TRIG_ON_EVDAT_SIZE != 0U)
/** \brief C-Callback function lookup table for TriggerOnEventDataChanged */
extern CONST(Dem_CbLookupTableType, DEM_CONST)
  Dem_CbLookupTableTrigOnEvDat[DEM_C_LOOKUP_TABLE_TRIG_ON_EVDAT_SIZE];
#endif

#if (DEM_C_LOOKUP_TABLE_CLEAR_EVENT_ALLOWED_SIZE != 0U)
/** \brief C-Callback function lookup table for ClearEventAllowed */
extern CONST(Dem_CbLookupTableType, DEM_CONST)
  Dem_CbLookupTableClearEventAllowed[DEM_C_LOOKUP_TABLE_CLEAR_EVENT_ALLOWED_SIZE];
#endif

/*-----------------[RTE-Lookuptable]----------------------------------------*/

#if (DEM_RTE_LOOKUP_TABLE_TRIG_ON_EVST_SIZE != 0U)
/** \brief RTE-Callback function lookup table for TriggerOnEventStatus */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_RteLookupTableTrigOnEvSt[DEM_RTE_LOOKUP_TABLE_TRIG_ON_EVST_SIZE];
#endif

#if (DEM_RTE_LOOKUP_TABLE_TRIG_ON_EVDAT_SIZE != 0U)
/** \brief RTE-Callback function lookup table for TriggerOnEventDataChanged */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_RteLookupTableTrigOnEvDat[DEM_RTE_LOOKUP_TABLE_TRIG_ON_EVDAT_SIZE];
#endif

#if (DEM_RTE_LOOKUP_TABLE_CLEAR_EVENT_ALLOWED_SIZE != 0U)
/** \brief RTE-Callback function lookup table for ClearEventAllowed */
extern CONST(Dem_EventIdType, DEM_CONST)
  Dem_RteLookupTableClearEventAllowed[DEM_RTE_LOOKUP_TABLE_CLEAR_EVENT_ALLOWED_SIZE];
#endif

/*--------------------------------------------------------------------------*/

#if (DEM_NUM_FFCLS > 0U)
/** \brief Configuration table for freeze frame classes
 **
 ** Number of elements: ::DEM_NUM_FFCLS
 */
extern CONST(Dem_FFClassType, DEM_CONST) Dem_FFClass[DEM_NUM_FFCLS];
#endif

#if (DEM_FREEZE_FRAME_REC_NUMERATION_TYPE == DEM_FF_RECNUM_CONFIGURED)
/** \brief Configuration table for freeze frame record numeration classes
 **
 ** Number of elements: ::DEM_NUM_FFRECNUMCLS
 */
extern CONST(Dem_FFRecNumerationClassType, DEM_CONST)
  Dem_FFRecNumerationClass[DEM_NUM_FFRECNUMCLS];
#endif

#if (DEM_NUM_EDCLS > 0U)
/** \brief Configuration table for extended data classes
 **
 ** Number of elements: ::DEM_NUM_EDCLS
 */
extern CONST(Dem_EDClassType, DEM_CONST) Dem_EDClass[DEM_NUM_EDCLS];
#endif

/** \brief Configuration description table of DTC-group values */
extern CONST(Dem_DTCGroupType, DEM_CONST) Dem_DTCGroups[DEM_NUM_DTC_GROUPS];

/** \brief Configuration description table for events
 **
 ** Number of elements: ::DEM_NUMBER_OF_EVENTS
 **
 ** This array contains all specific event-related data, which are packed by
 ** using the 'bit packing scheme'.
 */
extern CONST(Dem_EventDescType, DEM_CONST)
  Dem_EventDesc[DEM_NUMBER_OF_EVENTS];

/** \brief Function pointer array holding debouncing functions */
extern CONST(Dem_DebounceFctPtrTableType, DEM_CONST)
  Dem_DebounceFctPtrTable[DEM_MAXNUM_DEBOUNCECLASSES];

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include <MemMap.h>

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

#define DEM_START_SEC_VAR_NO_INIT_UNSPECIFIED
#include <MemMap.h>

/** \brief Queue holding the errors appeared before Dem_Init(), or to be
 ** entered or updated in event memory after Dem_Init()
 */
extern VAR(Dem_ErrorQueueEntryType, DEM_VAR_NOINIT)
  Dem_ErrorQueue[DEM_BSW_ERROR_BUFFER_SIZE];

#if (DEM_OPCYC_NVSTORAGE == STD_OFF)
/** \brief Array to store the current operation cycle state for all configured
 ** operating cycles
 */
extern VAR(Dem_OperationCycleStateType, DEM_VAR_NOINIT)
  Dem_OpCycleState[DEM_NUM_OPCYCLES];
#endif

#if (DEM_NUM_DEBOUNCE_COUNTER > 0U)
/** \brief per-event status for counter based debouncing */
extern VAR(Dem_DebounceCounterStatusType, DEM_VAR_NOINIT)
  Dem_DebounceCounterStatus[DEM_NUM_DEBOUNCE_COUNTER];
#endif

#if (DEM_NUM_DEBOUNCE_TIME > 0U)
/** \brief per-event status for time based debouncing */
extern VAR(Dem_DebounceTimeStatusType, DEM_VAR_NOINIT)
  Dem_DebounceTimeStatus[DEM_NUM_DEBOUNCE_TIME];
#endif

#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
/** \brief per-event status for frequency based debouncing */
extern VAR(Dem_DebounceFrequencyStatusType, DEM_VAR_NOINIT)
  Dem_DebounceFrequencyStatus[DEM_NUM_DEBOUNCE_FREQUENCY];
#endif

#if (DEM_MAX_NUMBER_PRESTORED_FF > 0U)
/** \brief Flags to hold validity of the prestored freeze frames
 **
 ** Each bit represents one flag.
 */
extern VAR(uint8, DEM_VAR_NOINIT)
  Dem_PFFEntryValid[(DEM_MAX_NUMBER_PRESTORED_FF + 7U) / 8U];
#endif

#if (DEM_NUM_EVENT_INDICATOR_USED > 0U)
/** \brief Flags to hold the status of WIR On-Criteria */
extern VAR(uint8, DEM_VAR_NOINIT) Dem_WIROnCriteriaFulfilledFlags[
  (DEM_NUM_EVENT_INDICATOR_USED + 7U) / 8U];
#endif

#if (DEM_NUM_BSWEVENT_INDICATOR_USED > 0U)
/** \brief Flags to hold the status of BSW event WIR-status-bit */
extern VAR(uint8, DEM_VAR_NOINIT) Dem_BSWEventWIRStatusFlags[
  (DEM_NUM_BSWEVENT_INDICATOR_USED + 7U) / 8U];
#endif

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
/** \brief NvM write operation (and related gate entry) status per event
 ** memory */
extern VAR(Dem_NvMStatusType, DEM_VAR_NOINIT)
  Dem_NvMStatus[DEM_MAXNUM_ORIGINS];
#endif

#if (DEM_CLEAR_DTC_BEHAVIOR != DEM_CLRRESP_VOLATILE)
/** \brief Status of an asynchronous ClearDTC operation */
extern VAR(Dem_ClearDtcStatusType, DEM_VAR_NOINIT) Dem_ClearDtcAsyncStatus;
#endif

#if (DEM_EVENTFAILURECOUNTER_BUFFER_SIZE > 0U)
/** \brief Buffer to store the failure counter for events
 ** whose event memory entry is not yet created
 */
extern VAR(Dem_EventFailureCycleCounterBufferType, DEM_VAR_NOINIT)
  Dem_EventFailureCycleCounterBuffer[DEM_EVENTFAILURECOUNTER_BUFFER_SIZE];
#endif

#define DEM_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
#include <MemMap.h>

#define DEM_START_SEC_VAR_INIT_UNSPECIFIED
#include <MemMap.h>

/** \brief Status of DTC-filter
 **
 ** This variable is used from DTC-based filter functions.
 **
 ** It reflects the status of the DTC-filter set by Dem_SetDTCFilter().
 */
extern VAR(Dem_DTCFilterType, DEM_VAR) Dem_DTCFilter;

#if (DEM_NUM_ENABLECONDITIONS > 0U)
/** \brief Array to store the current enable condition state for all
 ** configured enable conditions
 **
 ** Number of elements: ::DEM_NUM_ENABLECONDITIONS / no RAM-variable
 */
extern VAR(boolean, DEM_VAR) Dem_EnCondStatus[DEM_NUM_ENABLECONDITIONS];
#endif

#define DEM_STOP_SEC_VAR_INIT_UNSPECIFIED
#include <MemMap.h>

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

#endif /* if !defined( DEM_INT_H ) */
/*==================[end of file]===========================================*/
