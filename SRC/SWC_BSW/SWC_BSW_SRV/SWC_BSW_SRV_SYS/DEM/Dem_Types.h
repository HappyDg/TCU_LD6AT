/**
 * \file
 *
 * \brief AUTOSAR Dem
 *
 * This file contains the implementation of the AUTOSAR
 * module Dem.
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2013 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
#if (!defined DEM_TYPES_H)
#define DEM_TYPES_H

/* This file provides the type definitions of the AUTOSAR module Dem.
 * Note: Some types are fixed and others depending on the configuration.
 */

/*==================[inclusions]============================================*/
/* !LINKSTO dsn.Dem.IncludeStr,1 */

#include <Std_Types.h>                            /* AUTOSAR standard types */
#include <TSAutosar.h>                        /* EB specific standard types */

#include <Dem_Cfg.h>                     /* Module public generated symbols */

#if (DEM_INCLUDE_RTE == STD_ON)
#include <Rte_Dem_Type.h>                         /* types generated by RTE */
#endif

/*==================[macros]================================================*/

/*------------------[Dem-specific Std_ReturnType values]--------------------*/

/** \brief There is no DTC configured in the requested format
 **
 ** Dem-specific ::Std_ReturnType value used by Dem_GetDTCOfEvent()
 */
#define DEM_E_NO_DTC_AVAILABLE 2U

/*==================[type definitions]======================================*/

/*------------------[>Dem data types<]--------------------------------------*/

/*------------------[Dem_ConfigType]----------------------------------------*/

/* Dem_ConfigType is defined within Dem_Cfg.h
   This is to support the post-build time multiple configuration data
   structure. Configuration structure of type pointer to Dem_ConfigType is
   passed to Dem_PreInit(). Although this is not used during pre-compile
   configuration, EcuM always calls Dem_PreInit() with the name of a
   referenced DemConfigSet container.
*/

#if (DEM_INCLUDE_RTE == STD_OFF)

/*------------------[Dem_EventIdType]---------------------------------------*/
#ifndef RTE_TYPE_Dem_EventIdType
#define RTE_TYPE_Dem_EventIdType
/** \brief Identification of an event by assigned EventId. The EventId is
 ** configured in the Dem.
 **
 ** Example:
 ** - 1 refers to monitor x,
 ** - 2 refers to monitor y, etc */
typedef uint16  Dem_EventIdType;
#endif

/*------------------[Dem_EventStatusType]-----------------------------------*/
#ifndef RTE_TYPE_Dem_EventStatusType
#define RTE_TYPE_Dem_EventStatusType
/** \brief This type contains all monitor test result values, which can be
 ** reported via Dem_ReportErrorStatus() and Dem_SetEventStatus().
 **
 ** bits 0x04..0xFF: reserved
 */
typedef uint8 Dem_EventStatusType;
#endif

#ifndef DEM_EVENT_STATUS_PASSED
/** \brief Monitor reports qualified test result passed */
#define DEM_EVENT_STATUS_PASSED      0x00U
#endif

#ifndef DEM_EVENT_STATUS_FAILED
/** \brief Monitor reports qualified test result failed */
#define DEM_EVENT_STATUS_FAILED      0x01U
#endif

#ifndef DEM_EVENT_STATUS_PREPASSED
/** \brief Monitor reports non-qualified test result pre-passed
 ** (debounced Dem-internally) */
#define DEM_EVENT_STATUS_PREPASSED   0x02U
#endif

#ifndef DEM_EVENT_STATUS_PREFAILED
/** \brief Monitor reports non-qualified test result pre-failed
 ** (debounced Dem-internally) */
#define DEM_EVENT_STATUS_PREFAILED   0x03U
#endif

/*------------------[Dem_EventStatusExtendedType]---------------------------*/
#ifndef RTE_TYPE_Dem_EventStatusExtendedType
#define RTE_TYPE_Dem_EventStatusExtendedType
/** \brief In this data-type each bit has an individual meaning. The bit is
 ** set to 1 when the condition holds. For example, if the 2nd bit (0x02)
 ** is set to 1, this means that the test failed this operation cycle.
 ** If the bit is set to 0, it has not yet failed this cycle.
 **
 ** Used in Dem_GetEventStatus() and Xxx_TriggerOnEventStatus().
 ** - Bit0: ::DEM_UDS_STATUS_TF
 ** - Bit1: ::DEM_UDS_STATUS_TFTOC
 ** - Bit2: ::DEM_UDS_STATUS_PDTC
 ** - Bit3: ::DEM_UDS_STATUS_CDTC
 ** - Bit4: ::DEM_UDS_STATUS_TNCSLC
 ** - Bit5: ::DEM_UDS_STATUS_TFSLC
 ** - Bit6: ::DEM_UDS_STATUS_TNCTOC
 ** - Bit7: ::DEM_UDS_STATUS_WIR */
typedef uint8 Dem_EventStatusExtendedType;
#endif

#ifndef DEM_UDS_STATUS_TF
/** \brief Test Failed status-bit */
#define DEM_UDS_STATUS_TF     0x01U
#endif

#ifndef DEM_UDS_STATUS_TFTOC
/** \brief Test Failed This Operation Cycle status-bit */
#define DEM_UDS_STATUS_TFTOC  0x02U
#endif

#ifndef DEM_UDS_STATUS_PDTC
/** \brief Pending DTC status-bit */
#define DEM_UDS_STATUS_PDTC   0x04U
#endif

#ifndef DEM_UDS_STATUS_CDTC
/** \brief Confirmed DTC status-bit */
#define DEM_UDS_STATUS_CDTC   0x08U
#endif

#ifndef DEM_UDS_STATUS_TNCSLC
/** \brief Test Not Completed Since Last Clear status-bit */
#define DEM_UDS_STATUS_TNCSLC 0x10U
#endif

#ifndef DEM_UDS_STATUS_TFSLC
/** \brief Test Failed Since Last Clear status-bit */
#define DEM_UDS_STATUS_TFSLC  0x20U
#endif

#ifndef DEM_UDS_STATUS_TNCTOC
/** \brief Test Not Completed This Operation Cycle status-bit */
#define DEM_UDS_STATUS_TNCTOC 0x40U
#endif

#ifndef DEM_UDS_STATUS_WIR
/** \brief Warning Indicator Requested status-bit */
#define DEM_UDS_STATUS_WIR    0x80U
#endif

/*------------------[Dem_OperationCycleIdType]------------------------------*/
#ifndef RTE_TYPE_Dem_OperationCycleIdType
#define RTE_TYPE_Dem_OperationCycleIdType
/** \brief Used to select the individual operation cycle in the API
 ** Dem_SetOperationCycleState()
 **
 ** value: The OperationCycleId, e.g. the ignition cycle is assigned to an ID
 **
 ** \note This type has been replaced with compatible base type (uint8) in
 ** AR3.1 Dem SWS, however it has been retained here for compatibility. */
typedef uint8 Dem_OperationCycleIdType;
#endif

/*------------------[Dem_OperationCycleStateType]---------------------------*/
#ifndef RTE_TYPE_Dem_OperationCycleStateType
#define RTE_TYPE_Dem_OperationCycleStateType
/** \brief This type contains operation cycle state values, which can be
 ** reported via Dem_SetOperationCycleState(). */
typedef uint8 Dem_OperationCycleStateType;
#endif

#ifndef DEM_CYCLE_STATE_START
/** \brief Start/restart the operation cycle */
#define DEM_CYCLE_STATE_START 0x00U
#endif

#ifndef DEM_CYCLE_STATE_END
/** \brief End of operation cycle */
#define DEM_CYCLE_STATE_END   0x01U
#endif

/*------------------[Dem_IndicatorIdType]-----------------------------------*/
#ifndef RTE_TYPE_Dem_IndicatorIdType
#define RTE_TYPE_Dem_IndicatorIdType
/** \brief Used to request a indicator type
 **
 ** value: indicator lamp ID
 **
 ** \note This type has been replaced with compatible base type (uint8) in
 ** AR3.1 Dem SWS, however it has been retained here for compatibility. */
typedef uint8 Dem_IndicatorIdType;
#endif

/*------------------[Dem_IndicatorStatusType]-------------------------------*/
#ifndef RTE_TYPE_Dem_IndicatorStatusType
#define RTE_TYPE_Dem_IndicatorStatusType
/** \brief Used to return the status of Dem_GetIndicatorStatus() */
typedef uint8 Dem_IndicatorStatusType;
#endif

#ifndef DEM_INDICATOR_OFF
/** \brief Indicator off mode */
#define DEM_INDICATOR_OFF        0x00U
#endif

#ifndef DEM_INDICATOR_CONTINUOUS
/** \brief Indicator continuously on mode */
#define DEM_INDICATOR_CONTINUOUS 0x01U
#endif

#ifndef DEM_INDICATOR_BLINKING
/** \brief Indicator blinking mode */
#define DEM_INDICATOR_BLINKING   0x02U
#endif

#ifndef DEM_INDICATOR_BLINK_CONT
/** \brief Indicator blinking or continuously on mode. The SW-C for indicator
 ** is responsible to decide if the indicator is blinking or continuously on. */
#define DEM_INDICATOR_BLINK_CONT 0x03U
#endif

#endif /* DEM_INCLUDE_RTE == STD_OFF */

/*------------------[Dem_DTCType]-------------------------------------------*/

/** \brief Diagnostic Trouble Code (DTC) assigned to each event stored in the
 ** event memory. The DTC is configured in the Dem.
 **
 ** The Dem always uses a 3 Byte definition with the following
 ** representations.
 **
 ** For UDS services, the DTC size is 3 bytes (HighByte, MiddleByte and
 ** LowByte). The Dem services shall report each of these DTC as a uint32 with
 ** byte 0 = LowByte, byte 1 = MiddleByte and byte 2 = HighByte. The byte 3 of the
 ** uint32 is free.
 **
 ** For OBD services only two bytes (HighByte, LowByte) are used. The
 ** Dem services shall report each of these DTC as a uint32 with
 ** byte 1 = LowByte and byte 2 = HighByte, byte 3 being free and byte 0 = 0x00.
 **
 ** \note This type has been replaced with compatible base type (uint32) in
 ** AR3.1 Dem SWS, however it has been retained here for compatibility. */
typedef uint32 Dem_DTCType;

/*------------------[Dem_DTCGroupType]--------------------------------------*/

/** \brief Used to define the group of DTCs
 **
 ** The user can add further groups. Unused bytes shall be filled with 00.
 */
typedef uint32 Dem_DTCGroupType;

#if (defined DEM_DTC_GROUP_ALL_DTCS)
#error DEM_DTC_GROUP_ALL_DTCS already defined
#endif
/** \brief All DTCs */
#define DEM_DTC_GROUP_ALL_DTCS          0xFFFFFFU

/* further DEM_DTC_GROUP_<GROUP_NAME> defines are generated in Dem_Cfg.h */

/*------------------[Dem_DTCKindType]---------------------------------------*/

/** \brief Used to define the DTC kind (type) */
typedef uint8 Dem_DTCKindType;

#if (defined DEM_DTC_KIND_ALL_DTCS)
#error DEM_DTC_KIND_ALL_DTCS already defined
#endif
/** \brief Select all DTCs */
#define DEM_DTC_KIND_ALL_DTCS          0x01U

#if (defined DEM_DTC_KIND_EMISSION_REL_DTCS)
#error DEM_DTC_KIND_EMISSION_REL_DTCS already defined
#endif
/** \brief Select OBD-relevant DTCs */
#define DEM_DTC_KIND_EMISSION_REL_DTCS 0x02U

#if (DEM_INCLUDE_RTE == STD_OFF)

/*------------------[Dem_DTCFormatType]---------------------------------------*/
#ifndef RTE_TYPE_Dem_DTCFormatType
#define RTE_TYPE_Dem_DTCFormatType
/** \brief Selects/specifies the format of the DTC value. */
typedef uint8 Dem_DTCFormatType;
#endif

#ifndef DEM_DTC_FORMAT_OBD
/** \brief selects the 2-byte OBD DTC format (refer to
 ** configuration parameter DemObdDTC) */
#define DEM_DTC_FORMAT_OBD             0x00U
#endif

#ifndef DEM_DTC_FORMAT_UDS
/** \brief selects the 3-byte UDS DTC format (refer to configuration parameter
 ** DemUdsDTC) */
#define DEM_DTC_FORMAT_UDS             0x01U
#endif

/*------------------[Dem_DTCOriginType]-------------------------------------*/
#ifndef RTE_TYPE_Dem_DTCOriginType
#define RTE_TYPE_Dem_DTCOriginType
/** \brief Enum used to define the location of the events/DTC
 **
 ** The ::Dem_DTCOriginType is used to differ between the different event
 ** memories. The definition and use of the different memory types is OEM
 ** specific.
 */
typedef uint8 Dem_DTCOriginType;
#endif

#ifndef DEM_DTC_ORIGIN_PRIMARY_MEMORY
/** \brief Event information located in the primary memory */
#define DEM_DTC_ORIGIN_PRIMARY_MEMORY    0x01U
#endif

#ifndef DEM_DTC_ORIGIN_MIRROR_MEMORY
/** \brief Event information located in the mirror memory */
#define DEM_DTC_ORIGIN_MIRROR_MEMORY     0x02U
#endif

#ifndef DEM_DTC_ORIGIN_PERMANENT_MEMORY
/** \brief Event information located in the permanent memory */
#define DEM_DTC_ORIGIN_PERMANENT_MEMORY  0x03U
#endif

#ifndef DEM_DTC_ORIGIN_SECONDARY_MEMORY
/** \brief Event information located in the secondary memory */
#define DEM_DTC_ORIGIN_SECONDARY_MEMORY  0x04U
#endif

#endif /* DEM_INCLUDE_RTE == STD_OFF */

/*----------------[Dem_DTCRequestType]--------------------------------------*/

/** \brief Request type for Dem_GetDTCByOccurrenceTime() */
typedef uint8 Dem_DTCRequestType;

#if (defined DEM_FIRST_FAILED_DTC)
#error DEM_FIRST_FAILED_DTC already defined
#endif
/** \brief First failed DTC requested */
#define DEM_FIRST_FAILED_DTC           0x01U

#if (defined DEM_MOST_RECENT_FAILED_DTC)
#error DEM_MOST_RECENT_FAILED_DTC already defined
#endif
/** \brief Most recent failed DTC requested */
#define DEM_MOST_RECENT_FAILED_DTC     0x02U

#if (defined DEM_FIRST_DET_CONFIRMED_DTC)
#error DEM_FIRST_DET_CONFIRMED_DTC already defined
#endif
/** \brief First detected confirmed DTC requested */
#define DEM_FIRST_DET_CONFIRMED_DTC    0x03U

#if (defined DEM_MOST_REC_DET_CONFIRMED_DTC)
#error DEM_MOST_REC_DET_CONFIRMED_DTC already defined
#endif
/** \brief Most recently detected confirmed DTC requested */
#define DEM_MOST_REC_DET_CONFIRMED_DTC 0x04U

/*------------------[Dem_DTCTranslationFormatType]--------------------------*/

/** \brief DTC translation format as defined in ISO14229-1 Service 0x19
 ** returned by Dem_GetTranslationType().
 **
 ** \note This type has been replaced with compatible base type (uint8) in
 ** AR3.1 Dem SWS, however it has been retained here for compatibility.
 */
typedef uint8 Dem_DTCTranslationFormatType;

#if (defined DEM_DTC_TRANSLATION_ISO15031_6)
#error DEM_DTC_TRANSLATION_ISO15031_6 already defined
#endif
/** \brief DTCs of ISO15031-6 */
#define DEM_DTC_TRANSLATION_ISO15031_6     0x00U

#if (defined DEM_DTC_TRANSLATION_ISO14229_1)
#error DEM_DTC_TRANSLATION_ISO14229_1 already defined
#endif
/** \brief DTCs of ISO14229-1 */
#define DEM_DTC_TRANSLATION_ISO14229_1     0x01U

#if (defined DEM_DTC_TRANSLATION_SAEJ1939_73)
#error DEM_DTC_TRANSLATION_SAEJ1939_73 already defined
#endif
/** \brief DTCs of SAEJ1939-73 */
#define DEM_DTC_TRANSLATION_SAEJ1939_73    0x02U

#if (defined DEM_DTC_TRANSLATION_ISO11992_4)
#error DEM_DTC_TRANSLATION_ISO11992_4 already defined
#endif
/** \brief DTCs of ISO11992_4 */
#define DEM_DTC_TRANSLATION_ISO11992_4     0x03U

/*----------------[Dem_DTCSeverityType]-------------------------------------*/

/** \brief Defines the type of a DTCSeverityMask according to ISO14229-1. */
typedef uint8 Dem_DTCSeverityType;

#if (defined DEM_SEVERITY_NO_SEVERITY)
#error DEM_SEVERITY_NO_SEVERITY already defined
#endif
/** \brief No severity information available */
#define DEM_SEVERITY_NO_SEVERITY        0x00U

#if (defined DEM_SEVERITY_MAINTENANCE_ONLY)
#error DEM_SEVERITY_MAINTENANCE_ONLY already defined
#endif
/** \brief Maintenance required */
#define DEM_SEVERITY_MAINTENANCE_ONLY   0x20U

#if (defined DEM_SEVERITY_CHECK_AT_NEXT_HALT)
#error DEM_SEVERITY_CHECK_AT_NEXT_HALT already defined
#endif
/** \brief Check at next halt */
#define DEM_SEVERITY_CHECK_AT_NEXT_HALT 0x40U

#if (defined DEM_SEVERITY_CHECK_IMMEDIATELY)
#error DEM_SEVERITY_CHECK_IMMEDIATELY already defined
#endif
/** \brief Check immediately */
#define DEM_SEVERITY_CHECK_IMMEDIATELY  0x80U

/*------------------[Dem_FaultDetectionCounterType]-------------------------*/

/** \brief Used to report Fault Detection Counter via API
 ** Dem_GetFaultDetectionCounter()
 **
 ** value: -128dec...127dec: PASSED ... FAILED according to ISO 14229-1
 **
 ** \note This type has been replaced with compatible base type (sint8) in
 ** AR3.1 Dem SWS, however it has been retained here for compatibility. */
typedef sint8 Dem_FaultDetectionCounterType;

/*----------------[Dem_FilterForFDCType]------------------------------------*/

/** \brief Used to specify the usage of Fault Detection Counter information */
typedef uint8 Dem_FilterForFDCType;

#if (defined DEM_FILTER_FOR_FDC_YES)
#error DEM_FILTER_FOR_FDC_YES already defined
#endif
/** \brief Fault Detection Counter information used */
#define DEM_FILTER_FOR_FDC_YES  0x00U

#if (defined DEM_FILTER_FOR_FDC_NO)
#error DEM_FILTER_FOR_FDC_NO already defined
#endif
/** \brief Fault Detection Counter information not used */
#define DEM_FILTER_FOR_FDC_NO   0x01U

/*----------------[Dem_FilterWithSeverityType]------------------------------*/

/** \brief Used to specify the usage of severity information */
typedef uint8 Dem_FilterWithSeverityType;

#if (defined DEM_FILTER_WITH_SEVERITY_YES)
#error DEM_FILTER_WITH_SEVERITY_YES already defined
#endif
/** \brief Severity information used */
#define DEM_FILTER_WITH_SEVERITY_YES  0x00U

#if (defined DEM_FILTER_WITH_SEVERITY_NO)
#error DEM_FILTER_WITH_SEVERITY_NO already defined
#endif
/** \brief Severity information not used */
#define DEM_FILTER_WITH_SEVERITY_NO   0x01U

#if (DEM_INCLUDE_RTE == STD_OFF)

/*------------------[Dem_DTCStatusMaskType]---------------------------------*/
#ifndef RTE_TYPE_Dem_DTCStatusMaskType
#define RTE_TYPE_Dem_DTCStatusMaskType
/** \brief Used to set the current status
 **
 ** value: - 0x00 ... 0xFF: Match DTCStatusMask as defined in ISO14229-1
 **
 ** \note This type has been replaced with compatible base type (uint8) in
 ** AR3.1 Dem SWS, however it has been retained here for compatibility. */
typedef uint8 Dem_DTCStatusMaskType;
#endif

/*------------------[Dem_RatioIdType]---------------------------------------*/
#ifndef RTE_TYPE_Dem_RatioIdType
#define RTE_TYPE_Dem_RatioIdType
/** \brief OBD specific ratio Id (related to a specific event, a FID, and an
 ** IUMPR group). This type depends on the Dem configuration.
 **
 ** Note: The size of this type is implementation specific and
 ** can be uint8 or uint16. */
typedef uint8 Dem_RatioIdType;
#endif

/*------------------[Dem_InitMonitorReasonType]-----------------------------*/
#ifndef RTE_TYPE_Dem_InitMonitorReasonType
#define RTE_TYPE_Dem_InitMonitorReasonType
/** \brief (Re-)Initialization reason returned by the
 ** callback <Module>_DemInitMonitorFor<EventName>() */
typedef uint8 Dem_InitMonitorReasonType;
#endif

#ifndef DEM_INIT_MONITOR_CLEAR
/** \brief Event was cleared and all internal values and states are reset */
#define DEM_INIT_MONITOR_CLEAR    0x01U
#endif

#ifndef DEM_INIT_MONITOR_RESTART
/** \brief Operation cycle of the event was (re-)started */
#define DEM_INIT_MONITOR_RESTART  0x02U
#endif

#endif /* DEM_INCLUDE_RTE == STD_OFF */

/*------------------[>Dem return types<]------------------------------------*/

/*------------------[Dem_ReturnSetFilterType]-------------------------------*/

/** \brief Used to return the status of (re-)setting a specific filter */
typedef uint8 Dem_ReturnSetFilterType;

#if (defined DEM_FILTER_ACCEPTED)
#error DEM_FILTER_ACCEPTED already defined
#endif
/** \brief Filter was accepted */
#define DEM_FILTER_ACCEPTED         0x00U

#if (defined DEM_WRONG_FILTER)
#error DEM_WRONG_FILTER already defined
#endif
/** \brief Wrong filter selected */
#define DEM_WRONG_FILTER            0x01U

/*------------------[Dem_ReturnGetStatusOfDTCType]--------------------------*/

/** \brief Used to return the status of Dem_GetStatusOfDTC() */
typedef uint8 Dem_ReturnGetStatusOfDTCType;

#if (defined DEM_STATUS_OK)
#error DEM_STATUS_OK already defined
#endif
/** \brief Status of DTC is OK */
#define DEM_STATUS_OK                0x00U

#if (defined DEM_STATUS_WRONG_DTC)
#error DEM_STATUS_WRONG_DTC already defined
#endif
/** \brief DTC value not existing (in this format) */
#define DEM_STATUS_WRONG_DTC         0x01U

#if (defined DEM_STATUS_WRONG_DTCORIGIN)
#error DEM_STATUS_WRONG_DTCORIGIN already defined
#endif
/** \brief Wrong DTC origin */
#define DEM_STATUS_WRONG_DTCORIGIN   0x02U

#if (defined DEM_STATUS_FAILED)
#error DEM_STATUS_FAILED already defined
#endif
/** \brief DTC failed */
#define DEM_STATUS_FAILED            0x03U

#if (defined DEM_STATUS_PENDING)
#error DEM_STATUS_PENDING already defined
#endif
/** \brief The requested value is calculated asynchronously and currently not
 * available. The caller can retry later. */
#define DEM_STATUS_PENDING           0x04U

/*------------------[Dem_ReturnGetNextFilteredDTCType]----------------------*/

/** \brief Used to return the status of the Dem_GetNextFiltered<...> interfaces */
typedef uint8 Dem_ReturnGetNextFilteredDTCType;

#if (defined DEM_FILTERED_OK)
#error DEM_FILTERED_OK already defined
#endif
/** \brief Returned next filtered DTC */
#define DEM_FILTERED_OK                0x00U

#if (defined DEM_FILTERED_NO_MATCHING_DTC)
#error DEM_FILTERED_NO_MATCHING_DTC already defined
#endif
/** \brief No further DTC (matching the filter criteria) found */
#define DEM_FILTERED_NO_MATCHING_DTC   0x01U

#if (defined DEM_FILTERED_PENDING)
#error DEM_FILTERED_PENDING already defined
#endif
/** \brief The requested value is calculated asynchronously and currently not
 ** available. The caller can retry later.
 ** Only used by asynchronous interfaces.
 */
#define DEM_FILTERED_PENDING           0x02U

/*-------------------[Dem_ReturnGetNumberOfFilteredDTCType]-----------------*/

/** \brief Used to return the status of Dem_GetNumberOfFilteredDTC() */
typedef uint8 Dem_ReturnGetNumberOfFilteredDTCType;

#if (defined DEM_NUMBER_OK)
#error DEM_NUMBER_OK already defined
#endif
/** \brief Getting number of filtered DTCs was successful. */
#define DEM_NUMBER_OK                0x00U

#if (defined DEM_NUMBER_FAILED)
#error DEM_NUMBER_FAILED already defined
#endif
/** \brief Getting number of filtered DTCs failed */
#define DEM_NUMBER_FAILED            0x01U

#if (defined DEM_NUMBER_PENDING)
#error DEM_NUMBER_PENDING already defined
#endif
/** \brief Getting number of filtered DTCs is pending */
#define DEM_NUMBER_PENDING           0x02U

/*------------------[Dem_ReturnClearDTCType]--------------------------------*/

/** \brief Used to return the status of Dem_ClearDTC() */
typedef uint8 Dem_ReturnClearDTCType;

#if (defined DEM_CLEAR_OK)
#error DEM_CLEAR_OK already defined
#endif
/** \brief DTC successfully cleared */
#define DEM_CLEAR_OK                0x00U

#if (defined DEM_CLEAR_WRONG_DTC)
#error DEM_CLEAR_WRONG_DTC already defined
#endif
/** \brief DTC value not existing (in this format) */
#define DEM_CLEAR_WRONG_DTC         0x01U

#if (defined DEM_CLEAR_WRONG_DTCORIGIN)
#error DEM_CLEAR_WRONG_DTCORIGIN already defined
#endif
/** \brief Wrong DTC origin */
#define DEM_CLEAR_WRONG_DTCORIGIN   0x02U

#if (defined DEM_CLEAR_FAILED)
#error DEM_CLEAR_FAILED already defined
#endif
/** \brief DTC not cleared */
#define DEM_CLEAR_FAILED            0x03U

#if (defined DEM_CLEAR_PENDING)
#error DEM_CLEAR_PENDING already defined
#endif
/** \brief Clearing of DTC is pending */
#define DEM_CLEAR_PENDING           0x04U

/*------------------[Dem_ReturnControlDTCSettingType]-----------------------*/

/** \brief Used to return the status of Dem_DisableDTCSetting() and
 * Dem_EnableDTCSetting() */
typedef uint8 Dem_ReturnControlDTCSettingType;

#if (defined DEM_CONTROL_DTC_SETTING_OK)
#error DEM_CONTROL_DTC_SETTING_OK already defined
#endif
/** \brief DTC setting control successful */
#define DEM_CONTROL_DTC_SETTING_OK     0x00U

#if (defined DEM_CONTROL_DTC_SETTING_N_OK)
#error DEM_CONTROL_DTC_SETTING_N_OK already defined
#endif
/** \brief DTC setting control not successful */
#define DEM_CONTROL_DTC_SETTING_N_OK   0x01U

#if (defined DEM_CONTROL_DTC_WRONG_DTCGROUP)
#error DEM_CONTROL_DTC_WRONG_DTCGROUP already defined
#endif
/** \brief DTC setting control not successful because group of DTC was wrong */
#define DEM_CONTROL_DTC_WRONG_DTCGROUP 0x02U

/*-----------------[Dem_ReturnDisableDTCRecordUpdateType]-------------------*/

/** \brief Used to return the status of Dem_DisableDTCRecordUpdate() */
typedef uint8 Dem_ReturnDisableDTCRecordUpdateType;

#if (defined DEM_DISABLE_DTCRECUP_OK)
#error DEM_DISABLE_DTCRECUP_OK already defined
#endif
/** \brief Event memory update of DTC successfully disabled */
#define DEM_DISABLE_DTCRECUP_OK              0x00U

#if (defined DEM_DISABLE_DTCRECUP_WRONG_DTC)
#error DEM_DISABLE_DTCRECUP_WRONG_DTC already defined
#endif
/** \brief DTC value not existing(in UDS format) */
#define DEM_DISABLE_DTCRECUP_WRONG_DTC       0x01U

#if (defined DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN)
#error DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN already defined
#endif
/** \brief Wrong DTC origin */
#define DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN 0x02U

#if (defined DEM_DISABLE_DTCRECUP_PENDING)
#error DEM_DISABLE_DTCRECUP_PENDING already defined
#endif
/** \brief Disabling is currently not possible. The caller can retry later. */
#define DEM_DISABLE_DTCRECUP_PENDING         0x03U

/*-------------[Dem_ReturnGetFreezeFrameDataByRecordType]-------------------*/

/** \brief Used to return the status of Dem_GetFreezeFrameDataByRecord() */
typedef uint8 Dem_ReturnGetFreezeFrameDataByRecordType;

#if (defined DEM_GET_FFBYRECORD_OK)
#error DEM_GET_FFBYRECORD_OK already defined
#endif
/** \brief DTC successfully returned */
#define DEM_GET_FFBYRECORD_OK                0x00U

#if (defined DEM_GET_FFBYRECORD_WRONG_RECORD)
#error DEM_GET_FFBYRECORD_WRONG_RECORD already defined
#endif
/** \brief Wrong record */
#define DEM_GET_FFBYRECORD_WRONG_RECORD      0x01U

#if (defined DEM_GET_FFBYRECORD_NO_DTC_FOR_RECORD)
#error DEM_GET_FFBYRECORD_NO_DTC_FOR_RECORD already defined
#endif
/** \brief No DTC for record available */
#define DEM_GET_FFBYRECORD_NO_DTC_FOR_RECORD 0x02U

/*---------[Dem_ReturnGetExtendedDataRecordByDTCType]-----------------------*/

/** \brief Used to return the status of Dem_GetExtendedDataRecordByDTC() */
typedef uint8 Dem_ReturnGetExtendedDataRecordByDTCType;

#if (defined DEM_RECORD_OK)
#error DEM_RECORD_OK already defined
#endif
/** \brief Extended data record successfully returned */
#define DEM_RECORD_OK                0x00U

#if (defined DEM_RECORD_WRONG_DTC)
#error DEM_RECORD_WRONG_DTC already defined
#endif
/** \brief DTC value not existing (in UDS format) */
#define DEM_RECORD_WRONG_DTC         0x01U

#if (defined DEM_RECORD_WRONG_DTCORIGIN)
#error DEM_RECORD_WRONG_DTCORIGIN already defined
#endif
/** \brief Origin wrong */
#define DEM_RECORD_WRONG_DTCORIGIN   0x02U

#if (defined DEM_RECORD_WRONG_NUMBER)
#error DEM_RECORD_WRONG_NUMBER already defined
#endif
/** \brief Record number is not supported by configuration and therefore
 ** invalid
 */
#define DEM_RECORD_WRONG_NUMBER      0x03U

#if (defined DEM_RECORD_WRONG_BUFFERSIZE)
#error DEM_RECORD_WRONG_BUFFERSIZE already defined
#endif
/** \brief Provided buffer size too small */
#define DEM_RECORD_WRONG_BUFFERSIZE  0x04U

#if (defined DEM_RECORD_PENDING)
#error DEM_RECORD_PENDING already defined
#endif
/** \brief The requested value is calculated asynchronously and currently not
 ** available.
 ** The caller can retry later.
 */
#define DEM_RECORD_PENDING           0x05U

/*---------[Dem_ReturnGetDTCByOccurrenceTimeType]---------------------------*/

/** \brief Used to return the status of Dem_GetDTCByOccurrenceTime() */
typedef uint8 Dem_ReturnGetDTCByOccurrenceTimeType;

#if (defined DEM_OCCURR_OK)
#error DEM_OCCURR_OK already defined
#endif
/** \brief Matching DTC available */
#define DEM_OCCURR_OK                0x00U

#if (defined DEM_OCCURR_NOT_AVAILABLE)
#error DEM_OCCURR_NOT_AVAILABLE already defined
#endif
/** \brief No DTC is matching the requested occurrence time */
#define DEM_OCCURR_NOT_AVAILABLE     0x01U

/*---------[Dem_ReturnGetFreezeFrameDataByDTCType]--------------------------*/

/** \brief Used to return the status of Dem_GetFreezeFrameDataByDTC() */
typedef uint8 Dem_ReturnGetFreezeFrameDataByDTCType;

#if (defined DEM_GET_FFDATABYDTC_OK)
#error DEM_GET_FFDATABYDTC_OK already defined
#endif
/** \brief freeze frame data successfully returned */
#define DEM_GET_FFDATABYDTC_OK                 0x00U

#if (defined DEM_GET_FFDATABYDTC_WRONG_DTC)
#error DEM_GET_FFDATABYDTC_WRONG_DTC already defined
#endif
/** \brief DTC value not existing (in UDS format) */
#define DEM_GET_FFDATABYDTC_WRONG_DTC          0x01U

#if (defined DEM_GET_FFDATABYDTC_WRONG_DTCORIGIN)
#error DEM_GET_FFDATABYDTC_WRONG_DTCORIGIN already defined
#endif
/** \brief Wrong DTC origin */
#define DEM_GET_FFDATABYDTC_WRONG_DTCORIGIN    0x02U

#if (defined DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER)
#error DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER already defined
#endif
/** \brief Record number is not supported by configuration and therefore
 ** invalid
 */
#define DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER 0x03U

#if (defined DEM_GET_FFDATABYDTC_WRONG_BUFFERSIZE)
#error DEM_GET_FFDATABYDTC_WRONG_BUFFERSIZE already defined
#endif
/** \brief Provided buffer size too small */
#define DEM_GET_FFDATABYDTC_WRONG_BUFFERSIZE   0x04U

#if (defined DEM_GET_FFDATABYDTC_PENDING)
#error DEM_GET_FFDATABYDTC_PENDING already defined
#endif
/** \brief The requested value is calculated asynchronously and currently not
 ** available.
 ** The caller can retry later.
 */
#define DEM_GET_FFDATABYDTC_PENDING            0x05U

/*---------[Dem_ReturnGetSizeOfExtendedDataRecordByDTCType]-----------------*/

/** \brief Used to return the status of Dem_GetSizeOfExtendedDataRecordByDTC()
 */
typedef uint8 Dem_ReturnGetSizeOfExtendedDataRecordByDTCType;

#if (defined DEM_GET_SIZEOFEDRBYDTC_OK)
#error DEM_GET_SIZEOFEDRBYDTC_OK already defined
#endif
/** \brief Size successfully returned */
#define DEM_GET_SIZEOFEDRBYDTC_OK      0x00U

#if (defined DEM_GET_SIZEOFEDRBYDTC_W_DTC)
#error DEM_GET_SIZEOFEDRBYDTC_W_DTC already defined
#endif
/** \brief DTC value not existing (in UDS format) */
#define DEM_GET_SIZEOFEDRBYDTC_W_DTC   0x01U

#if (defined DEM_GET_SIZEOFEDRBYDTC_W_DTCOR)
#error DEM_GET_SIZEOFEDRBYDTC_W_DTCOR already defined
#endif
/** \brief Wrong DTC origin */
#define DEM_GET_SIZEOFEDRBYDTC_W_DTCOR 0x02U

#if (defined DEM_GET_SIZEOFEDRBYDTC_W_RNUM)
#error DEM_GET_SIZEOFEDRBYDTC_W_RNUM already defined
#endif
/** \brief Record number is not supported by configuration and therefore
 ** invalid
 */
#define DEM_GET_SIZEOFEDRBYDTC_W_RNUM  0x03U

#if (defined DEM_GET_SIZEOFEDRBYDTC_PENDING)
#error DEM_GET_SIZEOFEDRBYDTC_PENDING already defined
#endif
/** \brief The requested value is calculated asynchronously and currently
 ** not available.
 ** The caller can retry later.
 */
#define DEM_GET_SIZEOFEDRBYDTC_PENDING 0x04U

/*---------[Dem_ReturnGetSizeOfFreezeFrameByDTCType]------------------------*/

/** \brief Used to return the status of Dem_GetSizeOfFreezeFrameByDTC() */
typedef uint8 Dem_ReturnGetSizeOfFreezeFrameByDTCType;

#if (defined DEM_GET_SIZEOFFF_OK)
#error DEM_GET_SIZEOFFF_OK already defined
#endif
/** \brief Size successfully returned */
#define DEM_GET_SIZEOFFF_OK                 0x00U

#if (defined DEM_GET_SIZEOFFF_WRONG_DTC)
#error DEM_GET_SIZEOFFF_WRONG_DTC already defined
#endif
/** \brief DTC value not existing (in UDS format) */
#define DEM_GET_SIZEOFFF_WRONG_DTC          0x01U

#if (defined DEM_GET_SIZEOFFF_WRONG_DTCOR)
#error DEM_GET_SIZEOFFF_WRONG_DTCOR already defined
#endif
/** \brief Wrong DTC origin */
#define DEM_GET_SIZEOFFF_WRONG_DTCOR        0x02U

#if (defined DEM_GET_SIZEOFFF_WRONG_RNUM)
#error DEM_GET_SIZEOFFF_WRONG_RNUM already defined
#endif
/** \brief Record number is not supported by configuration and therefore
 ** invalid
 */
#define DEM_GET_SIZEOFFF_WRONG_RNUM         0x03U

#if (defined DEM_GET_SIZEOFFF_PENDING)
#error DEM_GET_SIZEOFFF_PENDING already defined
#endif
/** \brief The requested value is calculated asynchronously and currently not
 ** available.
 ** The caller can retry later.
 */
#define DEM_GET_SIZEOFFF_PENDING            0x04U

/*---------[Dem_ReturnGetSeverityOfDTCType]---------------------------------*/

/** \brief Used to return the status of Dem_GetSeverityOfDTC() */
typedef uint8 Dem_ReturnGetSeverityOfDTCType;

#if (defined DEM_GET_SEVERITYOFDTC_OK)
#error DEM_GET_SEVERITYOFDTC_OK already defined
#endif
/** \brief Severity successfully returned */
#define DEM_GET_SEVERITYOFDTC_OK              0x00U

#if (defined DEM_GET_SEVERITYOFDTC_WRONG_DTC)
#error DEM_GET_SEVERITYOFDTC_WRONG_DTC already defined
#endif
/** \brief DTC value not existing (in UDS format) */
#define DEM_GET_SEVERITYOFDTC_WRONG_DTC       0x01U

#if (defined DEM_GET_SEVERITYOFDTC_NOSEVERITY)
#error DEM_GET_SEVERITYOFDTC_NOSEVERITY already defined
#endif
/** \brief Severity information is not available */
#define DEM_GET_SEVERITYOFDTC_NOSEVERITY      0x02U

#if (defined DEM_GET_SEVERITYOFDTC_PENDING)
#error DEM_GET_SEVERITYOFDTC_PENDING already defined
#endif
/** \brief The requested value is calculated asynchronously and currently not
 ** available.
 ** The caller can retry later.
 */
#define DEM_GET_SEVERITYOFDTC_PENDING         0x03U

/*---------[Dem_ReturnGetFunctionalUnitOfDTCType]---------------------------*/

/** \brief Used to return the status of Dem_GetFunctionalUnitOfDTC() */
typedef uint8 Dem_ReturnGetFunctionalUnitOfDTCType;

#if (defined DEM_GET_FUNCTIONALUNITOFDTC_OK)
#error DEM_GET_FUNCTIONALUNITOFDTC_OK already defined
#endif
/** \brief Functional unit successfully returned */
#define DEM_GET_FUNCTIONALUNITOFDTC_OK              0x00U

#if (defined DEM_GET_FUNCTIONALUNITOFDTC_WRONG_DTC)
#error DEM_GET_FUNCTIONALUNITOFDTC_WRONG_DTC already defined
#endif
/** \brief DTC value not existing (in UDS format) */
#define DEM_GET_FUNCTIONALUNITOFDTC_WRONG_DTC       0x01U

/*------------------[>NvRAM-related types<]---------------------------------*/

/*---------[Dem_FFIdxType]--------------------------------------------------*/

/** \brief Number of freeze frames type
 **
 ** Note: The size of this type is defined by ISO14229-1.
 ** (FF RecordNumber = 0x01 ... 0xFE)
 **
 ** NumFF and MaxNumFF variables are also of this type.
 */
typedef uint8 Dem_FFIdxType;

/*------------------[definitions for Entry Types]---------------------------*/

/** \brief Entry data type, dynamic part of the error memory */
typedef uint8 Dem_EntryDataType;

/** \brief Entry data size type */
typedef uint16 Dem_SizeEntryDataType;

/*------------------[Dem_IndicatorCycleCounterType]-------------------------*/

/** \brief indicator cycle counter Type */
typedef uint8 Dem_IndicatorCycleCounterType;

/*------------------[Dem_FailureCycleCounterType]---------------------------*/

/** \brief Type for value of Event failure cycles */
typedef uint8 Dem_FailureCycleCounterType;

/*-----------------[Dem_DebounceCounterStatusType]--------------------------*/

/** \brief Status information for counter based debouncing algorithm */
typedef struct
{
  sint16              InternalCounter;          /**< internal counter value */
  Dem_EventStatusType Direction;                     /**< counter direction */
} Dem_DebounceCounterStatusType;

/*------------------[Dem_EntryStatusType]-----------------------------------*/

/** \brief Type concerning immediate storage */
typedef enum
{
  /** entry was not changed and needs not to be stored persistently */
  DEM_ENTRY_UNCHANGED,
  /** entry was changed and has to be stored persistently during shutdown */
  DEM_ENTRY_CHANGED,
  /** entry was changed and has to be stored persistent immediately */
  DEM_ENTRY_STORE_IMMEDIATELY,
  /** entry was cleared and has to be stored persistent immediately */
  DEM_ENTRY_CLEAR_IMMEDIATELY
} Dem_EntryStatusType;

/*---------------------[Dem_OccOrderType]-----------------------------------*/

/** \brief Type concerning occurrence order which is used for event
 ** displacement */
typedef uint16 Dem_OccOrderType;

/*------------------[Dem_EventMemoryEntryType]------------------------------*/

/** \brief Event memory entry type, static part of the error memory */
typedef struct
{
  Dem_EventIdType             EventId;           /**< Event Id of the entry */
  uint8                       OccCtr;
                               /**< Occurrence of event also used for NumFF */
#if (DEM_USE_EVENT_DISPLACEMENT == STD_ON)
  Dem_OccOrderType            OccOrder;
                     /**< Occurrence order of the event in the event memory */
#endif
#if (DEM_NUM_FAILURECYCLES > 0U)
  Dem_FailureCycleCounterType EventFailureCycleCounter;
                                        /**< Failure cycle counter of Event */
#endif
  Dem_SizeEntryDataType       EntryDataPos;
                               /**< Start of extended and freeze frame data */
#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)
  Dem_EntryStatusType         EntryStatus;
                                    /**< Entry status for immediate storage */
#endif
} Dem_EventMemoryEntryType;

/*------------------[types resulting into NVRAM blocks]---------------------*/

/* !LINKSTO dsn.Dem.NvMDataStructure,1 */
/** \brief Structure containing all non-volatile data
 **
 ** If no immediate storage is used, NvData consists of DTCStatusMask
 ** and event memory entries.
 ** If immediate storage is used, NvData consists of DTCStatusMask, but no
 ** event memory entries, as then the event memory data will be stored separately
 ** via gate-entry if immediate storage is enabled for any event.
 **
 ** Immediate storage = OFF:
 ** - NvM block DEM_NVM_BLOCK_ID_DEFAULT stores all non-volatile data
 ** Immediate storage = ON:
 ** - NvM block DEM_NVM_BLOCK_ID_DEFAULT stores DTCStatusMask
 ** - NvM block DEM_NVM_BLOCK_ID_PRIMARY stores entry related data of primary
 ** - NvM block DEM_NVM_BLOCK_ID_SECONDARY stores entry related data of sec
 ** - NvM block DEM_NVM_BLOCK_ID_MIRROR stores entry related data of mirror
 ** - NvM block DEM_NVM_BLOCK_ID_PERMANENT stores entry related data of perm
 **
 ** \note configuration dependent type
 */
typedef struct
{
  Dem_DTCStatusMaskType    DTCStatusMask[DEM_NUMBER_OF_EVENTS];
    /**< Status of each DTC. In case Nv storage of TF bit is disabled TF bit 0
         shall not be used */
  uint8                    EvMemOvfIndFlags;
    /**< Bit-field to store the overflow indication status of all event
         memorys (primary, secondary, mirror, permanent). One bit will be used
         per memory. */
#if (DEM_NUM_INDICATOR_LINKS > 0U)
  Dem_IndicatorCycleCounterType IndicatorCycleCounter[DEM_NUM_INDICATOR_LINKS];
                                               /**< indicator cycle counter */
  uint8 IndicatorCycleCounterRole[(DEM_NUM_INDICATOR_LINKS + 7U) / 8U];
                        /**< Flags to indicate indicator cycle counter role */
  uint8 IndicatorCycleCounterWIRStatus[(DEM_NUM_INDICATOR_LINKS + 7U) / 8U];
                  /**< Flags to indicate indicator cycle counter WIR status */
#endif
#if (DEM_OPCYC_NVSTORAGE == STD_ON)
  Dem_OperationCycleStateType Dem_OpCycleState[DEM_NUM_OPCYCLES];
                                                /**< Operation Cycle states */
#if (DEM_NUM_DEBOUNCE_COUNTER_PERM > 0U)
  Dem_DebounceCounterStatusType
    Dem_DebounceCounterStatus[DEM_NUM_DEBOUNCE_COUNTER_PERM];
      /**< Debouncing info for persistently stored counter debounced events */
#endif
#endif
#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_OFF)

  Dem_EventMemoryEntryType EventMemoryPrimary[
    DEM_MAX_NUMBER_EVENT_ENTRY_PRI];              /**< Primary event memory */
#if (DEM_MAX_NUMBER_EVENT_ENTRY_SEC != 0U)
  /* !LINKSTO Dem162_Implicit1,1 */
  Dem_EventMemoryEntryType EventMemorySecondary[
    DEM_MAX_NUMBER_EVENT_ENTRY_SEC];            /**< Secondary event memory */
#endif
#if (DEM_MAX_NUMBER_EVENT_ENTRY_MIR != 0U)
  /* !LINKSTO Dem162_Implicit1,1 */
  Dem_EventMemoryEntryType EventMemoryMirror[
    DEM_MAX_NUMBER_EVENT_ENTRY_MIR];               /**< Mirror event memory */
#endif
#if (DEM_MAX_NUMBER_EVENT_ENTRY_PER != 0U)
  /* !LINKSTO Dem162_Implicit1,1 */
  Dem_EventMemoryEntryType EventMemoryPermanent[
    DEM_MAX_NUMBER_EVENT_ENTRY_PER];            /**< Permanent event memory */
#endif
#if (DEM_SIZE_ENTRY_DATA_PRIMARY != 0U)
  Dem_EntryDataType        EntryDataPrimary[DEM_SIZE_ENTRY_DATA_PRIMARY];
                                               /**< Primary entry data area */
  Dem_SizeEntryDataType    EntryDataFreePosPrimary;
                                      /**< Primary entry data free position */
#endif
#if (DEM_SIZE_ENTRY_DATA_SECONDARY != 0U)
  Dem_EntryDataType        EntryDataSecondary[DEM_SIZE_ENTRY_DATA_SECONDARY];
                                             /**< Secondary entry data area */
  Dem_SizeEntryDataType    EntryDataFreePosSecondary;
                                    /**< Secondary entry data free position */
#endif
#if (DEM_SIZE_ENTRY_DATA_MIRROR != 0U)
  Dem_EntryDataType        EntryDataMirror[DEM_SIZE_ENTRY_DATA_MIRROR];
                                                /**< Mirror entry data area */
  Dem_SizeEntryDataType    EntryDataFreePosMirror;
                                       /**< Mirror entry data free position */
#endif
#if (DEM_SIZE_ENTRY_DATA_PERMANENT != 0U)
  Dem_EntryDataType        EntryDataPermanent[DEM_SIZE_ENTRY_DATA_PERMANENT];
                                             /**< Permanent entry data area */
  Dem_SizeEntryDataType    EntryDataFreePosPermanent;
                                    /**< Permanent entry data free position */
#endif

#endif /* DEM_USE_IMMEDIATE_NV_STORAGE == STD_OFF */
} Dem_NvDataType;

/*------------------[fragments to build up further gate-entry types]--------*/

/* These fragment-type definitions are used to build up similar types based on
 * a class-concept, but are not intended to be used by the implementation
 * directly. */

/** \brief gate-entry base fragment structure */
typedef struct
{
  Dem_EventIdType             EventId;           /**< Event Id of the entry */
  Dem_FFIdxType               OccCtr;
                               /**< Occurrence of Event also used for NumFF */
#if (DEM_USE_EVENT_DISPLACEMENT == STD_ON)
  Dem_OccOrderType            OccOrder;
                     /**< Occurrence order of the event in the event memory */
#endif
#if (DEM_NUM_FAILURECYCLES > 0U)
  Dem_FailureCycleCounterType EventFailureCycleCounter;
                                        /**< Failure cycle counter of Event */
#endif
} Dem_GateEntryBaseFragment;

/** \brief gate-entry primary data fragment structure */
typedef struct
{
  Dem_EntryDataType EntryData[DEM_SIZE_GATE_ENTRY_DATA_PRIMARY];
    /**< Entry data for gate-entry consisting of IntVal area, extended data and
         freeze frame data */
} Dem_GateEntryPrimaryFragment;

/** \brief gate-entry secondary data fragment structure */
typedef struct
{
  Dem_EntryDataType EntryData[DEM_SIZE_GATE_ENTRY_DATA_SECONDARY];
    /**< Entry data for gate-entry consisting of IntVal area, extended data and
         freeze frame data */
} Dem_GateEntrySecondaryFragment;

/** \brief gate-entry mirror data fragment structure */
typedef struct
{
  Dem_EntryDataType EntryData[DEM_SIZE_GATE_ENTRY_DATA_MIRROR];
    /**< Entry data for gate-entry consisting of IntVal area, extended data and
         freeze frame data */
} Dem_GateEntryMirrorFragment;

/** \brief gate-entry permanent data fragment structure */
typedef struct
{
  Dem_EntryDataType EntryData[DEM_SIZE_GATE_ENTRY_DATA_PERMANENT];
    /**< Entry data for gate-entry consisting of IntVal area, extended data and
         freeze frame data */
} Dem_GateEntryPermanentFragment;

/*------------------[gate-entry type inheritance structure]-----------------*/

/** \brief gate-entry data void type - used for pointers to gate-entry data */
typedef void Dem_GateEntryDataVoid;

/** \brief gate-entry data void pointer type */
typedef CONSTP2VAR(Dem_GateEntryDataVoid, DEM_CONST, DEM_VAR_NOINIT)
  Dem_GateEntryDataPtrVoid;

/** \brief gate-entry base type - used for basic access */
typedef struct
{
  Dem_GateEntryBaseFragment      EntryBase;          /**< Basic information */
} Dem_GateEntryBaseType;

/*------------------[types resulting into NVRAM blocks]---------------------*/

/** \brief gate-entry void type - used for pointers to gate entries */
typedef void Dem_NvGateEntryDataVoid;

/** \brief gate-entry void pointer type */
typedef CONSTP2VAR(Dem_NvGateEntryDataVoid, DEM_CONST, DEM_VAR_NOINIT)
  Dem_NvGateEntryDataPtrVoid;

/** \brief Structure containing all non-volatile primary event memory data
 ** for one gate-entry
 **
 ** \note configuration dependent type, derived from GateEntryBaseType
 **/
typedef struct
{
  Dem_GateEntryBaseFragment      EntryBase;          /**< Basic information */
  Dem_GateEntryPrimaryFragment   EntryPrimary;      /**< Primary entry data */
} Dem_NvGateEntryPrimaryDataType;

/** \brief Structure containing all non-volatile secondary event memory data
 ** for one gate-entry
 **
 ** \note configuration dependent type, derived from GateEntryBaseType
 **/
typedef struct
{
  Dem_GateEntryBaseFragment      EntryBase;          /**< Basic information */
  Dem_GateEntrySecondaryFragment EntrySecondary;  /**< Secondary entry data */
} Dem_NvGateEntrySecondaryDataType;

/** \brief Structure containing all non-volatile mirror event memory data
 ** for one gate-entry
 **
 ** \note configuration dependent type, derived from GateEntryBaseType
 **/
typedef struct
{
  Dem_GateEntryBaseFragment      EntryBase;          /**< Basic information */
  Dem_GateEntryMirrorFragment    EntryMirror;        /**< Mirror entry data */
} Dem_NvGateEntryMirrorDataType;

/** \brief Structure containing all non-volatile permanent event memory data
 ** for one gate-entry
 **
 ** \note configuration dependent type, derived from GateEntryBaseType
 **/
typedef struct
{
  Dem_GateEntryBaseFragment      EntryBase;          /**< Basic information */
  Dem_GateEntryPermanentFragment EntryPermanent;  /**< Permanent entry data */
} Dem_NvGateEntryPermanentDataType;

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

#endif /* if !defined( DEM_TYPES_H ) */
/*==================[end of file]===========================================*/
