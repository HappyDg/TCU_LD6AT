<html xmlns="http://www.w3.org/1999/xhtml"><head><title>RTA-OS Reference Guide: TriCoreHighTec</title><meta http-equiv="Content-Type" content="text/html; charset=ANSI" /><link href="OS API Reference.css" media="all" rel="Stylesheet" type="text/css" /></head><body><h1>RTA-OS Reference Guide: TriCoreHighTec</h1><table class="toc"><thead><tr class="toc1"><th class="toc1"><a href="#API">API calls</a></th><th class="toc1"><a href="#CBACK">Callbacks</a></th><th><a href="#TYPES">Types</a></th><th><a href="#MACROS">Macros</a></th></tr></thead><tbody><tr class="toc2"><td><a href="#ActivateTask">ActivateTask</a><br /><a href="#AllowAccess">AllowAccess</a><br /><a href="#CallAndProtectFunction">CallAndProtectFunction</a><br /><a href="#CallTrustedFunction">CallTrustedFunction</a><br /><a href="#CancelAlarm">CancelAlarm</a><br /><a href="#ChainTask">ChainTask</a><br /><a href="#CheckISRMemoryAccess">CheckISRMemoryAccess</a><br /><a href="#CheckObjectAccess">CheckObjectAccess</a><br /><a href="#CheckObjectOwnership">CheckObjectOwnership</a><br /><a href="#CheckTaskMemoryAccess">CheckTaskMemoryAccess</a><br /><a href="#ClearEvent">ClearEvent</a><br /><a href="#ControlIdle">ControlIdle</a><br /><a href="#DisableAllInterrupts">DisableAllInterrupts</a><br /><a href="#EnableAllInterrupts">EnableAllInterrupts</a><br /><a href="#GetActiveApplicationMode">GetActiveApplicationMode</a><br /><a href="#GetAlarm">GetAlarm</a><br /><a href="#GetAlarmBase">GetAlarmBase</a><br /><a href="#GetApplicationID">GetApplicationID</a><br /><a href="#GetApplicationState">GetApplicationState</a><br /><a href="#GetCoreID">GetCoreID</a><br /><a href="#GetCounterValue">GetCounterValue</a><br /><a href="#GetElapsedCounterValue">GetElapsedCounterValue</a><br /><a href="#GetElapsedValue">GetElapsedValue</a><br /><a href="#GetEvent">GetEvent</a><br /><a href="#GetISRID">GetISRID</a><br /><a href="#GetNumberOfActivatedCores">GetNumberOfActivatedCores</a><br /><a href="#GetResource">GetResource</a><br /><a href="#GetScheduleTableStatus">GetScheduleTableStatus</a><br /><a href="#GetSpinlock">GetSpinlock</a><br /><a href="#GetSpinlockInfo">GetSpinlockInfo</a><br /><a href="#GetTaskID">GetTaskID</a><br /><a href="#GetTaskState">GetTaskState</a><br /><a href="#IncrementCounter">IncrementCounter</a><br /><a href="#NextScheduleTable">NextScheduleTable</a><br /><a href="#Os_AddDelayedTasks">Os_AddDelayedTasks</a><br /><a href="#Os_AdvanceCounter">Os_AdvanceCounter</a><br /><a href="#Os_AdvanceCounter_&lt;CounterID&gt;">Os_AdvanceCounter_&lt;CounterID&gt;</a><br /><a href="#Os_CheckTraceOutput">Os_CheckTraceOutput</a><br /><a href="#Os_ClearTrigger">Os_ClearTrigger</a><br /><a href="#Os_DisableTraceCategories">Os_DisableTraceCategories</a><br /><a href="#Os_DisableTraceClasses">Os_DisableTraceClasses</a><br /><a href="#Os_EnableTraceCategories">Os_EnableTraceCategories</a><br /><a href="#Os_EnableTraceClasses">Os_EnableTraceClasses</a><br /><a href="#Os_GetElapsedTime">Os_GetElapsedTime</a><br /><a href="#Os_GetExecutionTime">Os_GetExecutionTime</a><br /><a href="#Os_GetIdleElapsedTime">Os_GetIdleElapsedTime</a><br /><a href="#Os_GetISRElapsedTime">Os_GetISRElapsedTime</a><br /><a href="#Os_GetISRMaxExecutionTime">Os_GetISRMaxExecutionTime</a><br /><a href="#Os_GetISRMaxStackUsage">Os_GetISRMaxStackUsage</a><br /><a href="#Os_GetStackSize">Os_GetStackSize</a><br /><a href="#Os_GetStackUsage">Os_GetStackUsage</a><br /><a href="#Os_GetStackValue">Os_GetStackValue</a><br /><a href="#Os_GetTaskActivationTime">Os_GetTaskActivationTime</a><br /><a href="#Os_GetTaskElapsedTime">Os_GetTaskElapsedTime</a><br /><a href="#Os_GetTaskMaxExecutionTime">Os_GetTaskMaxExecutionTime</a><br /><a href="#Os_GetTaskMaxStackUsage">Os_GetTaskMaxStackUsage</a><br /><a href="#Os_GetTrapInfo">Os_GetTrapInfo</a><br /><a href="#Os_GetVersionInfo">Os_GetVersionInfo</a><br /><a href="#Os_IncrementCounter_&lt;CounterID&gt;">Os_IncrementCounter_&lt;CounterID&gt;</a><br /><a href="#Os_InitializeInterruptTable">Os_InitializeInterruptTable</a><br /><a href="#Os_InitializeServiceRequests">Os_InitializeServiceRequests</a><br /><a href="#Os_InitializeTrapTable">Os_InitializeTrapTable</a><br /><a href="#Os_InitializeVectorTable">Os_InitializeVectorTable</a><br /><a href="#Os_LogCat1ISREnd">Os_LogCat1ISREnd</a><br /><a href="#Os_LogCat1ISRStart">Os_LogCat1ISRStart</a><br /><a href="#Os_LogCriticalExecutionEnd">Os_LogCriticalExecutionEnd</a><br /><a href="#Os_LogIntervalEnd">Os_LogIntervalEnd</a><br /><a href="#Os_LogIntervalEndData">Os_LogIntervalEndData</a><br /><a href="#Os_LogIntervalEndValue">Os_LogIntervalEndValue</a><br /><a href="#Os_LogIntervalStart">Os_LogIntervalStart</a><br /><a href="#Os_LogIntervalStartData">Os_LogIntervalStartData</a><br /><a href="#Os_LogIntervalStartValue">Os_LogIntervalStartValue</a><br /><a href="#Os_LogProfileStart">Os_LogProfileStart</a><br /><a href="#Os_LogTaskTracepoint">Os_LogTaskTracepoint</a><br /><a href="#Os_LogTaskTracepointData">Os_LogTaskTracepointData</a><br /><a href="#Os_LogTaskTracepointValue">Os_LogTaskTracepointValue</a><br /><a href="#Os_LogTracepoint">Os_LogTracepoint</a><br /><a href="#Os_LogTracepointData">Os_LogTracepointData</a><br /><a href="#Os_LogTracepointValue">Os_LogTracepointValue</a><br /><a href="#Os_RemoveDelayedTasks">Os_RemoveDelayedTasks</a><br /><a href="#Os_ResetIdleElapsedTime">Os_ResetIdleElapsedTime</a><br /><a href="#Os_ResetISRElapsedTime">Os_ResetISRElapsedTime</a><br /><a href="#Os_ResetISRMaxExecutionTime">Os_ResetISRMaxExecutionTime</a><br /><a href="#Os_ResetISRMaxStackUsage">Os_ResetISRMaxStackUsage</a><br /><a href="#Os_ResetTaskElapsedTime">Os_ResetTaskElapsedTime</a><br /><a href="#Os_ResetTaskMaxExecutionTime">Os_ResetTaskMaxExecutionTime</a><br /><a href="#Os_ResetTaskMaxStackUsage">Os_ResetTaskMaxStackUsage</a><br /><a href="#Os_Restart">Os_Restart</a><br /><a href="#Os_SetDelayedTasks">Os_SetDelayedTasks</a><br /><a href="#Os_SetRestartPoint">Os_SetRestartPoint</a><br /><a href="#Os_SetTraceRepeat">Os_SetTraceRepeat</a><br /><a href="#Os_SetTriggerWindow">Os_SetTriggerWindow</a><br /><a href="#Os_StartBurstingTrace">Os_StartBurstingTrace</a><br /><a href="#Os_StartCoreGate">Os_StartCoreGate</a><br /><a href="#Os_StartFreeRunningTrace">Os_StartFreeRunningTrace</a><br /><a href="#Os_StartTriggeringTrace">Os_StartTriggeringTrace</a><br /><a href="#Os_StopTrace">Os_StopTrace</a><br /><a href="#Os_SyncScheduleTableRel">Os_SyncScheduleTableRel</a><br /><a href="#Os_TimingFaultDetected">Os_TimingFaultDetected</a><br /><a href="#Os_TraceCommInit">Os_TraceCommInit</a><br /><a href="#Os_TraceDumpAsync">Os_TraceDumpAsync</a><br /><a href="#Os_TriggerNow">Os_TriggerNow</a><br /><a href="#Os_TriggerOnActivation">Os_TriggerOnActivation</a><br /><a href="#Os_TriggerOnAdvanceCounter">Os_TriggerOnAdvanceCounter</a><br /><a href="#Os_TriggerOnAlarmExpiry">Os_TriggerOnAlarmExpiry</a><br /><a href="#Os_TriggerOnCat1ISRStart">Os_TriggerOnCat1ISRStart</a><br /><a href="#Os_TriggerOnCat1ISRStop">Os_TriggerOnCat1ISRStop</a><br /><a href="#Os_TriggerOnCat2ISRStart">Os_TriggerOnCat2ISRStart</a><br /><a href="#Os_TriggerOnCat2ISRStop">Os_TriggerOnCat2ISRStop</a><br /><a href="#Os_TriggerOnChain">Os_TriggerOnChain</a><br /><a href="#Os_TriggerOnError">Os_TriggerOnError</a><br /><a href="#Os_TriggerOnGetResource">Os_TriggerOnGetResource</a><br /><a href="#Os_TriggerOnIncrementCounter">Os_TriggerOnIncrementCounter</a><br /><a href="#Os_TriggerOnIntervalEnd">Os_TriggerOnIntervalEnd</a><br /><a href="#Os_TriggerOnIntervalStart">Os_TriggerOnIntervalStart</a><br /><a href="#Os_TriggerOnIntervalStop">Os_TriggerOnIntervalStop</a><br /><a href="#Os_TriggerOnReleaseResource">Os_TriggerOnReleaseResource</a><br /><a href="#Os_TriggerOnScheduleTableExpiry">Os_TriggerOnScheduleTableExpiry</a><br /><a href="#Os_TriggerOnSetEvent">Os_TriggerOnSetEvent</a><br /><a href="#Os_TriggerOnShutdown">Os_TriggerOnShutdown</a><br /><a href="#Os_TriggerOnTaskStart">Os_TriggerOnTaskStart</a><br /><a href="#Os_TriggerOnTaskStop">Os_TriggerOnTaskStop</a><br /><a href="#Os_TriggerOnTaskTracepoint">Os_TriggerOnTaskTracepoint</a><br /><a href="#Os_TriggerOnTracepoint">Os_TriggerOnTracepoint</a><br /><a href="#Os_UploadTraceData">Os_UploadTraceData</a><br /><a href="#ReleaseResource">ReleaseResource</a><br /><a href="#ReleaseSpinlock">ReleaseSpinlock</a><br /><a href="#ResetSpinlockInfo">ResetSpinlockInfo</a><br /><a href="#ResumeAllInterrupts">ResumeAllInterrupts</a><br /><a href="#ResumeOSInterrupts">ResumeOSInterrupts</a><br /><a href="#Schedule">Schedule</a><br /><a href="#SetAbsAlarm">SetAbsAlarm</a><br /><a href="#SetEvent">SetEvent</a><br /><a href="#SetRelAlarm">SetRelAlarm</a><br /><a href="#SetScheduleTableAsync">SetScheduleTableAsync</a><br /><a href="#ShutdownAllCores">ShutdownAllCores</a><br /><a href="#ShutdownOS">ShutdownOS</a><br /><a href="#StartCore">StartCore</a><br /><a href="#StartNonAutosarCore">StartNonAutosarCore</a><br /><a href="#StartOS">StartOS</a><br /><a href="#StartScheduleTableAbs">StartScheduleTableAbs</a><br /><a href="#StartScheduleTableRel">StartScheduleTableRel</a><br /><a href="#StartScheduleTableSynchron">StartScheduleTableSynchron</a><br /><a href="#StopScheduleTable">StopScheduleTable</a><br /><a href="#SuspendAllInterrupts">SuspendAllInterrupts</a><br /><a href="#SuspendOSInterrupts">SuspendOSInterrupts</a><br /><a href="#SyncScheduleTable">SyncScheduleTable</a><br /><a href="#TerminateApplication">TerminateApplication</a><br /><a href="#TerminateTask">TerminateTask</a><br /><a href="#TryToGetSpinlock">TryToGetSpinlock</a><br /><a href="#UncheckedGetSpinlock">UncheckedGetSpinlock</a><br /><a href="#UncheckedReleaseSpinlock">UncheckedReleaseSpinlock</a><br /><a href="#UncheckedTryToGetSpinlock">UncheckedTryToGetSpinlock</a><br /><a href="#WaitEvent">WaitEvent</a><br /></td><td><a href="#ErrorHook">ErrorHook</a><br /><a href="#Os_Cbk_Cancel_&lt;CounterID&gt;">Os_Cbk_Cancel_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_CheckMemoryAccess">Os_Cbk_CheckMemoryAccess</a><br /><a href="#Os_Cbk_CheckStackDepth">Os_Cbk_CheckStackDepth</a><br /><a href="#Os_Cbk_CrosscoreISREnd">Os_Cbk_CrosscoreISREnd</a><br /><a href="#Os_Cbk_CrosscoreISRStart">Os_Cbk_CrosscoreISRStart</a><br /><a href="#Os_Cbk_Disable_&lt;ISRName&gt;">Os_Cbk_Disable_&lt;ISRName&gt;</a><br /><a href="#Os_Cbk_GetStopwatch">Os_Cbk_GetStopwatch</a><br /><a href="#Os_Cbk_Idle">Os_Cbk_Idle</a><br /><a href="#Os_Cbk_ISREnd">Os_Cbk_ISREnd</a><br /><a href="#Os_Cbk_ISRStart">Os_Cbk_ISRStart</a><br /><a href="#Os_Cbk_Now_&lt;CounterID&gt;">Os_Cbk_Now_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_RegSetRestore_&lt;RegisterSetID&gt;">Os_Cbk_RegSetRestore_&lt;RegisterSetID&gt;</a><br /><a href="#Os_Cbk_RegSetSave_&lt;RegisterSetID&gt;">Os_Cbk_RegSetSave_&lt;RegisterSetID&gt;</a><br /><a href="#Os_Cbk_Set_&lt;CounterID&gt;">Os_Cbk_Set_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_SetMemoryAccess">Os_Cbk_SetMemoryAccess</a><br /><a href="#Os_Cbk_SetTimeLimit">Os_Cbk_SetTimeLimit</a><br /><a href="#Os_Cbk_StackOverrunHook">Os_Cbk_StackOverrunHook</a><br /><a href="#Os_Cbk_StartCore">Os_Cbk_StartCore</a><br /><a href="#Os_Cbk_State_&lt;CounterID&gt;">Os_Cbk_State_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_SuspendTimeLimit">Os_Cbk_SuspendTimeLimit</a><br /><a href="#Os_Cbk_TaskActivated">Os_Cbk_TaskActivated</a><br /><a href="#Os_Cbk_TaskEnd">Os_Cbk_TaskEnd</a><br /><a href="#Os_Cbk_TaskStart">Os_Cbk_TaskStart</a><br /><a href="#Os_Cbk_Terminated_&lt;ISRName&gt;">Os_Cbk_Terminated_&lt;ISRName&gt;</a><br /><a href="#Os_Cbk_TimeOverrunHook">Os_Cbk_TimeOverrunHook</a><br /><a href="#Os_Cbk_TraceCommDataReady">Os_Cbk_TraceCommDataReady</a><br /><a href="#Os_Cbk_TraceCommInitTarget">Os_Cbk_TraceCommInitTarget</a><br /><a href="#Os_Cbk_TraceCommTxByte">Os_Cbk_TraceCommTxByte</a><br /><a href="#Os_Cbk_TraceCommTxEnd">Os_Cbk_TraceCommTxEnd</a><br /><a href="#Os_Cbk_TraceCommTxReady">Os_Cbk_TraceCommTxReady</a><br /><a href="#Os_Cbk_TraceCommTxStart">Os_Cbk_TraceCommTxStart</a><br /><a href="#PostTaskHook">PostTaskHook</a><br /><a href="#PreTaskHook">PreTaskHook</a><br /><a href="#ProtectionHook">ProtectionHook</a><br /><a href="#ShutdownHook">ShutdownHook</a><br /><a href="#StartupHook">StartupHook</a><br /></td><td><a href="#AccessType">AccessType</a><br /><a href="#AlarmBaseRefType">AlarmBaseRefType</a><br /><a href="#AlarmBaseType">AlarmBaseType</a><br /><a href="#AlarmType">AlarmType</a><br /><a href="#ApplicationStateRefType">ApplicationStateRefType</a><br /><a href="#ApplicationStateType">ApplicationStateType</a><br /><a href="#ApplicationType">ApplicationType</a><br /><a href="#AppModeType">AppModeType</a><br /><a href="#boolean">boolean</a><br /><a href="#CoreIdType">CoreIdType</a><br /><a href="#CounterType">CounterType</a><br /><a href="#EventMaskRefType">EventMaskRefType</a><br /><a href="#EventMaskType">EventMaskType</a><br /><a href="#float32">float32</a><br /><a href="#float64">float64</a><br /><a href="#ISRRefType">ISRRefType</a><br /><a href="#ISRType">ISRType</a><br /><a href="#MemorySizeType">MemorySizeType</a><br /><a href="#MemoryStartAddressType">MemoryStartAddressType</a><br /><a href="#ObjectAccessType">ObjectAccessType</a><br /><a href="#ObjectTypeType">ObjectTypeType</a><br /><a href="#Os_AnyType">Os_AnyType</a><br /><a href="#Os_AsyncPushCallbackType">Os_AsyncPushCallbackType</a><br /><a href="#Os_CounterStatusRefType">Os_CounterStatusRefType</a><br /><a href="#Os_CounterStatusType">Os_CounterStatusType</a><br /><a href="#Os_SpinlockInfo">Os_SpinlockInfo</a><br /><a href="#Os_SpinlockInfoRefType">Os_SpinlockInfoRefType</a><br /><a href="#Os_StackOverrunType">Os_StackOverrunType</a><br /><a href="#Os_StatusRefType">Os_StatusRefType</a><br /><a href="#Os_StopwatchTickRefType">Os_StopwatchTickRefType</a><br /><a href="#Os_StopwatchTickType">Os_StopwatchTickType</a><br /><a href="#Os_TasksetType">Os_TasksetType</a><br /><a href="#Os_TimeLimitType">Os_TimeLimitType</a><br /><a href="#Os_TraceCategoriesType">Os_TraceCategoriesType</a><br /><a href="#Os_TraceClassesType">Os_TraceClassesType</a><br /><a href="#Os_TraceDataLengthType">Os_TraceDataLengthType</a><br /><a href="#Os_TraceDataPtrType">Os_TraceDataPtrType</a><br /><a href="#Os_TraceExpiryIDType">Os_TraceExpiryIDType</a><br /><a href="#Os_TraceIndexType">Os_TraceIndexType</a><br /><a href="#Os_TraceInfoType">Os_TraceInfoType</a><br /><a href="#Os_TraceIntervalIDType">Os_TraceIntervalIDType</a><br /><a href="#Os_TraceStatusType">Os_TraceStatusType</a><br /><a href="#Os_TraceTracepointIDType">Os_TraceTracepointIDType</a><br /><a href="#Os_TraceValueType">Os_TraceValueType</a><br /><a href="#Os_UntrustedContextRefType">Os_UntrustedContextRefType</a><br /><a href="#Os_UntrustedContextType">Os_UntrustedContextType</a><br /><a href="#OSServiceIdType">OSServiceIdType</a><br /><a href="#OsTrapInfoRefType">OsTrapInfoRefType</a><br /><a href="#OsTrapInfoType">OsTrapInfoType</a><br /><a href="#PhysicalTimeType">PhysicalTimeType</a><br /><a href="#ProtectionReturnType">ProtectionReturnType</a><br /><a href="#ResourceType">ResourceType</a><br /><a href="#RestartType">RestartType</a><br /><a href="#ScheduleTableRefType">ScheduleTableRefType</a><br /><a href="#ScheduleTableStatusRefType">ScheduleTableStatusRefType</a><br /><a href="#ScheduleTableStatusType">ScheduleTableStatusType</a><br /><a href="#ScheduleTableType">ScheduleTableType</a><br /><a href="#SignedTickType">SignedTickType</a><br /><a href="#sint16">sint16</a><br /><a href="#sint16_least">sint16_least</a><br /><a href="#sint32">sint32</a><br /><a href="#sint32_least">sint32_least</a><br /><a href="#sint8">sint8</a><br /><a href="#sint8_least">sint8_least</a><br /><a href="#SpinlockIdType">SpinlockIdType</a><br /><a href="#StatusType">StatusType</a><br /><a href="#Std_ReturnType">Std_ReturnType</a><br /><a href="#Std_VersionInfoType">Std_VersionInfoType</a><br /><a href="#TaskRefType">TaskRefType</a><br /><a href="#TaskStateRefType">TaskStateRefType</a><br /><a href="#TaskStateType">TaskStateType</a><br /><a href="#TaskType">TaskType</a><br /><a href="#TickRefType">TickRefType</a><br /><a href="#TickType">TickType</a><br /><a href="#TrustedFunctionIndexType">TrustedFunctionIndexType</a><br /><a href="#TrustedFunctionParameterRefType">TrustedFunctionParameterRefType</a><br /><a href="#TryToGetSpinlockType">TryToGetSpinlockType</a><br /><a href="#uint16">uint16</a><br /><a href="#uint16_least">uint16_least</a><br /><a href="#uint32">uint32</a><br /><a href="#uint32_least">uint32_least</a><br /><a href="#uint8">uint8</a><br /><a href="#uint8_least">uint8_least</a><br /></td><td><a href="#ALARMCALLBACK">ALARMCALLBACK</a><br /><a href="#DeclareAlarm">DeclareAlarm</a><br /><a href="#DeclareCounter">DeclareCounter</a><br /><a href="#DeclareEvent">DeclareEvent</a><br /><a href="#DeclareISR">DeclareISR</a><br /><a href="#DeclareResource">DeclareResource</a><br /><a href="#DeclareResource">DeclareResource</a><br /><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#DeclareTask">DeclareTask</a><br /><a href="#DONOTCARE">DONOTCARE</a><br /><a href="#INVALID_SPINLOCK">INVALID_SPINLOCK</a><br /><a href="#ISR">ISR</a><br /><a href="#OS_ACTIVATION_MONITORING">OS_ACTIVATION_MONITORING</a><br /><a href="#OS_ADD_TASK">OS_ADD_TASK</a><br /><a href="#OS_CORE_CURRENT">OS_CORE_CURRENT</a><br /><a href="#OS_CORE_FOR_&lt;TaskOrISR&gt;">OS_CORE_FOR_&lt;TaskOrISR&gt;</a><br /><a href="#OS_CORE_FOR_ISR">OS_CORE_FOR_ISR</a><br /><a href="#OS_CORE_FOR_TASK">OS_CORE_FOR_TASK</a><br /><a href="#OS_CORE_ID_0">OS_CORE_ID_0</a><br /><a href="#OS_CORE_ID_1">OS_CORE_ID_1</a><br /><a href="#OS_CORE_ID_MASTER">OS_CORE_ID_MASTER</a><br /><a href="#OS_CORE_isrname">OS_CORE_isrname</a><br /><a href="#OS_CURRENT_IDLEMODE">OS_CURRENT_IDLEMODE</a><br /><a href="#Os_Disable_x">Os_Disable_x</a><br /><a href="#Os_DisableAllConfiguredInterrupts">Os_DisableAllConfiguredInterrupts</a><br /><a href="#OS_DURATION_&lt;ScheduleTableID&gt;">OS_DURATION_&lt;ScheduleTableID&gt;</a><br /><a href="#OS_ELAPSED_TIME_RECORDING">OS_ELAPSED_TIME_RECORDING</a><br /><a href="#Os_Enable_x">Os_Enable_x</a><br /><a href="#Os_EnableAllConfiguredInterrupts">Os_EnableAllConfiguredInterrupts</a><br /><a href="#OS_EXTENDED_STATUS">OS_EXTENDED_STATUS</a><br /><a href="#OS_FAST_TASK_TERMINATION">OS_FAST_TASK_TERMINATION</a><br /><a href="#OS_INDEX_TO_ISRTYPE">OS_INDEX_TO_ISRTYPE</a><br /><a href="#OS_INDEX_TO_TASKTYPE">OS_INDEX_TO_TASKTYPE</a><br /><a href="#Os_IntChannel_x">Os_IntChannel_x</a><br /><a href="#OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a><br /><a href="#OS_MAIN">OS_MAIN</a><br /><a href="#OS_NO_TASKS">OS_NO_TASKS</a><br /><a href="#OS_NOAPPMODE">OS_NOAPPMODE</a><br /><a href="#OS_NUM_ALARMS">OS_NUM_ALARMS</a><br /><a href="#OS_NUM_APPLICATIONS">OS_NUM_APPLICATIONS</a><br /><a href="#OS_NUM_APPMODES">OS_NUM_APPMODES</a><br /><a href="#OS_NUM_CORES">OS_NUM_CORES</a><br /><a href="#OS_NUM_COUNTERS">OS_NUM_COUNTERS</a><br /><a href="#OS_NUM_EVENTS">OS_NUM_EVENTS</a><br /><a href="#OS_NUM_INTERVALS">OS_NUM_INTERVALS</a><br /><a href="#OS_NUM_ISRS">OS_NUM_ISRS</a><br /><a href="#OS_NUM_OS_CORES">OS_NUM_OS_CORES</a><br /><a href="#OS_NUM_RESOURCES">OS_NUM_RESOURCES</a><br /><a href="#OS_NUM_SCHEDULETABLES">OS_NUM_SCHEDULETABLES</a><br /><a href="#OS_NUM_SPINLOCKS">OS_NUM_SPINLOCKS</a><br /><a href="#OS_NUM_TASKS">OS_NUM_TASKS</a><br /><a href="#OS_NUM_TASKTRACEPOINTS">OS_NUM_TASKTRACEPOINTS</a><br /><a href="#OS_NUM_TRACECATEGORIES">OS_NUM_TRACECATEGORIES</a><br /><a href="#OS_NUM_TRACEPOINTS">OS_NUM_TRACEPOINTS</a><br /><a href="#OS_NUM_TRUSTED_FUNCTIONS">OS_NUM_TRUSTED_FUNCTIONS</a><br /><a href="#OS_REGSET_&lt;RegisterSetID&gt;_SIZE">OS_REGSET_&lt;RegisterSetID&gt;_SIZE</a><br /><a href="#OS_SCALABILITY_CLASS_1">OS_SCALABILITY_CLASS_1</a><br /><a href="#OS_SCALABILITY_CLASS_2">OS_SCALABILITY_CLASS_2</a><br /><a href="#OS_SCALABILITY_CLASS_3">OS_SCALABILITY_CLASS_3</a><br /><a href="#OS_SCALABILITY_CLASS_4">OS_SCALABILITY_CLASS_4</a><br /><a href="#OS_STACK_MONITORING">OS_STACK_MONITORING</a><br /><a href="#OS_STANDARD_STATUS">OS_STANDARD_STATUS</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /><a href="#OS_TICKS2&lt;Unit&gt;_&lt;CounterID&gt;(ticks)">OS_TICKS2&lt;Unit&gt;_&lt;CounterID&gt;(ticks)</a><br /><a href="#OS_TIME_MONITORING">OS_TIME_MONITORING</a><br /><a href="#OS_TRACE">OS_TRACE</a><br /><a href="#OS_VEC_isrname">OS_VEC_isrname</a><br /><a href="#OSCYCLEDURATION">OSCYCLEDURATION</a><br /><a href="#OSCYCLESPERSECOND">OSCYCLESPERSECOND</a><br /><a href="#OSErrorGetServiceId">OSErrorGetServiceId</a><br /><a href="#OSMAXALLOWEDVALUE">OSMAXALLOWEDVALUE</a><br /><a href="#OSMAXALLOWEDVALUE_&lt;CounterID&gt;">OSMAXALLOWEDVALUE_&lt;CounterID&gt;</a><br /><a href="#OSMEMORY_IS_EXECUTABLE">OSMEMORY_IS_EXECUTABLE</a><br /><a href="#OSMEMORY_IS_READABLE">OSMEMORY_IS_READABLE</a><br /><a href="#OSMEMORY_IS_STACKSPACE">OSMEMORY_IS_STACKSPACE</a><br /><a href="#OSMEMORY_IS_WRITEABLE">OSMEMORY_IS_WRITEABLE</a><br /><a href="#OSMINCYCLE">OSMINCYCLE</a><br /><a href="#OSMINCYCLE_&lt;CounterID&gt;">OSMINCYCLE_&lt;CounterID&gt;</a><br /><a href="#OSSWTICKDURATION">OSSWTICKDURATION</a><br /><a href="#OSSWTICKSPERSECOND">OSSWTICKSPERSECOND</a><br /><a href="#OSTICKDURATION">OSTICKDURATION</a><br /><a href="#OSTICKDURATION_&lt;CounterID&gt;">OSTICKDURATION_&lt;CounterID&gt;</a><br /><a href="#OSTICKSPERBASE">OSTICKSPERBASE</a><br /><a href="#OSTICKSPERBASE_&lt;CounterID&gt;">OSTICKSPERBASE_&lt;CounterID&gt;</a><br /><a href="#TASK">TASK</a><br /><a href="#TASK_MASK">TASK_MASK</a><br /></td></tr></tbody></table><h1><a name="API">API calls</a></h1><h2 xmlns=""><a name="ActivateTask">ActivateTask</a></h2><p xmlns="">Activate a task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType ActivateTask(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>The task to activate.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_LIMIT</td><td>all</td><td>The requested activation would exceed the maximum number of queued activations specified by configuration. The requested activation is ignored.</td></tr><tr><td class="CodeBodyText">E_OS_CORE</td><td>all</td><td>The task belongs to a core that is stopped (in Shutdown).</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>TaskID is not a valid TaskType.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">If TaskID is in the suspended state then it is transferred into the ready state.</p><p xmlns="">If TaskID is in either the ready or the running state and the total number of queued activations is less than the task activation limit then the requested activation is queued.</p><p xmlns="">Rescheduling behavior depends on the caller:</p><p xmlns="">- if the caller is a non-preemptive task the rescheduling does not occur until the caller terminates or makes a Schedule() call.</p><p xmlns="">- if the caller is a preemptive task and TaskID is higher priority then rescheduling will take place immediately.</p><p xmlns="">- if the caller is a Category 2 ISR then rescheduling will not occur until after the Category 2 ISR terminates.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  ActivateTask(YourTask);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareTask">DeclareTask</a><br /><a href="#ChainTask">ChainTask</a><br /><a href="#TerminateTask">TerminateTask</a><br /><a href="#GetTaskState">GetTaskState</a><br /><a href="#GetTaskID">GetTaskID</a><br /></p><h2 xmlns=""><a name="AllowAccess">AllowAccess</a></h2><p xmlns="">Change the state of the current OS-Application from APPLICATION_RESTARTING to APPLICATION_ACCESSIBLE.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType AllowAccess(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>all</td><td>Application state is not APPLICATION_RESTARTING .</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The call changes the state of the calling OS-Application to APPLICATION_ACCESSIBLE, provided that the current state was APPLICATION_RESTARTING.</p><p xmlns="">This is normally used from a restart task to re-enable access to a terminated OS-Application.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(AppRestarter) {
  AllowAccess();
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TerminateApplication">TerminateApplication</a><br /><a href="#GetApplicationState">GetApplicationState</a><br /></p><h2 xmlns=""><a name="CallAndProtectFunction">CallAndProtectFunction</a></h2><p xmlns="">Call a time-limited OS-Application function.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType CallAndProtectFunction(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams, Os_TimeLimitType TimeLimit)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">FunctionIndex</td><td class="CodeBodyText">TrustedFunctionIndexType</td><td>in</td><td>The index of the function to be called. This is the same as the name declared for the function.</td></tr><tr><td class="CodeBodyText">FunctionParams</td><td class="CodeBodyText">TrustedFunctionParameterRefType</td><td>in</td><td>A pointer to the parameters of the function. Can be NULL.</td></tr><tr><td class="CodeBodyText">TimeLimit</td><td class="CodeBodyText">Os_TimeLimitType</td><td>in</td><td>The maximum number of ticks of the stopwatch that the function is allowed to run for. If this value is less than 1 then no limit is applied.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_SERVICEID</td><td>all</td><td>FunctionIndex is not valid.</td></tr><tr><td class="CodeBodyText">E_OS_PROTECTION_TIME</td><td>all</td><td>Function timed out AND the ProtectionHook returned PRO_TERMINATETASKISR.</td></tr><tr><td class="CodeBodyText">E_OS_PROTECTION_LOCKED</td><td>all</td><td>Function locked a resource or interrupt for too long AND the ProtectionHook returned PRO_TERMINATETASKISR.</td></tr><tr><td class="CodeBodyText">E_OS_PROTECTION_MEMORY</td><td>all</td><td>Function experienced a memory protection violation AND the ProtectionHook returned PRO_TERMINATETASKISR.</td></tr><tr><td class="CodeBodyText">E_OS_PROTECTION_EXCEPTION</td><td>all</td><td>Function experienced an unexpected exception AND the ProtectionHook returned PRO_TERMINATETASKISR.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>The function is part of an OS-Application on a different core</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This is exactly the same as CallTrustedFunction, but with the addition of a Timing Protection execution limit and the ability to recover from a memory protection violation.</p><p xmlns="">If the function execution time reaches the specified limit, then ProtectionHook gets called with Reason 'E_OS_PROTECTION_TIME'. Within ProtectionHook you can choose to shutdown or kill the OS-Application. Alternatively if you return PRO_TERMINATETASKISR then you merely terminate the remaining execution of the function and CallAndProtectFunction will return with a status of E_OS_PROTECTION_TIME.</p><p xmlns="">Similarly resource and interrupt lock violations can cause termination with 'E_OS_PROTECTION_LOCKED', and memory violations can cause termination with 'E_OS_PROTECTION_MEMORY' or 'E_OS_PROTECTION_EXCEPTION'.</p><p xmlns="">CallAndProtectFunction can only be used if you configure the OS option 'Function Protection'.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  struct func3_params {
    uint32 val1;
    uint32 val2;
  } data = {1U, 2U};
  ...
  CallAndProtectFunction(Func3, (TrustedFunctionParameterRefType)&amp;data, (0.001 * OSSWTICKSPERSECOND)); /* Limit 1ms */
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CallTrustedFunction">CallTrustedFunction</a><br /><a href="#ProtectionHook">ProtectionHook</a><br /><a href="#Os_TimeLimitType">Os_TimeLimitType</a><br /><a href="#Os_Cbk_SetMemoryAccess">Os_Cbk_SetMemoryAccess</a><br /></p><h2 xmlns=""><a name="CallTrustedFunction">CallTrustedFunction</a></h2><p xmlns="">Call an OS-Application function.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType CallTrustedFunction(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">FunctionIndex</td><td class="CodeBodyText">TrustedFunctionIndexType</td><td>in</td><td>The index of the function to be called. This is the same as the name declared for the function.</td></tr><tr><td class="CodeBodyText">FunctionParams</td><td class="CodeBodyText">TrustedFunctionParameterRefType</td><td>in</td><td>A pointer to the parameters of the function. Can be NULL.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_SERVICEID</td><td>all</td><td>FunctionIndex is not valid.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>The function is part of an OS-Application on a different core</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Call a function provided by an OS-application. The service is typically used to allow a non-trusted OS-Application to call a function provided by a trusted OS-Application.</p><p xmlns="">RTA-OS also allows you to call a function provided by an *untrusted* OS-Application. This means that you can have a trusted task that calls a set of untrusted functions.</p><p xmlns="">When a function is called, it always runs with the access permissions of the OS-Application to which it belongs.</p><p xmlns="">*NOTE*</p><p xmlns="">For AUTOSAR version 4.0.3, the following requirement exists:</p><p xmlns="">'Reaction to timing protection can be defined to terminate the OSApplication. If a task is inside CallTrustedFunction() and task rescheduling takes place within the same OSApplication, the newly running higher priority task may cause timing protection and terminate the OSApplication, thus indirectly aborting the trusted function. To avoid this, the scheduling of other Tasks which belong to the same OS-Application as the caller needs to be restricted, as well as the availability of interrupts of the same OS-Application.'</p><p xmlns="">RTA-OS does not implement this behavior, because of the impact on performance at run-time.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask) {
  struct func3_params {
    uint32 val1;
    uint32 val2;
  } data = {1U, 2U};
  ...
  CallTrustedFunction(Func1, (TrustedFunctionParameterRefType)0U);
  CallTrustedFunction(Func2, (TrustedFunctionParameterRefType)&amp;value);
  CallTrustedFunction(Func3, (TrustedFunctionParameterRefType)&amp;data);
  ...
}
...
void TRUSTED_Func3(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams) {
    struct func3_params *params = (struct func3_params *)FunctionParams;
    if (params-&gt;val2 &lt; 100U) {
        ...
    }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CallAndProtectFunction">CallAndProtectFunction</a><br /><a href="#Os_Cbk_SetMemoryAccess">Os_Cbk_SetMemoryAccess</a><br /></p><h2 xmlns=""><a name="CancelAlarm">CancelAlarm</a></h2><p xmlns="">Cancel an alarm.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType CancelAlarm(AlarmType AlarmID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">AlarmID</td><td class="CodeBodyText">AlarmType</td><td>in</td><td>Name of the alarm to cancel.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_NOFUNC</td><td>all</td><td>AlarmID is not running.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>AlarmID is not a valid alarm.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>AlarmID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call cancels (stops) the specified alarm.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyExtendedTask){
  ...
  CancelAlarm(TimeOutAlarm);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CancelAlarm">CancelAlarm</a><br /><a href="#DeclareAlarm">DeclareAlarm</a><br /><a href="#GetAlarm">GetAlarm</a><br /><a href="#GetAlarmBase">GetAlarmBase</a><br /><a href="#SetRelAlarm">SetRelAlarm</a><br /></p><h2 xmlns=""><a name="ChainTask">ChainTask</a></h2><p xmlns="">Terminate the calling task and activate another task</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType ChainTask(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>The task to be activated</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OS_LIMIT</td><td>all</td><td>The requested activation would exceed the maximum number of queued activations specified by configuration. The requested activation is ignored.</td></tr><tr><td class="CodeBodyText">E_OS_CORE</td><td>all</td><td>The task belongs to a core that is stopped (in Shutdown).</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>TaskID is not a valid TaskType.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_RESOURCE</td><td>extended</td><td>Calling task still holds resources.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called at interrupt level.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This service causes the termination of the calling task followed by the activation of TaskID. A successful call of ChainTask() does not return to the calling context.</p><p xmlns="">Internal resources held by the calling task are released automatically.</p><p xmlns="">Standard or linked resources held by the calling task are also released automatically and this is reported as an error condition in extended status.</p><p xmlns="">A task can chain itself without affecting the queued activation count.</p><p xmlns="">The ChainTask() call always causes re-scheduling. However, note that TaskID may not run immediately - there may be higher priority tasks in the ready queue that will run in preference, for example tasks with a higher priority that share an internal resource with TaskID.</p><p xmlns="">If the 'Fast Terminate' is enabled in Optimizations for RTA-OS then ChainTask() must only be called from the task entry function and the return status should not be checked (ErrorHook, when configured, will be called if there is an error). This optimization saves memory and execution time.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  ChainTask(YourTask);
  /* Any code here will not execute if the call is successful */
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareTask">DeclareTask</a><br /><a href="#ActivateTask">ActivateTask</a><br /><a href="#TerminateTask">TerminateTask</a><br /><a href="#GetTaskState">GetTaskState</a><br /><a href="#GetTaskID">GetTaskID</a><br /></p><h2 xmlns=""><a name="CheckISRMemoryAccess">CheckISRMemoryAccess</a></h2><p xmlns="">Check if a memory region is read/write/execute/stack accessible by a specified ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">AccessType CheckISRMemoryAccess(ISRType ISRID, MemoryStartAddressType Address, MemorySizeType Size)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>The ISR for which the memory access is being checked.</td></tr><tr><td class="CodeBodyText">Address</td><td class="CodeBodyText">MemoryStartAddressType</td><td>in</td><td>A pointer to the start address of the memory area (the base).</td></tr><tr><td class="CodeBodyText">Size</td><td class="CodeBodyText">MemorySizeType</td><td>in</td><td>The size of the memory area in bytes (the bound).</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type AccessType</p><h4 xmlns="">Description</h4><p xmlns="">If ISRID represents a valid ISR, then CheckISRMemoryAccess() determines whether the inclusive range of memory addresses from Address to (Address+Size) is:</p><p xmlns="">- readable by ISRID</p><p xmlns="">- writeable by ISRID</p><p xmlns="">- executable by ISRID</p><p xmlns="">- represents stack space</p><p xmlns="">If a memory access condition is not valid for the whole specified memory area, then CheckISRMemoryAccess() reports no access for the type. That is, if any address in the range is not writeable, CheckTaskMemoryAccess() reports the range is not writeable.</p><p xmlns="">A call to this service results in the OS calling Os_Cbk_CheckMemoryAccess().</p><p xmlns="">The result of the call is encoded in an AccessType that can be decoded using the OSMEMORY_IS_* macros.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ISR(MyISR){
  if (OSMEMORY_IS_WRITEABLE(CheckISRMemoryAccess(MyISR, &amp;datum, sizeof(datum)))) {
    datum = ...
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CheckTaskMemoryAccess">CheckTaskMemoryAccess</a><br /><a href="#Os_Cbk_CheckMemoryAccess">Os_Cbk_CheckMemoryAccess</a><br /></p><h2 xmlns=""><a name="CheckObjectAccess">CheckObjectAccess</a></h2><p xmlns="">Determine whether the OS-Application can access an OS Object.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">ObjectAccessType CheckObjectAccess(ApplicationType ApplID, ObjectTypeType ObjectType, Os_AnyType Object)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ApplID</td><td class="CodeBodyText">ApplicationType</td><td>in</td><td>The OS-Application identifier for which access is to be checked.</td></tr><tr><td class="CodeBodyText">ObjectType</td><td class="CodeBodyText">ObjectTypeType</td><td>in</td><td>The type of object (OBJECT_TASK, OBJECT_ISR, OBJECT_ALARM, OBJECT_RESOURCE, OBJECT_COUNTER or OBJECT_SCHEDULETABLE).</td></tr><tr><td class="CodeBodyText">Object</td><td class="CodeBodyText">Os_AnyType</td><td>in</td><td>The object identifier for which access is to be checked.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type ObjectAccessType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">NO_ACCESS</td><td>all</td><td>The OS-Application does not have access to the object, or it is an invalid Object and/or ObjectType</td></tr><tr><td class="CodeBodyText">ACCESS</td><td>all</td><td>The OS-Application has access to the object</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The call returns ACCESS only if AppID can access the specified OS Object. NO_ACCESS is returned otherwise.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">if (CheckObjectAccess(GetApplicationID(), OBJECT_TASK, Task1) == ACCESS) {
  ActivateTask(Task1);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CheckObjectOwnership">CheckObjectOwnership</a><br /></p><h2 xmlns=""><a name="CheckObjectOwnership">CheckObjectOwnership</a></h2><p xmlns="">Get the OS-Application that owns the Object.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">ApplicationType CheckObjectOwnership(ObjectTypeType ObjectType, Os_AnyType Object)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ObjectType</td><td class="CodeBodyText">ObjectTypeType</td><td>in</td><td>The type of object (OBJECT_TASK, OBJECT_ISR, OBJECT_ALARM, OBJECT_RESOURCE, OBJECT_COUNTER or OBJECT_SCHEDULETABLE).</td></tr><tr><td class="CodeBodyText">Object</td><td class="CodeBodyText">Os_AnyType</td><td>in</td><td>The object whose ownership is to be checked.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type ApplicationType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">INVALID_OSAPPLICATION</td><td>all</td><td>Invalid Object and/or ObjectType</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The call returns the identifier of the OS-Application that owns the Object, or INVALID_OSAPPLICATION if the ObjectType and Object do not match an object that is owned by an OS-Application.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ApplicationType OwningApplication = CheckObjectOwnership(OBJECT_TASK, Task1);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CheckObjectAccess">CheckObjectAccess</a><br /></p><h2 xmlns=""><a name="CheckTaskMemoryAccess">CheckTaskMemoryAccess</a></h2><p xmlns="">Check if a memory region is read/write/execute/stack accessible by a specified Task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">AccessType CheckTaskMemoryAccess(TaskType TaskID, MemoryStartAddressType Address, MemorySizeType Size)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>The task for which the memory access is being checked.</td></tr><tr><td class="CodeBodyText">Address</td><td class="CodeBodyText">MemoryStartAddressType</td><td>in</td><td>A pointer to the start address of the memory area (the base).</td></tr><tr><td class="CodeBodyText">Size</td><td class="CodeBodyText">MemorySizeType</td><td>in</td><td>The size of the memory area in bytes (the bound).</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type AccessType</p><h4 xmlns="">Description</h4><p xmlns="">If TaskID represents a valid task, then CheckTaskMemoryAccess() determines whether the inclusive range of memory addresses from Address to (Address+Size) is:</p><p xmlns="">- readable by TaskID</p><p xmlns="">- writeable by TaskID</p><p xmlns="">- executable by TaskID</p><p xmlns="">- represents stack space</p><p xmlns="">If a memory access condition is not valid for the whole specified memory area, then CheckTaskMemoryAccess() reports no access for the type. That is, if any address in the range is not writeable, CheckTaskMemoryAccess() reports the range is not writeable.</p><p xmlns="">A call to this service results in the OS calling Os_Cbk_CheckMemoryAccess().</p><p xmlns="">The result of the call is encoded in an AccessType that can be decoded using the OSMEMORY_IS_* macros.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  if (OSMEMORY_IS_WRITEABLE(CheckTaskMemoryAccess(MyTask, &amp;datum, sizeof(datum)))) {
    datum = ...
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CheckISRMemoryAccess">CheckISRMemoryAccess</a><br /><a href="#Os_Cbk_CheckMemoryAccess">Os_Cbk_CheckMemoryAccess</a><br /><a href="#OSMEMORY_IS_READABLE">OSMEMORY_IS_READABLE</a><br /><a href="#OSMEMORY_IS_WRITEABLE">OSMEMORY_IS_WRITEABLE</a><br /><a href="#OSMEMORY_IS_EXECUTABLE">OSMEMORY_IS_EXECUTABLE</a><br /><a href="#OSMEMORY_IS_STACKSPACE">OSMEMORY_IS_STACKSPACE</a><br /><a href="#Os_Cbk_SetMemoryAccess">Os_Cbk_SetMemoryAccess</a><br /></p><h2 xmlns=""><a name="ClearEvent">ClearEvent</a></h2><p xmlns="">Clear one (or more) events from the task's event mask.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType ClearEvent(EventMaskType Mask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Mask</td><td class="CodeBodyText">EventMaskType</td><td>in</td><td>The event(s) to be cleared.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>Not called from an extended task.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from interrupt level.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The events of the extended task calling ClearEvent are cleared according to the event mask Mask.</p><p xmlns="">Any events that are not set in the event mask remain unchanged.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyExtendedTask){
  EventMaskType WhatHappened;
  while (WaitEvent(Event1 | Event2 | Event3) == E_OK ) {
    GetEvent(MyExtendedTask, &amp;WhatHappened);
    if (WhatHappened &amp; Event1) {
      ClearEvent(Event1);
      /* Take action on Event1 */
      ...
    } else if (WhatHappened &amp; (Event2 | Event3) {
      ClearEvent(Event2 | Event3);
      /* Take action on Event2 or Event3 */
      ...
    }
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareEvent">DeclareEvent</a><br /><a href="#GetEvent">GetEvent</a><br /><a href="#SetEvent">SetEvent</a><br /><a href="#WaitEvent">WaitEvent</a><br /></p><h2 xmlns=""><a name="ControlIdle">ControlIdle</a></h2><p xmlns="">Sets the idle mode for a core.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType ControlIdle(CoreIdType CoreID, IdleModeType IdleMode)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CoreID</td><td class="CodeBodyText">CoreIdType</td><td>in</td><td>The core ID.</td></tr><tr><td class="CodeBodyText">IdleMode</td><td class="CodeBodyText">IdleModeType</td><td>in</td><td>The mode to set.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>Core is not valid.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call sets the idle mode for a core. The value that has been set for the currently running core can be read using the OS_CURRENT_IDLEMODE() macro. Note that this API was added for AUTOSAR version 4.1.x, but RTA-OS allows it to be used in earlier version too.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">/* Set user-defined value */
ControlIdle(OS_CORE_ID_MASTER, 3);
/* Set AUTOSAR-defined value */
ControlIdle(OS_CORE_ID_1, IDLE_NO_HALT);

/* Read mode for this core */
idle_mode = OS_CURRENT_IDLEMODE();

</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr /></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#OS_CURRENT_IDLEMODE">OS_CURRENT_IDLEMODE</a><br /></p><h2 xmlns=""><a name="DisableAllInterrupts">DisableAllInterrupts</a></h2><p xmlns="">Disables (masks) all interrupts for which the hardware supports disabling.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void DisableAllInterrupts(void)</p><h4 xmlns="">Description</h4><p xmlns="">This call is intended to start a (short) critical section of the code. This critical section must be finished by calling EnableAllInterrupts(). No API calls are allowed within the critical section.</p><p xmlns="">The call does not support nesting. If nesting is needed for critical sections, e.g. for libraries, then SuspendAllInterrupts()/ResumeAllInterrupts() should be used.</p><p xmlns="">In a multicore environment, this call only affects the interrupts on the core that it is called from.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  DisableAllInterrupts();
    /* Critical section */
    /* No RTA-OS API calls allowed */
  EnableAllInterrupts();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#EnableAllInterrupts">EnableAllInterrupts</a><br /><a href="#ResumeAllInterrupts">ResumeAllInterrupts</a><br /><a href="#ResumeOSInterrupts">ResumeOSInterrupts</a><br /><a href="#SuspendAllInterrupts">SuspendAllInterrupts</a><br /><a href="#SuspendOSInterrupts">SuspendOSInterrupts</a><br /></p><h2 xmlns=""><a name="EnableAllInterrupts">EnableAllInterrupts</a></h2><p xmlns="">Enables (unmasks) all interrupts.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void EnableAllInterrupts(void)</p><h4 xmlns="">Description</h4><p xmlns="">This API call marks the end of a critical section that is protected from any maskable interrupt occurring. The critical section must have been entered using the DisableAllInterrupts() call.</p><p xmlns="">This call restores the state of the interrupt mask saved by DisableAllInterrupts().</p><p xmlns="">In a multicore environment, this call only affects the interrupts on the core that it is called from.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  DisableAllInterrupts();
  /* Critical section */
  /* No RTA-OS API calls allowed */
  EnableAllInterrupts();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DisableAllInterrupts">DisableAllInterrupts</a><br /><a href="#ResumeAllInterrupts">ResumeAllInterrupts</a><br /><a href="#ResumeOSInterrupts">ResumeOSInterrupts</a><br /><a href="#SuspendAllInterrupts">SuspendAllInterrupts</a><br /><a href="#SuspendOSInterrupts">SuspendOSInterrupts</a><br /></p><h2 xmlns=""><a name="GetActiveApplicationMode">GetActiveApplicationMode</a></h2><p xmlns="">Get the currently active application mode.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">AppModeType GetActiveApplicationMode(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type AppModeType</p><h4 xmlns="">Description</h4><p xmlns="">The call returns the currently active application mode (i.e. the value of parameter that was passed to StartOS()). The call can be used to write application-mode dependent code.</p><p xmlns="">It will return OS_NOAPPMODE if the OS is not running.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  if (GetActiveApplicationMode() == DiagnosticsMode) {
    /* Send diagnostic message */
  }
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartOS">StartOS</a><br /></p><h2 xmlns=""><a name="GetAlarm">GetAlarm</a></h2><p xmlns="">Get the number of ticks before an alarm expires.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetAlarm(AlarmType AlarmID, TickRefType Tick)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">AlarmID</td><td class="CodeBodyText">AlarmType</td><td>in</td><td>Name of the alarm of interest.</td></tr><tr><td class="CodeBodyText">Tick</td><td class="CodeBodyText">TickRefType</td><td>out</td><td>Reference to a TickType variable.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_NOFUNC</td><td>all</td><td>AlarmID is not currently set.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>AlarmID is not a valid alarm.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>AlarmID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>Tick is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Returns the relative number of ticks from the point at which the call was made before the alarm AlarmID is due to expire.</p><p xmlns="">Note that between making this call and evaluating the out parameter Tick the task may have been preempted and the alarm may have already expired. Exercise caution when making program decisions based on the value of Tick.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  TickType  TicksToExpiry;
  ...
  GetAlarm(MyAlarm, &amp;TicksToExpiry);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CancelAlarm">CancelAlarm</a><br /><a href="#DeclareAlarm">DeclareAlarm</a><br /><a href="#GetAlarmBase">GetAlarmBase</a><br /><a href="#SetAbsAlarm">SetAbsAlarm</a><br /><a href="#SetRelAlarm">SetRelAlarm</a><br /></p><h2 xmlns=""><a name="GetAlarmBase">GetAlarmBase</a></h2><p xmlns="">Get properties of the counter associated with an alarm.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetAlarmBase(AlarmType AlarmID, AlarmBaseRefType Info)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">AlarmID</td><td class="CodeBodyText">AlarmType</td><td>in</td><td>Name of the alarm of interest.</td></tr><tr><td class="CodeBodyText">Info</td><td class="CodeBodyText">AlarmBaseRefType</td><td>out</td><td>Reference to an AlarmBaseType structure.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>AlarmID is not a valid alarm.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>AlarmID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>Info is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">GetAlarmBase() reads the alarm base characteristics. These are the static properties of the counter with which AlarmID is associated.</p><p xmlns="">The out parameter Info refers to a structure in which the information of data type AlarmBaseType gets stored.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  AlarmBaseType Info;
  TickType maxallowedvalue;
  TickType ticksperbase;
  TickType mincycle;

  GetAlarmBase(MyAlarm, &amp;Info);
  maxallowedvalue = Info.maxallowedvalue;
  ticksperbase = Info.ticksperbase;
  mincycle = Info.mincycle;
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>True</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CancelAlarm">CancelAlarm</a><br /><a href="#DeclareAlarm">DeclareAlarm</a><br /><a href="#GetAlarm">GetAlarm</a><br /><a href="#SetAbsAlarm">SetAbsAlarm</a><br /><a href="#SetRelAlarm">SetRelAlarm</a><br /></p><h2 xmlns=""><a name="GetApplicationID">GetApplicationID</a></h2><p xmlns="">Get the identifier of the currently running OS-Application.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">ApplicationType GetApplicationID(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type ApplicationType</p><h4 xmlns="">Description</h4><p xmlns="">The call returns the currently running OS-Application. This is the OS-Application that owns the currently running task or Category 2 ISR.</p><p xmlns="">The call will return INVALID_OSAPPLICATION if no OS-Application is active.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">if (GetApplicationID() == App1) {
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetTaskID">GetTaskID</a><br /><a href="#GetISRID">GetISRID</a><br /></p><h2 xmlns=""><a name="GetApplicationState">GetApplicationState</a></h2><p xmlns="">Get the state of the specified OS-Application.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetApplicationState(ApplicationType Application, ApplicationStateRefType Value)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Application</td><td class="CodeBodyText">ApplicationType</td><td>in</td><td>The OS-Application from which the state is requested.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">ApplicationStateRefType</td><td>out</td><td>The current state of the application.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>all</td><td>Application is not a valid OS-Application.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The call returns the state of the specified OS-Application. The state is set to APPLICATION_ACCESSIBLE during StartOS.</p><p xmlns="">It gets changed changed to APPLICATION_TERMINATED if the application gets terminated without being restarted.</p><p xmlns="">It can be APPLICATION_RESTARTING following a ProtectionHook or TerminateApplication with RESTART.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ApplicationStateType appState;
if (GetApplicationState(App1, &amp;appState) == E_OK) {
  switch (appState) {
    case APPLICATION_ACCESSIBLE:
      ...
    case APPLICATION_RESTARTING:
      ...
    case APPLICATION_TERMINATED:
      ...
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TerminateApplication">TerminateApplication</a><br /><a href="#AllowAccess">AllowAccess</a><br /></p><h2 xmlns=""><a name="GetCoreID">GetCoreID</a></h2><p xmlns="">GetCoreID returns the unique logical CoreID of the core on which the function is called.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">CoreIdType GetCoreID(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type CoreIdType</p><h4 xmlns="">Description</h4><p xmlns="">GetCoreID returns the unique logical CoreID of the core on which the function is called.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">    CoreIdType core_id = GetCoreID();
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartCore">StartCore</a><br /><a href="#StartNonAutosarCore">StartNonAutosarCore</a><br /></p><h2 xmlns=""><a name="GetCounterValue">GetCounterValue</a></h2><p xmlns="">Get the value of a counter.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetCounterValue(CounterType CounterID, TickRefType Value)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CounterID</td><td class="CodeBodyText">CounterType</td><td>in</td><td>The counter to read.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">TickRefType</td><td>out</td><td>The current value of the counter.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>CounterID is not a valid counter.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>CounterID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>Value is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Returns the current value of the specified counter CounterID in Value.</p><p xmlns="">The Operating System ensures that the lowest value is zero and consecutive reads return an increasing count value until the counter wraps.</p><p xmlns="">If CounterID is a hardware counter, then the user callback Os_Cbk_Now_&lt;CounterID&gt; will be called.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Task(MyTask){
  TickType Value;
  ...
  GetCounterValue(MyCounter,&amp;Value);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#IncrementCounter">IncrementCounter</a><br /><a href="#GetElapsedValue">GetElapsedValue</a><br /><a href="#GetElapsedCounterValue">GetElapsedCounterValue</a><br /><a href="#Os_AdvanceCounter">Os_AdvanceCounter</a><br /><a href="#Os_AdvanceCounter_&lt;CounterID&gt;">Os_AdvanceCounter_&lt;CounterID&gt;</a><br /><a href="#Os_IncrementCounter_&lt;CounterID&gt;">Os_IncrementCounter_&lt;CounterID&gt;</a><br /></p><h2 xmlns=""><a name="GetElapsedCounterValue">GetElapsedCounterValue</a></h2><p xmlns="">Returns the number of elapsed ticks since the given &lt;Value&gt; value via &lt;ElapsedValue&gt;.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetElapsedCounterValue(CounterType CounterID, TickRefType Value, TickRefType ElapsedValue)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CounterID</td><td class="CodeBodyText">CounterType</td><td>in</td><td>Name of the counter.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">TickRefType</td><td>in</td><td>A previous counter value.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">TickRefType</td><td>out</td><td>The current value of the counter.</td></tr><tr><td class="CodeBodyText">ElapsedValue</td><td class="CodeBodyText">TickRefType</td><td>out</td><td>The difference from the in Value.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>CounterID is not a valid counter.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>CounterID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>Value or ElapsedValue is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Returns the number of ticks that have elapsed on the counter current since Value.</p><p xmlns="">Value is updated with the current value of the counter when the call returns.</p><p xmlns="">Note that the call can only return a value up to maxallowedvalue ticks in length.</p><p xmlns="">If the counter has ticked more than maxallowedvalue ticks since Value then ElapsedValue will be Value modulo maxallowedvalue.</p><p xmlns="">Note that this API was renamed to GetElapsedValue for AUTOSAR version 4. For compatibility reasons, RTA-OS allows you to use either name in AUTOSAR version 4 applications. Macros are used to map to the actual implementation name.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Task(MyTask){
  TickType Value;
  TickType ElapsedValue;
  ...
  GetCounterValue(MyCounterID,&amp;Value);
  /* Value =&gt; current count */
  ...
  GetElapsedCounterValue(MyCounter,&amp;Value,&amp;ElapsedValue);
  /* ElapsedValue =&gt; ticks since original Value, Value =&gt; current count */
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetCounterValue">GetCounterValue</a><br /><a href="#GetElapsedValue">GetElapsedValue</a><br /></p><h2 xmlns=""><a name="GetElapsedValue">GetElapsedValue</a></h2><p xmlns="">Returns the number of elapsed ticks since the given &lt;Value&gt; value via &lt;ElapsedValue&gt;.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetElapsedValue(CounterType CounterID, TickRefType Value, TickRefType ElapsedValue)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CounterID</td><td class="CodeBodyText">CounterType</td><td>in</td><td>Name of the counter.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">TickRefType</td><td>in</td><td>A previous counter value.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">TickRefType</td><td>out</td><td>The current value of the counter.</td></tr><tr><td class="CodeBodyText">ElapsedValue</td><td class="CodeBodyText">TickRefType</td><td>out</td><td>The difference from the in Value.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>CounterID is not a valid counter.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>CounterID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>Value or ElapsedValue is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Returns the number of ticks that have elapsed on the counter current since Value.</p><p xmlns="">Value is updated with the current value of the counter when the call returns.</p><p xmlns="">Note that the call can only return a value up to maxallowedvalue ticks in length.</p><p xmlns="">If the counter has ticked more than maxallowedvalue ticks since Value then ElapsedValue will be Value modulo maxallowedvalue.</p><p xmlns="">Note that this API was called GetElapsedCounterValue for AUTOSAR version 3. For compatibility reasons, RTA-OS allows you to use either name in AUTOSAR version 4 applications. Macros are used to map to the actual implementation name.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Task(MyTask){
  TickType Value;
  TickType ElapsedValue;
  ...
  GetCounterValue(MyCounterID,&amp;Value);
  /* Value =&gt; current count */
  ...
  GetElapsedValue(MyCounter,&amp;Value,&amp;ElapsedValue);
  /* ElapsedValue =&gt; ticks since original Value, Value =&gt; current count */
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetCounterValue">GetCounterValue</a><br /><a href="#GetElapsedCounterValue">GetElapsedCounterValue</a><br /></p><h2 xmlns=""><a name="GetEvent">GetEvent</a></h2><p xmlns="">Get the state of all event bits for a task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetEvent(TaskType TaskID, EventMaskRefType Event)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Name of the Task of interest.</td></tr><tr><td class="CodeBodyText">Event</td><td class="CodeBodyText">EventMaskRefType</td><td>out</td><td>Reference to an event mask.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>TaskID is not a valid task.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not an extended task.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>TaskID is in the suspended state.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>Event is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call returns all events that are set for the extended task TaskID.</p><p xmlns="">Note that all set events are returned, regardless of which events the task may have been waiting for.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyExtendedTask){
  EventMaskType WhatHappened;
  while (WaitEvent(Event1 | Event2 | Event3) == E_OK ) {
    GetEvent(MyExtendedTask, &amp;WhatHappened);
    if(WhatHappened &amp; Event1) {
      ClearEvent(Event1);
      /* Take action on Event1 */
      ...
    } else if (WhatHappened &amp; (Event2 | Event3) {
      ClearEvent(Event2 | Event3);
      /* Take action on Event2 or Event3 */
      ...
    }
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ClearEvent">ClearEvent</a><br /><a href="#DeclareEvent">DeclareEvent</a><br /><a href="#SetEvent">SetEvent</a><br /><a href="#WaitEvent">WaitEvent</a><br /></p><h2 xmlns=""><a name="GetISRID">GetISRID</a></h2><p xmlns="">Get the identifier of the currently running ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">ISRType GetISRID(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type ISRType</p><h4 xmlns="">Description</h4><p xmlns="">The call returns the ID of the currently running Category2 ISR or INVALID_ISR if no ISR is running.</p><p xmlns="">The main use of the call is to identify which ISR is running in hook functions.</p><p xmlns="">In a multicore environment, this call only looks at the core that it is called from.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) ErrorHook(StatusType Error){
  ISRType ISRInError;
  TaskType TaskInError;

  ISRInError = GetISRID();
  if (ISRInError != INVALID_ISR) {
    /* Must be an ISR in error */
  } else {
    /* Maybe it's a task in error */
    GetTaskID(&amp;TaskInError);
    ...
  }
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>True</td><td>False</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetTaskID">GetTaskID</a><br /><a href="#OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a><br /></p><h2 xmlns=""><a name="GetNumberOfActivatedCores">GetNumberOfActivatedCores</a></h2><p xmlns="">Get the number of cores activated by the StartCore function.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">uint32 GetNumberOfActivatedCores(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type uint32</p><h4 xmlns="">Description</h4><p xmlns="">GetNumberOfActivatedCores() returns the number of cores that have been activated using StartCore(). These must be cores that are configured to run the OS.</p><p xmlns="">RTA-OS allows GetNumberOfActivatedCores() to be called before StartOS(), as this is the only time that its return value can be less than the number configured.</p><p xmlns="">This API is only provided with multicore project configurations.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">OS_MAIN(){
  StatusType status;
  CoreIdType core_id = GetCoreID()
  ...
  if (core_id == OS_CORE_ID_MASTER) {
    while (GetNumberOfActivatedCores() &lt; OS_NUM_CORES) {
      StartCore(++core_id, &amp;status);
    }
  }
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartCore">StartCore</a><br /><a href="#StartOS">StartOS</a><br /></p><h2 xmlns=""><a name="GetResource">GetResource</a></h2><p xmlns="">Get (lock) a resource to enter a critical section.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetResource(ResourceType ResID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ResID</td><td class="CodeBodyText">ResourceType</td><td>in</td><td>The resource to get.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ResID is not a valid resource.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ResID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>Attempt to get a resource which is (a) already locked by another task or ISR, or (b) the priority of the calling task or interrupt routine is higher than the actual priority of ResID.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call enters a named critical section (the resource), protecting the code inside the critical section against concurrent access by any other tasks and ISRs that are configured to be able to access the resource.</p><p xmlns="">A critical section must always be left using ReleaseResource().</p><p xmlns="">Nested resource occupation is allowed, but only where the inner critical sections are completely executed within the surrounding critical section as shown in the example.</p><p xmlns="">Nested occupation of the same resource is not allowed, although you can use linked resources to achieve this effect.</p><p xmlns="">Calls that put the running task into any other state must not be used in critical sections. (e.g. as ChainTask(), Schedule(), TerminateTask() or WaitEvent().)</p><p xmlns="">A system where Category 2 ISRs can lock a resource has slightly higher run-time overheads than one where only Tasks lock resources.</p><p xmlns="">Resources can not be configured to work across different cores.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  GetResource(Outer);
    /* Outer Critical Section */
    ...
    GetResource(Inner);
      /* Inner Critical Section */
    ReleaseResource(Inner);
    ...
  ReleaseResource(Outer);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareResource">DeclareResource</a><br /><a href="#ReleaseResource">ReleaseResource</a><br /></p><h2 xmlns=""><a name="GetScheduleTableStatus">GetScheduleTableStatus</a></h2><p xmlns="">Get the status of a schedule table.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetScheduleTableStatus(ScheduleTableType ScheduleTableID, ScheduleTableStatusRefType ScheduleStatus)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ScheduleTableID</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Schedule table for which the status is required.</td></tr><tr><td class="CodeBodyText">ScheduleStatus</td><td class="CodeBodyText">ScheduleTableStatusRefType</td><td>out</td><td>Reference to the schedule table status.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ScheduleTableID is not a valid ScheduleTable.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ScheduleTableID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>ScheduleStatus is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call returns the status of the ScheduleTableID.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ScheduleTableStatusType Status;

  GetScheduleTableStatus(MyScheduleTable, &amp;Status);
  if (Status != SCHEDULETABLE_RUNNING){
      StartScheduleTableAbs(MyScheduleTable,42);
  }
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#NextScheduleTable">NextScheduleTable</a><br /><a href="#StartScheduleTableAbs">StartScheduleTableAbs</a><br /><a href="#StartScheduleTableRel">StartScheduleTableRel</a><br /><a href="#StartScheduleTableSynchron">StartScheduleTableSynchron</a><br /><a href="#StopScheduleTable">StopScheduleTable</a><br /><a href="#SyncScheduleTable">SyncScheduleTable</a><br /><a href="#Os_SyncScheduleTableRel">Os_SyncScheduleTableRel</a><br /><a href="#SetScheduleTableAsync">SetScheduleTableAsync</a><br /></p><h2 xmlns=""><a name="GetSpinlock">GetSpinlock</a></h2><p xmlns="">GetSpinlock tries to occupy a spin-lock variable.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">GetSpinlock(SpinlockIdType SpinlockId)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">SpinlockId</td><td class="CodeBodyText">SpinlockIdType</td><td>in</td><td>The Spinlock to occupy.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>SpinlockId does not refer to a valid Spinlock.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>The Spinlock is already occupied by the calling TASK or ISR (pre AUTOSAR version 4.0.3).</td></tr><tr><td class="CodeBodyText">E_OS_INTERFERENCE_DEADLOCK</td><td>extended</td><td>The Spinlock is already occupied by a TASK/ISR on the same core. This would cause a deadlock.</td></tr><tr><td class="CodeBodyText">E_OS_NESTING_DEADLOCK</td><td>extended</td><td>Attempt to occupy the Spinlock while already holding a different Spinlock in a way that may cause a deadlock.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>SpinlockId is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">GetSpinlock is used to give one core exclusive access to a shared resource - typically writeable data.</p><p xmlns="">Only one core is able to occupy a specific spinlock at a time. A request to occupy a spinlock occupied by a different core results in the caller busy-waiting until the other core releases the lock.</p><p xmlns="">ReleaseSpinlock has to be used to release the lock.</p><p xmlns="">Note that higher priority Tasks or ISRs can preempt code that has a spinlock. Therefore code on other cores may have to wait for the preempted code to complete before they can obtain the lock. This can have bad effects on system timing, so you may also choose to use resources or SuspendOSInterrupts/ResumeOSInterrupts around spinlocks in order to prevent such behavior.</p><p xmlns="">Further, if preempting code tries to occupy a spinlock that is already occupied by a lower priority Task/ISR then the OS will not perform the operation and will raise an error, because otherwise the second lock could never succeed and would permanently busy-wait.</p><p xmlns="">Care has to be taken when there is nested access to spinlocks. You must configure the order in which nested spinlocks will be locked so that the OS can enforce this and prevent deadlock.</p><p xmlns="">GetSpinlock only returns when the lock is successfully taken or an error has occurred.</p><p xmlns="">When the spinlock has a lock method with LOCK_ALL_INTERRUPTS semantics, this API will exit with a call to SuspendAllInterrupts() in effect and the usage restrictions that apply to SuspendAllInterrupts() also apply to GetSpinlock().</p><p xmlns="">When the spinlock has a lock method with LOCK_CAT2_INTERRUPTS semantics, this API will exit with a call to SuspendOSInterrupts() in effect and the usage restrictions that apply to SuspendOSInterrupts() also apply to GetSpinlock().</p><p xmlns="">When the spinlock has a lock method with LOCK_WITH_RES_SCHEDULER semantics, this API will exit with a call to GetResource(RES_SCHEDULER) in effect and the usage restrictions that apply to GetResource(RES_SCHEDULER) also apply to GetSpinlock().</p><p xmlns="">When the spinlock has a lock method with NESTABLE semantics, this API will indicate a successful lock if the lock is already held by a TASK or ISR on the same core. The lock is only released by the original locker, and only then when it has made the same number of Release calls as Get calls.</p><p xmlns="">When the spinlock has a lock method with COMMONABLE semantics, it can be followed by any spinlock that has no successors of its own, and is not also COMMONABLE. It can follow a normal lock without being on its list of successors.</p><p xmlns="">Note that the OS configuration option 'Force spinlock error checks' can be used to cause the error checks to be done in standard as well as extended status builds.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  GetSpinlock(Spinlock1);
  ...
  ReleaseSpinlock(Spinlock1);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TryToGetSpinlock">TryToGetSpinlock</a><br /><a href="#ReleaseSpinlock">ReleaseSpinlock</a><br /><a href="#UncheckedGetSpinlock">UncheckedGetSpinlock</a><br /><a href="#UncheckedTryToGetSpinlock">UncheckedTryToGetSpinlock</a><br /><a href="#UncheckedReleaseSpinlock">UncheckedReleaseSpinlock</a><br /><a href="#SuspendAllInterrupts">SuspendAllInterrupts</a><br /><a href="#SuspendOSInterrupts">SuspendOSInterrupts</a><br /><a href="#GetResource">GetResource</a><br /></p><h2 xmlns=""><a name="GetSpinlockInfo">GetSpinlockInfo</a></h2><p xmlns="">Get run-time statistics about a spinlock.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetSpinlockInfo(SpinlockIdType SpinlockId, Os_SpinlockInfoRefType Info)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">SpinlockId</td><td class="CodeBodyText">SpinlockIdType</td><td>in</td><td>The Spinlock</td></tr><tr><td class="CodeBodyText">Info</td><td class="CodeBodyText">Os_SpinlockInfo</td><td>out</td><td>Reference to the Spinlock statistics.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>SpinlockId does not refer to a valid Spinlock.</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>Info is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">GetSpinlockInfo is an optional API that is only available when there are spinlocks in the application and the OS option 'Provide spinlock statistics' is set to true.</p><p xmlns="">It is used to retrieve run-time locking statistics for the specified SpinlockId.</p><p xmlns="">When the spinlock is locked at the time of the call:</p><p xmlns="">- The CurrentLockTime field contains the number of ticks that the lock has been locked for. If it is not currently locked, the value will be zero.</p><p xmlns="">- The CurrentLocker field contains the TaskType or ISRType TASK/ISR that took the lock. If it is not currently locked, the value will be INVALID_TASK.</p><p xmlns="">- The CurrentLockingCore field contains the number of the core that has the lock. If it is not locked, the value will be OS_NUM_CORES.</p><p xmlns="">The field LockAttempts contains the number of Try/Get attempts made for the spinlock (per core).</p><p xmlns="">The field LockSucceeds contains the number of Try/Get attempts that resulted in the lock being taken (per core).</p><p xmlns="">The field LockFails contains the number of Try attempts that failed, plus the number of retries on a Get (per core).</p><p xmlns="">The field MaxLockTime shows for each core the max number of ticks that the spinlock was locked for. MaxLockTimeLocker contains the TaskType or ISRType TASK/ISR that took the lock</p><p xmlns="">The field MaxSpinTime shows for each core the max number of ticks that it took to get the spinlock. This time is typically the time spent within GetSpinlock waiting for the other core to release the lock. MaxSpinTimeLocker contains the TaskType or ISRType TASK/ISR that wanted the lock</p><p xmlns="">Note that the OS configuration option 'Force spinlock error checks' can be used to cause the error checks to be done in standard as well as extended status builds.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  Os_SpinlockInfo Info;
  GetSpinlockInfo(Spinlock1, &amp;Info);
  if ((TaskType)Info.CurrentLocker == MyTask) {
    ...
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SpinlockInfo">Os_SpinlockInfo</a><br /><a href="#ResetSpinlockInfo">ResetSpinlockInfo</a><br /><a href="#GetSpinlock">GetSpinlock</a><br /><a href="#TryToGetSpinlock">TryToGetSpinlock</a><br /><a href="#ReleaseSpinlock">ReleaseSpinlock</a><br /></p><h2 xmlns=""><a name="GetTaskID">GetTaskID</a></h2><p xmlns="">Identify the currently running task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetTaskID(TaskRefType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskRefType</td><td>out</td><td>A reference to the running task.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>TaskID is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The call returns a reference to the currently running Task.</p><p xmlns="">If the call is made from a task, then it will return the identifier of that task.</p><p xmlns="">If the call is made from an ISR, then it will return the identifier of the task that was running when the interrupt occurred.</p><p xmlns="">The main use of the call is to identify which task is running in hook functions.</p><p xmlns="">In a multicore environment, this call only looks at the core that it is called from.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) ErrorHook(StatusType Error){
  TaskType TaskInError;
  GetTaskID(&amp;TaskInError);
  if (TaskInError == INVALID_TASK) {
    /* Must be an ISR in error */
  } else if (TaskInError == MyTask) {
    /* Do something */
  }
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>True</td><td>False</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareTask">DeclareTask</a><br /><a href="#TerminateTask">TerminateTask</a><br /><a href="#GetTaskState">GetTaskState</a><br /><a href="#GetTaskID">GetTaskID</a><br /><a href="#GetISRID">GetISRID</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /></p><h2 xmlns=""><a name="GetTaskState">GetTaskState</a></h2><p xmlns="">Get the current state (suspended, ready, running, waiting) of a specified task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType GetTaskState(TaskType TaskID, TaskStateRefType State)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>The task of interest.</td></tr><tr><td class="CodeBodyText">State</td><td class="CodeBodyText">TaskStateRefType</td><td>out</td><td>Reference to the task state.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>TaskID is not a valid TaskType.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>State is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The call returns the state of the task at the point GetTaskState() was called.</p><p xmlns="">The main use of this API is to check that an extended task is not in the suspended state before setting an event.</p><p xmlns="">A task that is preempted by an ISR remains in the running state.</p><p xmlns="">Note that when called from a preemptive task or from an ISR the state may already be incorrect at the time it is evaluated because preemption may have occurred between the call returning and the result being evaluated.</p><p xmlns="">In a multicore environment, the state of all tasks can be examined - even where the task is assigned to a different core.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  TaskStateType CurrentState;
  ...
  GetTaskState(YourTask, &amp;CurrentState);
  switch (CurrrentState) {
    case SUSPENDED:
      /* YourTask is suspended */
    case READY:
      /* YourTask is ready to run */
    case WAITING:
      /* YourTask is waiting (for an event) */
    case RUNNING:
      /* YourTask is running. Not possible as MyTask must be running to make the call */
  }
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareTask">DeclareTask</a><br /><a href="#TerminateTask">TerminateTask</a><br /><a href="#GetTaskState">GetTaskState</a><br /><a href="#GetTaskID">GetTaskID</a><br /></p><h2 xmlns=""><a name="IncrementCounter">IncrementCounter</a></h2><p xmlns="">Increment a software counter.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType IncrementCounter(CounterType CounterID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CounterID</td><td class="CodeBodyText">CounterType</td><td>in</td><td>Name of the counter to increment.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>CounterID is not a software counter.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>CounterID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_CORE</td><td>extended</td><td>Called from a core other than the core that owns CounterID</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call increments (adds one to) CounterID. CounterID must be a software counter.</p><p xmlns="">If any alarms on the counter are triggered by the increment then the alarm actions will be executed before the call returns.</p><p xmlns="">Note that if an error occurs during the expiry of an alarm (for example, a task activation raises E_OS_LIMIT), the error hook(s) are called for each error that occurs.</p><p xmlns="">However, the IncrementCounter() service itself will still return E_OK.</p><p xmlns="">The API call may cause re-scheduling to take place.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ISR(MillisecondTimerInterrupt){
  ...
  IncrementCounter(MillisecondCounter);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_AdvanceCounter">Os_AdvanceCounter</a><br /><a href="#Os_AdvanceCounter_&lt;CounterID&gt;">Os_AdvanceCounter_&lt;CounterID&gt;</a><br /><a href="#Os_IncrementCounter_&lt;CounterID&gt;">Os_IncrementCounter_&lt;CounterID&gt;</a><br /></p><h2 xmlns=""><a name="NextScheduleTable">NextScheduleTable</a></h2><p xmlns="">Change the execution pattern from one ScheduleTable to another.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType NextScheduleTable(ScheduleTableType ScheduleTableID_From, ScheduleTableType ScheduleTableID_To)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ScheduleTableID_From</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Schedule table to switch from.</td></tr><tr><td class="CodeBodyText">ScheduleTableID_To</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Schedule table to switch into.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_NOFUNC</td><td>all</td><td>ScheduleTableID_From is not started.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ScheduleTableID_From or ScheduleTableID_To is not a valid ScheduleTable.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ScheduleTableID_From and ScheduleTableID_To have different Synchronization strategies.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ScheduleTableID_From or ScheduleTableID_To is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>ScheduleTableID_To is already started or nexted.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call starts the processing of schedule table of ScheduleTableID_To ScheduleTableID_From.FinalDelay ticks after the Final Expiry Point on ScheduleTableID_From has been processed.</p><p xmlns="">The Initial Expiry Point on ScheduleTableID_To is processed ScheduleTable_To.InitialOffset ticks after the start of ScheduleTableID_To.</p><p xmlns="">If ScheduleTableID_From already has a 'nexted' schedule table then ScheduleTableID_To replaces the previous 'nexted' schedule table and that previous table is set to state SCHEDULETABLE_STOPPED.</p><p xmlns="">If either schedule table is not valid or they are driven by different counters then the states of both tables remain unchanged.</p><p xmlns="">The synchronization strategy of ScheduleTableID_To comes into effect when the OS processes the first expiry point of ScheduleTableID_To.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
    /* Stop MyScheduleTable at the end and start YourScheduleTable */
    NextScheduleTableAbs(MyScheduleTable, YourScheduleTable);
    ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#GetScheduleTableStatus">GetScheduleTableStatus</a><br /><a href="#StartScheduleTableAbs">StartScheduleTableAbs</a><br /><a href="#StartScheduleTableRel">StartScheduleTableRel</a><br /><a href="#StartScheduleTableSynchron">StartScheduleTableSynchron</a><br /><a href="#StopScheduleTable">StopScheduleTable</a><br /><a href="#SyncScheduleTable">SyncScheduleTable</a><br /><a href="#Os_SyncScheduleTableRel">Os_SyncScheduleTableRel</a><br /><a href="#SetScheduleTableAsync">SetScheduleTableAsync</a><br /></p><h2 xmlns=""><a name="Os_AddDelayedTasks">Os_AddDelayedTasks</a></h2><p xmlns="">Add one or more tasks to the set of tasks that are subject to delayed execution.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_AddDelayedTasks(Os_TasksetType Taskset)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Taskset</td><td class="CodeBodyText">Os_TasksetType</td><td>in</td><td>The set of tasks to be added.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>Delayed tasks cannot be changed by untrusted code</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>A task is being added that has the same priority as another task on the same core. You have to add all of the tasks that share the priority.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">When delayed task execution is configured for the project, you can tell RTA-OS to delay execution of a set of tasks. These tasks can be activated, but will not actually run until they are removed from the set.</p><p xmlns="">Os_AddDelayedTasks is used to add tasks to the existing set of delayed tasks. Adding a task multiple times is permissible but has no effect.</p><p xmlns="">Note that where tasks share priorities on a specific core, you must either add all of the tasks sharing a priority or none.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">/* Normal case - fewer than 65 tasks */
TASK(LowPrioTask){
  Os_AddDelayedTasks(TASK_MASK(Task1) | TASK_MASK(Task3));
  ... /* Tasks 1 and 3 can be activated, but will not run*/

  Os_SetDelayedTasks(OS_NO_TASKS);
  ... /* Tasks 1 and 3 can run*/
}

/* 65 tasks or more*/
TASK(LowPrioTask){
  Os_TasksetType no_tasks = OS_NO_TASKS;
  Os_TasksetType t1_and_t3 = TASK_MASK(Task1);
  OS_ADD_TASK(t1_and_t3, Task3);
  Os_AddDelayedTasks(t1_and_t3);
  ... /* Tasks 1 and 3 can be activated, but will not run*/

  Os_SetDelayedTasks(no_tasks);
  ... /* Tasks 1 and 3 can run*/
}

</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SetDelayedTasks">Os_SetDelayedTasks</a><br /><a href="#Os_RemoveDelayedTasks">Os_RemoveDelayedTasks</a><br /><a href="#OS_ADD_TASK">OS_ADD_TASK</a><br /><a href="#OS_NO_TASKS">OS_NO_TASKS</a><br /><a href="#TASK_MASK">TASK_MASK</a><br /><a href="#Os_TasksetType">Os_TasksetType</a><br /></p><h2 xmlns=""><a name="Os_AdvanceCounter">Os_AdvanceCounter</a></h2><p xmlns="">Inform the OS that a hardware counter has reached the previously programmed value.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_AdvanceCounter(CounterType CounterID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CounterID</td><td class="CodeBodyText">CounterType</td><td>in</td><td>Name of the counter that has reached a programmed value.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>CounterID is not a hardware counter.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>CounterID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>CounterID is not running.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call tells the OS that the counter value has matched the value previously set via the Os_Cbk_Set_&lt;CounterID&gt; callback.</p><p xmlns="">The OS will then process any alarm or expiry point actions that are due. It will then either set a new match value (via Os_Cbk_Set_&lt;CounterID&gt;) or cancel counter matching (via Os_Cbk_Cancel_&lt;CounterID&gt;).</p><p xmlns="">Note that it is possible for the new counter match value to be reached before leaving any interrupt that is being used to drive the counter. It is important that this occurrence is not missed because otherwise the counter will not be awoken again until a complete wrap of the underlying hardware counter value has occurred.</p><p xmlns="">On some hardware platforms no special action is needed because the interrupt will simply get reasserted when the existing instance exits.</p><p xmlns="">On other platforms, the interrupt has to be reasserted in software or, where this is not possible, the code must loop as shown in the example. In either case great care has to be taken to avoid missing matches that occur while the driver is executing.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">/* For systems where the interrupt will be re-entered automatically if the match occurs before leaving the ISR: */
ISR(SimpleCounterDriver){
  Os_AdvanceCounter(MyHWCounter);
}
/* For systems where the software can force the interrupt to get re-entered if the match occurs before leaving the ISR: */
ISR(RetriggeringCounterDriver){
  Os_CounterStatusRefType CurrentState;
  Os_AdvanceCounter(MyHWCounter);
  Os_Cbk_State_MyHWCounter(&amp;CurrentState);
  if (CurrentState.Running &amp;&amp; CurrentState.Pending) {
    /* Retrigger this interrupt */
  }
}
/* For systems where the software has to loop if the match occurs before leaving the ISR: */
ISR(LoopingCounterDriver){
  Os_CounterStatusRefType CurrentState;
  do {
    Os_AdvanceCounter(MyHWCounter);
    Os_Cbk_State_MyHWCounter(&amp;CurrentState);
  } while (CurrentState.Running &amp;&amp; CurrentState.Pending);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#IncrementCounter">IncrementCounter</a><br /><a href="#Os_AdvanceCounter_&lt;CounterID&gt;">Os_AdvanceCounter_&lt;CounterID&gt;</a><br /><a href="#Os_IncrementCounter_&lt;CounterID&gt;">Os_IncrementCounter_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_Set_&lt;CounterID&gt;">Os_Cbk_Set_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_Cancel_&lt;CounterID&gt;">Os_Cbk_Cancel_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_State_&lt;CounterID&gt;">Os_Cbk_State_&lt;CounterID&gt;</a><br /></p><h2 xmlns=""><a name="Os_AdvanceCounter_&lt;CounterID&gt;">Os_AdvanceCounter_&lt;CounterID&gt;</a></h2><p xmlns="">Inform the OS that a hardware counter has reached a programmed value.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_AdvanceCounter_CounterID(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>CounterID is not running.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call has the same behavior as Os_AdvanceCounter(CounterID) but is customized for a specific counter. This makes the call faster and more suitable for use in interrupt handlers.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">/* For systems where the interrupt will be re-entered automatically if the match occurs before leaving the ISR: */
ISR(SimpleCounterDriver){
  Os_AdvanceCounter_MyHWCounter();
}
/* For systems where the software can force the interrupt to get re-entered if the match occurs before leaving the ISR: */
ISR(RetriggeringCounterDriver){
  Os_CounterStatusRefType CurrentState;
  Os_AdvanceCounter_MyHWCounter();
  Os_Cbk_State_MyHWCounter(&amp;CurrentState);
  if (CurrentState.Running &amp;&amp; CurrentState.Pending) {
    /* Retrigger this interrupt */
  }
}
/* For systems where the software has to loop if the match occurs before leaving the ISR: */
ISR(LoopingCounterDriver){
  Os_CounterStatusRefType CurrentState;
  do {
    Os_AdvanceCounter_MyHWCounter();
    Os_Cbk_State_MyHWCounter(&amp;CurrentState);
  } while (CurrentState.Running &amp;&amp; CurrentState.Pending);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#IncrementCounter">IncrementCounter</a><br /><a href="#Os_AdvanceCounter">Os_AdvanceCounter</a><br /><a href="#Os_IncrementCounter_&lt;CounterID&gt;">Os_IncrementCounter_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_Set_&lt;CounterID&gt;">Os_Cbk_Set_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_Cancel_&lt;CounterID&gt;">Os_Cbk_Cancel_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_State_&lt;CounterID&gt;">Os_Cbk_State_&lt;CounterID&gt;</a><br /></p><h2 xmlns=""><a name="Os_CheckTraceOutput">Os_CheckTraceOutput</a></h2><p xmlns="">Checks for the presence of trace data.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_CheckTraceOutput(void)</p><h4 xmlns="">Description</h4><p xmlns="">When tracing in free-running mode, this must be called regularly by the application. It is used to detect when the trace buffer has data to upload to RTA-TRACE.</p><p xmlns="">It does not have to be called in Bursting or Triggering modes, though it is not harmful to do so.</p><p xmlns="">It causes Os_Cbk_TraceCommDataReady() to be called when there is data to send.</p><p xmlns="">This API will only check trace data for the core that calls it. If you have more than one core tracing data, each one needs to call this independently.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_CheckTraceOutput();
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_TraceCommDataReady">Os_Cbk_TraceCommDataReady</a><br /><a href="#Os_Cbk_TraceCommTxStart">Os_Cbk_TraceCommTxStart</a><br /><a href="#Os_Cbk_TraceCommTxByte">Os_Cbk_TraceCommTxByte</a><br /><a href="#Os_Cbk_TraceCommTxEnd">Os_Cbk_TraceCommTxEnd</a><br /><a href="#Os_Cbk_TraceCommTxReady">Os_Cbk_TraceCommTxReady</a><br /></p><h2 xmlns=""><a name="Os_ClearTrigger">Os_ClearTrigger</a></h2><p xmlns="">Clear all triggering conditions.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_ClearTrigger(void)</p><h4 xmlns="">Description</h4><p xmlns="">This API call clears all trigger conditions that have been set using an Os_TriggerOnXXX() API.</p><p xmlns="">Trace information will continue to be logged in the trace buffer, but no trace record will trigger the upload of the trace buffer to the host.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_ClearTrigger();
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_StartBurstingTrace">Os_StartBurstingTrace</a><br /><a href="#Os_StartFreeRunningTrace">Os_StartFreeRunningTrace</a><br /><a href="#Os_SetTriggerWindow">Os_SetTriggerWindow</a><br /><a href="#Os_SetTraceRepeat">Os_SetTraceRepeat</a><br /></p><h2 xmlns=""><a name="Os_DisableTraceCategories">Os_DisableTraceCategories</a></h2><p xmlns="">Control which tracepoints are traced.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_DisableTraceCategories(Os_TraceCategoriesType CategoriesMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CategoriesMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>Mask of the trace categories to disable.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Trace categories are used to filter whether tracepoints, task tracepoints and intervals get recorded and are typically used to control the volume of data that gets traced.</p><p xmlns="">A category can be configured at build time to be active always, never or under run-time control. Categories that are under run-time control are enabled using Os_EnableTraceCategories and disabled using Os_DisableTraceCategories.</p><p xmlns="">This call disables the specified run-time categories and therefore will inhibit the logging of all tracepoints, task tracepoints and intervals that are filtered by these categories.</p><p xmlns="">Categories not listed in the call will be left in their current state. The category filter applies to all cores in a multicore application.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_DisableTraceCategories(DebugTracePoints | DataLogTracePoints); /* Disable DebugTracePoints and DataLogTracePoints*/
Os_LogTracepoint(tpTest, DebugTracePoints); /* tpTest is not recorded: DebugTracePoints is disabled */
Os_LogTracepoint(tpTest, OS_TRACE_CATEGORY_ALWAYS); /* tpTest is recorded here */
Os_DisableTraceCategories(OS_TRACE_ALL_CATEGORIES); /* Disable all categories except for OS_TRACE_CATEGORY_ALWAYS */
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_EnableTraceCategories">Os_EnableTraceCategories</a><br /></p><h2 xmlns=""><a name="Os_DisableTraceClasses">Os_DisableTraceClasses</a></h2><p xmlns="">Control which types of objects are traced.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_DisableTraceClasses(Os_TraceClassesType ClassMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ClassMask</td><td class="CodeBodyText">Os_TraceClassesType</td><td>in</td><td>Mask of the trace classes to disable.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Trace classes are used to filter whether complete types of trace events get recorded. They are typically used to control the volume of data that gets traced.</p><p xmlns="">Trace classes can be configured at build time to be active always, never or under run-time control. Classes that are under run-time control are enabled using Os_EnableTraceClasses and disabled using Os_DisableTraceClasses.</p><p xmlns="">This call disables the specified run-time classes and therefore will inhibit the tracing of events that are filtered by these classes.</p><p xmlns="">Classes not listed in the call will be left in their current state. The class filter applies to all cores in a multicore application.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_DisableTraceClasses(OS_TRACE_TRACEPOINT_CLASS);
Os_LogTracepoint(tpTest, OS_TRACE_ALL_CATEGORIES);  /* Will not get recorded */
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_EnableTraceClasses">Os_EnableTraceClasses</a><br /></p><h2 xmlns=""><a name="Os_EnableTraceCategories">Os_EnableTraceCategories</a></h2><p xmlns="">Control which tracepoints are traced.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_EnableTraceCategories(Os_TraceCategoriesType CategoriesMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CategoriesMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>Mask of the trace categories to enable.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Trace categories are used to filter whether tracepoints, task tracepoints and intervals get recorded and are typically used to control the volume of data that gets traced.</p><p xmlns="">A category can be configured at build time to be active always, never or under run-time control. Categories that are under run-time control are enabled using Os_EnableTraceCategories and disabled using Os_DisableTraceCategories.</p><p xmlns="">This call enables the specified run-time categories.</p><p xmlns="">Categories not listed in the call will be left in their current state. The category filter applies to all cores in a multicore application.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_EnableTraceCategories(DebugTracePoints | DataLogTracePoints);
Os_LogTracepoint(tpTest, DebugTracePoints); /* tpTest is recorded */
Os_LogTracepoint(tpTest, FunctionProfileTracePoints); /* tpTest is not recorded - FunctionProfileTracePoints not enabled */
Os_LogTracepoint(tpTest, OS_TRACE_ALL_CATEGORIES); /* tpTest is recorded */
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_DisableTraceCategories">Os_DisableTraceCategories</a><br /></p><h2 xmlns=""><a name="Os_EnableTraceClasses">Os_EnableTraceClasses</a></h2><p xmlns="">Control which types of objects are traced.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_EnableTraceClasses(Os_TraceClassesType ClassMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ClassMask</td><td class="CodeBodyText">Os_TraceClassesType</td><td>in</td><td>Mask of the trace classes to enable.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Trace classes are used to filter whether complete types of trace events get recorded. They are typically used to control the volume of data that gets traced.</p><p xmlns="">Trace classes can be configured at build time to be active always, never or under run-time control. Classes that are under run-time control are enabled using Os_EnableTraceClasses and disabled using Os_DisableTraceClasses.</p><p xmlns="">This call enables the specified run-time classes. The class filter applies to all cores in a multicore application.</p><p xmlns="">Classes not listed in the call will be left in their current state.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_EnableTraceClasses(OS_TRACE_TRACEPOINT_CLASS);
Os_LogTracepoint(tpTest, OS_TRACE_ALL_CATEGORIES);  /* Will get recorded */
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_DisableTraceClasses">Os_DisableTraceClasses</a><br /></p><h2 xmlns=""><a name="Os_GetElapsedTime">Os_GetElapsedTime</a></h2><p xmlns="">Get the cumulative execution time consumed by the calling TASK/ISR or Idle callback.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StopwatchTickType Os_GetElapsedTime(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StopwatchTickType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the cumulative time spent running the calling TASK, ISR or Idle callback since StartOS() (or an explicit reset of the accumulated time).</p><p xmlns="">If the total time exceeds the range of Os_StopwatchTickType the reported value will saturate at the maximum Os_StopwatchTickType value (typically 0xffffffff).</p><p xmlns="">The time reported includes the time accrued in the current invocation of the TASK/ISR/Idle callback.</p><p xmlns="">Time Monitoring and Elapsed Time Recording must be enabled for this API to give meaningful results. It returns zero if time monitoring is not enabled.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StopwatchTickType Total_Idle_Time;
Os_StopwatchTickType Total_Task_Time;
Os_StopwatchTickType Total_ISR_Time;

FUNC(boolean, {memclass}) Os_Cbk_Idle(void) {
  Total_Idle_Time = Os_GetElapsedTime();
}

TASK(MyTask){
  Total_Task_Time = Os_GetElapsedTime();
}

ISR(MyISR){
  Total_ISR_Time = Os_GetElapsedTime();
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetTaskElapsedTime">Os_GetTaskElapsedTime</a><br /><a href="#Os_GetISRElapsedTime">Os_GetISRElapsedTime</a><br /><a href="#Os_GetIdleElapsedTime">Os_GetIdleElapsedTime</a><br /><a href="#Os_ResetTaskElapsedTime">Os_ResetTaskElapsedTime</a><br /><a href="#Os_ResetISRElapsedTime">Os_ResetISRElapsedTime</a><br /><a href="#Os_ResetIdleElapsedTime">Os_ResetIdleElapsedTime</a><br /></p><h2 xmlns=""><a name="Os_GetExecutionTime">Os_GetExecutionTime</a></h2><p xmlns="">Get the execution time consumed by the calling Task/ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StopwatchTickType Os_GetExecutionTime(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StopwatchTickType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the net execution time consumed (i.e. excluding all preemptions) since the start of the Task or ISR.</p><p xmlns="">In the case of an extended task, execution time restarts on return from a WaitEvent() call.</p><p xmlns="">The value is not valid in PreTaskHook(), but it is valid in Os_Cbk_TaskStart() and Os_Cbk_ISRStart().</p><p xmlns="">Any value read in PostTaskHook() is valid, but it will be greater than the value that is used to determine a task's maximum execution time.</p><p xmlns="">If the value overflows, then the returned value will be the wrapped value.</p><p xmlns="">Time monitoring must be enabled for this API to give meaningful results. It returns zero if time monitoring is not enabled.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  Os_StopwatchTickType Start, Finish, Used, APICallCorrection;
  Start = GetExecutionTime();
  Finish = GetExecutionTime();
  APICallCorrection = Finish - Start;  /* Get time for GetExecutionTime() call itself. */
  Start = GetExecutionTime();
  Call3rdPartyLibraryFunction();       /* Measure 3rd Party Library Code Execution Time */
  Finish = GetExecutionTime();
  Used = Finish - Start - APICallCorrection; /* Calculate the amount of time used. */
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetISRMaxExecutionTime">Os_GetISRMaxExecutionTime</a><br /><a href="#Os_GetTaskMaxExecutionTime">Os_GetTaskMaxExecutionTime</a><br /><a href="#Os_ResetISRMaxExecutionTime">Os_ResetISRMaxExecutionTime</a><br /><a href="#Os_ResetTaskMaxExecutionTime">Os_ResetTaskMaxExecutionTime</a><br /><a href="#OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /><a href="#Os_Cbk_TaskStart">Os_Cbk_TaskStart</a><br /><a href="#Os_Cbk_TaskEnd">Os_Cbk_TaskEnd</a><br /><a href="#Os_Cbk_ISRStart">Os_Cbk_ISRStart</a><br /><a href="#Os_Cbk_ISREnd">Os_Cbk_ISREnd</a><br /></p><h2 xmlns=""><a name="Os_GetIdleElapsedTime">Os_GetIdleElapsedTime</a></h2><p xmlns="">Get the cumulative execution time consumed when idle on the specified core.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StopwatchTickType Os_GetIdleElapsedTime(Os_IdleType IdleID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">OS_CORE_CURRENT</td><td class="CodeBodyText">Os_IdleType</td><td>in</td><td>Idle on the calling core.</td></tr><tr><td class="CodeBodyText">OS_CORE_ID_0</td><td class="CodeBodyText">Os_IdleType</td><td>in</td><td>Idle on Core 0</td></tr><tr><td class="CodeBodyText">OS_CORE_ID_n</td><td class="CodeBodyText">Os_IdleType</td><td>in</td><td>Idle on Core n</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StopwatchTickType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the cumulative time spent 'idle' since StartOS() (or an explicit reset of the accumulated time).</p><p xmlns="">If the total time exceeds the range of Os_StopwatchTickType the reported value will wrap around and appear to get smaller.</p><p xmlns="">The time reported includes the time accrued in the current invocation of the Idle callback if this is on the calling core.</p><p xmlns="">Zero is returned if the IdleID is not valid.</p><p xmlns="">Time Monitoring and Elapsed Time Recording must be enabled for this API to give meaningful results. It returns zero if time monitoring is not enabled.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StopwatchTickType Total_Idle_Time;
Total_Idle_Time = Os_IdleType IdleID(OS_CORE_CURRENT);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetElapsedTime">Os_GetElapsedTime</a><br /><a href="#Os_GetTaskElapsedTime">Os_GetTaskElapsedTime</a><br /><a href="#Os_GetISRElapsedTime">Os_GetISRElapsedTime</a><br /><a href="#Os_ResetTaskElapsedTime">Os_ResetTaskElapsedTime</a><br /><a href="#Os_ResetISRElapsedTime">Os_ResetISRElapsedTime</a><br /><a href="#Os_ResetIdleElapsedTime">Os_ResetIdleElapsedTime</a><br /></p><h2 xmlns=""><a name="Os_GetISRElapsedTime">Os_GetISRElapsedTime</a></h2><p xmlns="">Get the cumulative execution time consumed by the specified ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StopwatchTickType Os_GetISRElapsedTime(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>The ISR of interest.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StopwatchTickType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the cumulative time spent running the specified category 2 ISR since StartOS() (or an explicit reset of the accumulated time).</p><p xmlns="">If the total time exceeds the range of Os_StopwatchTickType the reported value will wrap around and appear to get smaller.</p><p xmlns="">The time reported does not include any time from the current invocation if the ISR is running.</p><p xmlns="">Zero is returned if the ISRID is not valid.</p><p xmlns="">Time Monitoring and Elapsed Time Recording must be enabled for this API to give meaningful results. It returns zero if time monitoring is not enabled.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StopwatchTickType Total_ISR_Time;
Total_ISR_Time = Os_GetISRMaxExecutionTime(MyISR);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetElapsedTime">Os_GetElapsedTime</a><br /><a href="#Os_GetTaskElapsedTime">Os_GetTaskElapsedTime</a><br /><a href="#Os_GetIdleElapsedTime">Os_GetIdleElapsedTime</a><br /><a href="#Os_ResetTaskElapsedTime">Os_ResetTaskElapsedTime</a><br /><a href="#Os_ResetISRElapsedTime">Os_ResetISRElapsedTime</a><br /><a href="#Os_ResetIdleElapsedTime">Os_ResetIdleElapsedTime</a><br /></p><h2 xmlns=""><a name="Os_GetISRMaxExecutionTime">Os_GetISRMaxExecutionTime</a></h2><p xmlns="">Get the longest observed execution time consumed by an ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StopwatchTickType Os_GetISRMaxExecutionTime(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>The ISR of interest.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StopwatchTickType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the maximum observed execution time for the Category 2 ISR identified by ISRID.</p><p xmlns="">This maximum value is over all complete invocations of the Category 2 ISR that have completed since the previous call to ResetISRMaxExecutionTime() for that Category 2 ISR or to StartOS().</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(LoggingTask){
  Os_StopwatchTickType ExecutionTimes[MAXISRS];
  ...
  ExecutionTimes[0] = GetISRMaxExecutionTime(ISR1);
  ExecutionTimes[1] = GetISRMaxExecutionTime(ISR2);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetExecutionTime">Os_GetExecutionTime</a><br /><a href="#Os_GetTaskMaxExecutionTime">Os_GetTaskMaxExecutionTime</a><br /><a href="#Os_ResetISRMaxExecutionTime">Os_ResetISRMaxExecutionTime</a><br /><a href="#Os_ResetTaskMaxExecutionTime">Os_ResetTaskMaxExecutionTime</a><br /><a href="#OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a><br /></p><h2 xmlns=""><a name="Os_GetISRMaxStackUsage">Os_GetISRMaxStackUsage</a></h2><p xmlns="">Get the maximum observed stack usage of an ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StackSizeType Os_GetISRMaxStackUsage(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>The ISR of interest.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StackSizeType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the maximum observed stack usage for the Category 2 ISR identified by ISRID.</p><p xmlns="">This maximum value is over all invocations of the Category 2 ISR since the previous call to ResetISRMaxStackUsage() for that Category 2 ISR or to StartOS().</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(LoggingTask){
  Os_StackSizeType StackUsages[MAXISRS];
  ...
  StackUsages[0] = GetISRMaxStackUsage(ISR1);
  StackUsages[1] = GetISRMaxStackUsage(ISR2);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetStackUsage">Os_GetStackUsage</a><br /><a href="#Os_GetTaskMaxStackUsage">Os_GetTaskMaxStackUsage</a><br /><a href="#Os_ResetISRMaxStackUsage">Os_ResetISRMaxStackUsage</a><br /><a href="#Os_ResetTaskMaxStackUsage">Os_ResetTaskMaxStackUsage</a><br /><a href="#OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a><br /></p><h2 xmlns=""><a name="Os_GetStackSize">Os_GetStackSize</a></h2><p xmlns="">Get the difference between 2 stack values.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StackSizeType Os_GetStackSize(Os_StackValueType Base, Os_StackValueType Sample)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Base</td><td class="CodeBodyText">Os_StackValueType</td><td>in</td><td>The position to measure the stack from.</td></tr><tr><td class="CodeBodyText">Sample</td><td class="CodeBodyText">Os_StackValueType</td><td>in</td><td>The position to measure the stack to.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StackSizeType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the difference between 2 Os_StackValueType values. To obtain a correct value, it is important that 'Base' represents an instant when the stack size was smaller than (or the same as) the point at which 'Sample' was measured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StackValueType start_position;
Os_StackValueType end_position;
Os_StackSizeType stack_size;
TASK(MyTask){
  start_position = Os_GetStackValue();
  nested_call();
  stack_size = Os_GetStackSize(start_position, end_position);
}
void nested_call(void) {
  end_position = Os_GetStackValue();
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetStackValue">Os_GetStackValue</a><br /><a href="#Os_GetStackUsage">Os_GetStackUsage</a><br /></p><h2 xmlns=""><a name="Os_GetStackUsage">Os_GetStackUsage</a></h2><p xmlns="">Get the amount of stack consumed by the calling Task/ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StackSizeType Os_GetStackUsage(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StackSizeType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the amount of stack used by the calling Task or ISR at the point of the call.</p><p xmlns="">The value is measured from the point at which the OS kernel starts to run the Task or ISR, and it includes overheads within the kernel so that the values returned can be used directly in the configuration of the stack allocation budget for a Task or ISR.</p><p xmlns="">Calling this API has the side-effect of updating the recorded maximum stack usage for the calling Task or ISR (where necessary).</p><p xmlns="">If the Task/ISR has a stack allocation budget, then a stack overrun may be reported before this API returns.</p><p xmlns="">Stack monitoring must be enabled in general OS configuration for this API to give meaningful results. It returns zero if stack monitoring is not enabled.</p><p xmlns="">The Os_Cbk_CheckStackDepth callback will be called from within this API if Stack Sampling is enabled. (It will be called even if stack monitoring is not enabled)</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  Os_StackSizeType stack_size;
  stack_size = Os_GetStackUsage();
  nested_call();
}
void nested_call(void) {
  Os_GetStackUsage(); /* Identifies a possible max stack usage location */
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_StackOverrunHook">Os_Cbk_StackOverrunHook</a><br /><a href="#Os_GetISRMaxStackUsage">Os_GetISRMaxStackUsage</a><br /><a href="#Os_GetTaskMaxStackUsage">Os_GetTaskMaxStackUsage</a><br /><a href="#Os_ResetISRMaxStackUsage">Os_ResetISRMaxStackUsage</a><br /><a href="#Os_ResetTaskMaxStackUsage">Os_ResetTaskMaxStackUsage</a><br /><a href="#Os_Cbk_CheckStackDepth">Os_Cbk_CheckStackDepth</a><br /></p><h2 xmlns=""><a name="Os_GetStackValue">Os_GetStackValue</a></h2><p xmlns="">Get the current stack value.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StackValueType Os_GetStackValue(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StackValueType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the current position of the stack pointer (or pointers).</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StackValueType start_position;
Os_StackValueType end_position;
Os_StackSizeType stack_size;
TASK(MyTask){
  start_position = Os_GetStackValue();
  nested_call();
  stack_size = Os_GetStackSize(start_position, end_position);
}
void nested_call(void) {
  end_position = Os_GetStackValue();
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetStackSize">Os_GetStackSize</a><br /><a href="#Os_GetStackUsage">Os_GetStackUsage</a><br /></p><h2 xmlns=""><a name="Os_GetTaskActivationTime">Os_GetTaskActivationTime</a></h2><p xmlns="">Get the timestamp of the most recent successful activation of the Task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_GetTaskActivationTime(TaskType TaskID, Os_StopwatchTickRefType Value)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>The Task of interest.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">Os_StopwatchTickRefType</td><td>out</td><td>The timestamp of the most recent activation for the task.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>TaskID is not a valid task.</td></tr><tr><td class="CodeBodyText">E_OS_NOFUNC</td><td>extended</td><td>TaskID has not yet been activated.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Returns the timestamp of the most recent activation of TaskID. (Zero if the task has not been activated.)</p><p xmlns="">In this context, activation can be via ActivateTask, SetEvent or an Alarm/ExpiryPoint.</p><p xmlns="">The timestamp is the value returned by the user-supplied function Os_Cbk_GetStopwatch() when it is called at an activation point.</p><p xmlns="">NOTE: This API (and recording of activation times) is only available when OS option Activation Monitoring is enabled.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(Task1){
  Os_StopwatchTickType MyLastActivation;
  ...
  GetTaskActivationTime(Task1, &amp;MyLastActivation);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_GetStopwatch">Os_Cbk_GetStopwatch</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /></p><h2 xmlns=""><a name="Os_GetTaskElapsedTime">Os_GetTaskElapsedTime</a></h2><p xmlns="">Get the cumulative execution time consumed by the specified TASK.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StopwatchTickType Os_GetTaskElapsedTime(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>The TASK of interest.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StopwatchTickType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the cumulative time spent running the specified TASK since StartOS() (or an explicit reset of the accumulated time).</p><p xmlns="">If the total time exceeds the range of Os_StopwatchTickType the reported value will wrap around and appear to get smaller.</p><p xmlns="">The time reported does not include any time from the current invocation if the TASK is running.</p><p xmlns="">Zero is returned if the TaskID is not valid.</p><p xmlns="">Time Monitoring and Elapsed Time Recording must be enabled for this API to give meaningful results. It returns zero if time monitoring is not enabled.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StopwatchTickType Total_Task_Time;
Total_Task_Time = Os_GetTaskElapsedTime(MyTask);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetElapsedTime">Os_GetElapsedTime</a><br /><a href="#Os_GetISRElapsedTime">Os_GetISRElapsedTime</a><br /><a href="#Os_GetIdleElapsedTime">Os_GetIdleElapsedTime</a><br /><a href="#Os_ResetTaskElapsedTime">Os_ResetTaskElapsedTime</a><br /><a href="#Os_ResetISRElapsedTime">Os_ResetISRElapsedTime</a><br /><a href="#Os_ResetIdleElapsedTime">Os_ResetIdleElapsedTime</a><br /></p><h2 xmlns=""><a name="Os_GetTaskMaxExecutionTime">Os_GetTaskMaxExecutionTime</a></h2><p xmlns="">Get the longest observed execution time consumed by a Task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StopwatchTickType Os_GetTaskMaxExecutionTime(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>The Task of interest.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StopwatchTickType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the maximum observed execution time for TaskID.</p><p xmlns="">This maximum value is over all complete invocations of TaskID that have completed since the previous call to ResetTaskMaxExecutionTime() for TaskID or to StartOS().</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(LoggingTask){
  Os_StopwatchTickType ExecutionTimes[MAXTASKS];
  ...
  ExecutionTimes[0] = GetTaskMaxExecutionTime(Task1);
  ExecutionTimes[1] = GetTaskMaxExecutionTime(Task2);
  ExecutionTimes[2] = GetTaskMaxExecutionTime(Task3);
  ExecutionTimes[3] = GetTaskMaxExecutionTime(Task4);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetExecutionTime">Os_GetExecutionTime</a><br /><a href="#Os_GetISRMaxExecutionTime">Os_GetISRMaxExecutionTime</a><br /><a href="#Os_ResetISRMaxExecutionTime">Os_ResetISRMaxExecutionTime</a><br /><a href="#Os_ResetTaskMaxExecutionTime">Os_ResetTaskMaxExecutionTime</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /></p><h2 xmlns=""><a name="Os_GetTaskMaxStackUsage">Os_GetTaskMaxStackUsage</a></h2><p xmlns="">Get the maximum observed stack usage of a Task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_StackSizeType Os_GetTaskMaxStackUsage(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>The Task of interest.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StackSizeType</p><h4 xmlns="">Description</h4><p xmlns="">Returns the maximum observed stack usage for TaskID.</p><p xmlns="">This maximum value is over all invocations of TaskID since the previous call to ResetTaskMaxStackUsage() for TaskID or to StartOS().</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(LoggingTask){
  Os_StackSizeType StackUsages[MAXTASKS];
  ...
  StackUsages[0] = GetTaskMaxStackUsage(Task1);
  StackUsages[1] = GetTaskMaxStackUsage(Task2);
  StackUsages[2] = GetTaskMaxStackUsage(Task3);
  StackUsages[3] = GetTaskMaxStackUsage(Task4);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetStackUsage">Os_GetStackUsage</a><br /><a href="#Os_GetISRMaxStackUsage">Os_GetISRMaxStackUsage</a><br /><a href="#Os_ResetISRMaxStackUsage">Os_ResetISRMaxStackUsage</a><br /><a href="#Os_ResetTaskMaxStackUsage">Os_ResetTaskMaxStackUsage</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /></p><h2 xmlns=""><a name="Os_GetTrapInfo">Os_GetTrapInfo</a></h2><p xmlns="">Return information about the most recent unhandled trap.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(StatusType, OS_CODE) Os_GetTrapInfo(OsTrapInfoRefType Info)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">info</td><td class="CodeBodyText">OsTrapInfoRefType</td><td>in</td><td>Pointer to the OsTrapInfoType into which the information will be copied.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ILLEGAL_ADDRESS</td><td>extended</td><td>State is an address that is not writable by the current OS-Application (only when there are untrusted OS-Applications).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">When an unhandled processor Trap is detected, RTA-OS records the trap class, identification number and return address.</p><p xmlns="">It stores this information independently for each core, and then calls the ProtectionHook (when configured).</p><p xmlns="">You can call Os_GetTrapInfo() from within ProtectionHook to get a copy of the most recent trap information for the calling core.</p><p xmlns="">You should only call Os_GetTrapInfo() when the StatusType passed to ProtectionHook is E_OS_PROTECTION_MEMORY or E_OS_PROTECTION_EXCEPTION.</p><p xmlns="">Note that Os_GetTrapInfo() can only return the information for the most recent unhandled trap for the given core.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(ProtectionReturnType, {memclass}) ProtectionHook(StatusType FatalError) {
  OsTrapInfoType trap_info;
  switch (FatalError) {
    case E_OS_PROTECTION_MEMORY:
      /* A memory protection error has been detected */
      Os_GetTrapInfo(&amp;trap_info);
      return MyUnexpectedTrapHandler(trap_info.Class, trap_info.TIN, trap_info.ReturnAddress);
    case E_OS_PROTECTION_EXCEPTION:
      /* Trap occurred */
      Os_GetTrapInfo(&amp;trap_info);
      return MyUnexpectedTrapHandler(trap_info.Class, trap_info.TIN, trap_info.ReturnAddress);
    ...
  }
  return PRO_SHUTDOWN;
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ProtectionHook">ProtectionHook</a><br /><a href="#OsTrapInfoType">OsTrapInfoType</a><br /><a href="#OsTrapInfoRefType">OsTrapInfoRefType</a><br /></p><h2 xmlns=""><a name="Os_GetVersionInfo">Os_GetVersionInfo</a></h2><p xmlns="">Get the version information for the OS</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_GetVersionInfo(Std_VersionInfoType *versioninfo)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">versioninfo</td><td class="CodeBodyText">Std_VersionInfoType</td><td>out</td><td>Pointer to variable used to get the OS Version information</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The content of the structure 'Std_VersionInfoType' is defined in Std_Types.h</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Std_VersionInfoType ver;
Os_GetVersionInfo(&amp;ver);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns="" /><h2 xmlns=""><a name="Os_IncrementCounter_&lt;CounterID&gt;">Os_IncrementCounter_&lt;CounterID&gt;</a></h2><p xmlns="">Increment a software counter.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType IncrementCounter_&lt;CounterID&gt;(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call has the same behavior as IncrementCounter(CounterID) but is customized for a named counter. This makes the call faster and more suitable for use in interrupt handlers. Note that error checks are not performed.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ISR(MillisecondTimerInterrupt){
  ...
  Os_IncrementCounter_MillisecondCounter();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#IncrementCounter">IncrementCounter</a><br /><a href="#Os_AdvanceCounter">Os_AdvanceCounter</a><br /><a href="#Os_AdvanceCounter_&lt;CounterID&gt;">Os_AdvanceCounter_&lt;CounterID&gt;</a><br /></p><h2 xmlns=""><a name="Os_InitializeInterruptTable">Os_InitializeInterruptTable</a></h2><p xmlns="">Initialize the trap vector table.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, OS_CODE) Os_InitializeInterruptTable(void)</p><h4 xmlns="">Description</h4><p xmlns="">RTA-OS creates interrupt vector table(s) based upon the interrupts that are configured. In the TriCore, the BIV register must be set to the address of the appropriate table. It should be called before StartOS().</p><p xmlns="">The interrupt table must be initialized by calling this for each AUTOSAR core in a multicore application.</p><p xmlns="">You do not normally need to call Os_InitializeInterruptTable() directly because it gets called by Os_InitializeVectorTable().</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_InitializeInterruptTable();
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr /></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartOS">StartOS</a><br /><a href="#Os_InitializeVectorTable">Os_InitializeVectorTable</a><br /></p><h2 xmlns=""><a name="Os_InitializeServiceRequests">Os_InitializeServiceRequests</a></h2><p xmlns="">Initializes the TriCore Service Request Registers according to the application configuration.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, OS_CODE) Os_InitializeServiceRequests(void)</p><h4 xmlns="">Description</h4><p xmlns="">It is crucial that the initialization of the TriCore Service Request Registers is done in accordance with the interrupts and priorities declared in the application configuration.</p><p xmlns="">This function gets called to set the correct SRC values. You do not normally need to call this explicitly because it is automatically called from Os_InitializeInterruptTable() (if this is called from core 0).</p><p xmlns="">Note that the hardware priority values allocated to each interrupt source are not the same as the logical interrupt priority levels (IPLs) that are assigned to an interrupt in the configuration. In a single-core system, the priorities are compressed to reduce the vector table size and improve response times. In multi-core systems, there are additional constraints that require priorities across cores to be aligned and the correct interrupt steering values to be set.</p><p xmlns="">If really necessary, you can use the OS_INIT_&lt;srcname&gt; macros to set the values directly.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">  Os_InitializeServiceRequests();
  StartOS();
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_InitializeVectorTable">Os_InitializeVectorTable</a><br /><a href="#StartOS">StartOS</a><br /><a href="#Os_InitializeInterruptTable">Os_InitializeInterruptTable</a><br /></p><h2 xmlns=""><a name="Os_InitializeTrapTable">Os_InitializeTrapTable</a></h2><p xmlns="">Initialize the trap vector table.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, OS_CODE) Os_InitializeTrapTable(void)</p><h4 xmlns="">Description</h4><p xmlns="">RTA-OS creates trap vector table(s) based upon the traps that are configured. In the TriCore, the BTV register must be set to the address of the appropriate table. It should be called before StartOS().</p><p xmlns="">The trap table must be initialized by calling this for each AUTOSAR core in a multicore application.</p><p xmlns="">You do not normally need to call Os_InitializeTrapTable() directly because it gets called by Os_InitializeVectorTable().</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_InitializeTrapTable();
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr /></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartOS">StartOS</a><br /><a href="#Os_InitializeVectorTable">Os_InitializeVectorTable</a><br /></p><h2 xmlns=""><a name="Os_InitializeVectorTable">Os_InitializeVectorTable</a></h2><p xmlns="">Initialize the interrupt vector table.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_InitializeVectorTable(void)</p><h4 xmlns="">Description</h4><p xmlns="">RTA-OS creates interrupt table(s) and trap vector table(s) based upon the interrupts and traps that are configured. In the TriCore, the BIV and BTV registers must be set to their start addresses.</p><p xmlns="">In addition, the Service Request Control Registers must be set up correctly such that they match the configuration that is declared for the project. In particular, the TOS and SRPN values must be correct. Note that the SRPN value does not necessarily match the priority assigned to an interrupt.</p><p xmlns="">Os_InitializeVectorTable() performs all of these initializations for you. It should be called before StartOS().</p><p xmlns="">If you only want to initialize the interrupt system then call Os_InitializeInterruptTable() instead of Os_InitializeVectorTable.</p><p xmlns="">If you only want to initialize the SRC registers then call Os_InitializeServiceRequests() instead of Os_InitializeVectorTable / Os_InitializeInterruptTable.</p><p xmlns="">If you only want to initialize the trap system then call Os_InitializeTrapTable() instead of Os_InitializeVectorTable.</p><p xmlns="">However it is recommended that you always use Os_InitializeVectorTable().</p><p xmlns="">In a multicore application, each core must perform these initializations.</p><p xmlns="">You must ensure that the BIV, BTV and SRC registers are in a state where they can be modified when you make these calls. You will need to be running in Supervisor with ENDINIT protection off.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_InitializeVectorTable();
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr /></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartOS">StartOS</a><br /><a href="#Os_InitializeTrapTable">Os_InitializeTrapTable</a><br /><a href="#Os_InitializeVectorTable">Os_InitializeVectorTable</a><br /><a href="#Os_InitializeServiceRequests">Os_InitializeServiceRequests</a><br /></p><h2 xmlns=""><a name="Os_LogCat1ISREnd">Os_LogCat1ISREnd</a></h2><p xmlns="">Log the end of a Category 1 ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogCat1ISREnd(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>Category 1 ISR identifier.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call marks the end of a Category 1 ISR. This type of ISR is not controlled by the operating system so no automatic tracing of it can occur. If Category 1 ISRs need to be logged then it is necessary to do this manually using this call.</p><p xmlns="">This event is only logged if the OS_TRACE_TASKS_AND_ISRS_CLASS trace class is active.</p><p xmlns="">Take care to ensure that both the start and end of the Category 1 ISR logged, otherwise the resulting trace will be incorrect.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CAT1_ISR(Category1Handler) {
  Os_LogCat1ISRStart(Category1Handler);
  ...
  Os_LogCat1ISREnd(Category1Handler);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogCat1ISRStart">Os_LogCat1ISRStart</a><br /></p><h2 xmlns=""><a name="Os_LogCat1ISRStart">Os_LogCat1ISRStart</a></h2><p xmlns="">Log the start of a Category 1 ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogCat1ISRStart(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>Category 1 ISR identifier.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call marks the start of a Category 1 ISR. This type of ISR is not controlled by the operating system so no automatic tracing of it can occur. If Category 1 ISRs need to be logged then it is necessary to do this manually using this call.</p><p xmlns="">This event is only logged if the OS_TRACE_TASKS_AND_ISRS_CLASS trace class is active.</p><p xmlns="">Take care to ensure that both the start and end of the Category 1 ISR are logged, otherwise the resulting trace will be incorrect.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CAT1_ISR(Category1Handler) {
  Os_LogCat1ISRStart(Category1Handler);
  ...
  Os_LogCat1ISREnd(Category1Handler);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogCat1ISREnd">Os_LogCat1ISREnd</a><br /></p><h2 xmlns=""><a name="Os_LogCriticalExecutionEnd">Os_LogCriticalExecutionEnd</a></h2><p xmlns="">Log the completion of a critical execution event.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogCriticalExecutionEnd(Os_TraceInfoType CriticalExecutionID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CriticalExecutionID</td><td class="CodeBodyText">Os_TraceInfoType</td><td>in</td><td>Critical execution profile identifier.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Logs the end of a critical point of execution in the trace buffer. This is typically used to indicate that a task/ISR has completed a time-critical section of code. This might be needed if the deadline that needs to be met by the task/ISR occurs before the end of the task/ISR.</p><p xmlns="">CriticalExecutionID is only logged if the OS_TRACE_TASKS_AND_ISRS_CLASS class is active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  ReadSensor(X);
  Os_LogCriticalExecutionEnd(SensorRead);
  ...
  WriteActuator(Y);
  Os_LogCriticalExecutionEnd(SensorRead);
  ...
  TerminateTask();
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns="" /><h2 xmlns=""><a name="Os_LogIntervalEnd">Os_LogIntervalEnd</a></h2><p xmlns="">Log the end of a measurement interval.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogIntervalEnd(Os_TraceIntervalIDType IntervalID, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">IntervalID</td><td class="CodeBodyText">Os_TraceIntervalIDType</td><td>in</td><td>Interval Identifier.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the end of an interval in the trace buffer.</p><p xmlns="">The interval is only logged if the OS_TRACE_INTERVAL_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogIntervalStart(EndToEndTime, SystemLoggingCategory);
...
Os_LogIntervalEnd(EndToEndTime, SystemLoggingCategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogIntervalEndValue">Os_LogIntervalEndValue</a><br /><a href="#Os_LogIntervalEndData">Os_LogIntervalEndData</a><br /><a href="#Os_LogIntervalStart">Os_LogIntervalStart</a><br /><a href="#Os_LogIntervalStartValue">Os_LogIntervalStartValue</a><br /><a href="#Os_LogIntervalStartData">Os_LogIntervalStartData</a><br /></p><h2 xmlns=""><a name="Os_LogIntervalEndData">Os_LogIntervalEndData</a></h2><p xmlns="">Log the end of a measurement interval together with associated data.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogIntervalEndData(Os_TraceIntervalIDType IntervalID, Os_TraceDataPtrType DataPtr, Os_TraceDataLengthType Length, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">IntervalID</td><td class="CodeBodyText">Os_TraceIntervalIDType</td><td>in</td><td>Interval Identifier.</td></tr><tr><td class="CodeBodyText">DataPtr</td><td class="CodeBodyText">Os_TraceDataPtrType</td><td>in</td><td>A pointer to the start address of the data block to log.</td></tr><tr><td class="CodeBodyText">Length</td><td class="CodeBodyText">Os_TraceDataLengthType</td><td>in</td><td>The length of the data block in bytes.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the end of an interval in the trace buffer and associate some data with it.</p><p xmlns="">The interval is only logged if the OS_TRACE_INTERVAL_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogIntervalStart(EndToEndTime, SystemLoggingCategory);
...
Os_LogIntervalEndData(EndToEndTime, &amp;DataBlock, 4,SystemLoggingCategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogIntervalEnd">Os_LogIntervalEnd</a><br /><a href="#Os_LogIntervalEndValue">Os_LogIntervalEndValue</a><br /><a href="#Os_LogIntervalStart">Os_LogIntervalStart</a><br /><a href="#Os_LogIntervalStartValue">Os_LogIntervalStartValue</a><br /><a href="#Os_LogIntervalStartData">Os_LogIntervalStartData</a><br /></p><h2 xmlns=""><a name="Os_LogIntervalEndValue">Os_LogIntervalEndValue</a></h2><p xmlns="">Log the end of a measurement interval together with an associated value.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogIntervalEndValue(Os_TraceIntervalIDType IntervalID, Os_TraceValueType Value, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">IntervalID</td><td class="CodeBodyText">Os_TraceIntervalIDType</td><td>in</td><td>Interval Identifier.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">Os_TraceValueType</td><td>in</td><td>Numerical value to be logged with the interval.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the end of an interval in the trace buffer and associate a value with it.</p><p xmlns="">The interval is only logged if the OS_TRACE_INTERVAL_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogIntervalStart(EndToEndTime, SystemLoggingCategory);
...
Os_LogIntervalEndValue(EndToEndTime, 42, SystemLoggingCategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogIntervalEnd">Os_LogIntervalEnd</a><br /><a href="#Os_LogIntervalEndData">Os_LogIntervalEndData</a><br /><a href="#Os_LogIntervalEndValue">Os_LogIntervalEndValue</a><br /><a href="#Os_LogIntervalStartValue">Os_LogIntervalStartValue</a><br /><a href="#Os_LogIntervalStartData">Os_LogIntervalStartData</a><br /></p><h2 xmlns=""><a name="Os_LogIntervalStart">Os_LogIntervalStart</a></h2><p xmlns="">Log the start of a measurement interval.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogIntervalStart(Os_TraceIntervalIDType IntervalID, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">IntervalID</td><td class="CodeBodyText">Os_TraceIntervalIDType</td><td>in</td><td>Interval Identifier.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the start of an interval in the trace buffer.</p><p xmlns="">The interval is only logged if the OS_TRACE_INTERVAL_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogIntervalStart(EndToEndTime, SystemLoggingCategory);
...
Os_LogIntervalEnd(EndToEndTime, SystemLoggingCategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogIntervalEnd">Os_LogIntervalEnd</a><br /><a href="#Os_LogIntervalEndData">Os_LogIntervalEndData</a><br /><a href="#Os_LogIntervalEndValue">Os_LogIntervalEndValue</a><br /><a href="#Os_LogIntervalStartData">Os_LogIntervalStartData</a><br /><a href="#Os_LogIntervalStartValue">Os_LogIntervalStartValue</a><br /></p><h2 xmlns=""><a name="Os_LogIntervalStartData">Os_LogIntervalStartData</a></h2><p xmlns="">Log the start of a measurement interval together with associated data.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogIntervalStartData(Os_TraceIntervalIDType IntervalID, Os_TraceDataPtrType DataPtr, Os_TraceDataLengthType Length, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">IntervalID</td><td class="CodeBodyText">Os_TraceIntervalIDType</td><td>in</td><td>Interval Identifier.</td></tr><tr><td class="CodeBodyText">DataPtr</td><td class="CodeBodyText">Os_TraceDataPtrType</td><td>in</td><td>A pointer to the start address of the data block to log.</td></tr><tr><td class="CodeBodyText">Length</td><td class="CodeBodyText">Os_TraceDataLengthType</td><td>in</td><td>The length of the data block in bytes.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the start of an interval in the trace buffer and associate some data with it.</p><p xmlns="">The interval is only logged if the OS_TRACE_INTERVAL_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogIntervalStartData(EndToEndTime, &amp;DataBlock, 4, SystemLoggingCategory);
...
Os_LogIntervalEnd(EndToEndTimeSystemLoggingCategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogIntervalEnd">Os_LogIntervalEnd</a><br /><a href="#Os_LogIntervalEndData">Os_LogIntervalEndData</a><br /><a href="#Os_LogIntervalEndValue">Os_LogIntervalEndValue</a><br /><a href="#Os_LogIntervalStart">Os_LogIntervalStart</a><br /><a href="#Os_LogIntervalStartValue">Os_LogIntervalStartValue</a><br /></p><h2 xmlns=""><a name="Os_LogIntervalStartValue">Os_LogIntervalStartValue</a></h2><p xmlns="">Log the start of a measurement interval together with an associated value.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogIntervalStartValue(Os_TraceIntervalIDType IntervalID, Os_TraceValueType Value, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">IntervalID</td><td class="CodeBodyText">Os_TraceIntervalIDType</td><td>in</td><td>Interval Identifier.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">Os_TraceValueType</td><td>in</td><td>Numerical value to be logged with the interval.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the start of an interval in the trace buffer and associate a value with it.</p><p xmlns="">The interval is only logged if the OS_TRACE_INTERVAL_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogIntervalStartValue(EndToEndTime, 42, SystemLoggingCategory);
...
Os_LogIntervalEnd(EndToEndTime, SystemLoggingCategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogIntervalEnd">Os_LogIntervalEnd</a><br /><a href="#Os_LogIntervalEndData">Os_LogIntervalEndData</a><br /><a href="#Os_LogIntervalEndValue">Os_LogIntervalEndValue</a><br /><a href="#Os_LogIntervalStart">Os_LogIntervalStart</a><br /><a href="#Os_LogIntervalStartData">Os_LogIntervalStartData</a><br /></p><h2 xmlns=""><a name="Os_LogProfileStart">Os_LogProfileStart</a></h2><p xmlns="">Log the start of a new execution profile.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogProfileStart(Os_TraceInfoType ProfileID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ProfileID</td><td class="CodeBodyText">Os_TraceInfoType</td><td>in</td><td>Profile Identifier.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Logs which execution profile is active in the trace buffer. Execution profiles can be used to identify which route is taken through a Task or ISR when this depends on external conditions.</p><p xmlns="">The profile is only recorded if the OS_TRACE_TASKS_AND_ISRS_CLASS class is active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  if (some_condition()) {
    Os_LogProfileStart(TrueRoute);
    ...
  } else {
    Os_LogProfileStart(FalseRoute);
    ...
  }
  TerminateTask();
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns="" /><h2 xmlns=""><a name="Os_LogTaskTracepoint">Os_LogTaskTracepoint</a></h2><p xmlns="">Log a tracepoint in the specified categories.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogTaskTracepoint(Os_TraceTracepointIDType TaskTracepointID, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskTracepointID</td><td class="CodeBodyText">Os_TraceTracepointIDType</td><td>in</td><td>Task Tracepoint Identifier.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the task tracepoint event in the trace buffer.</p><p xmlns="">TaskTracepointID is recorded only if the OS_TRACE_TASK_TRACEPOINT_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogTaskTracepoint(MyTaskTracePoint, ACategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogTracepoint">Os_LogTracepoint</a><br /><a href="#Os_LogTracepointData">Os_LogTracepointData</a><br /><a href="#Os_LogTracepointValue">Os_LogTracepointValue</a><br /><a href="#Os_LogTaskTracepointData">Os_LogTaskTracepointData</a><br /><a href="#Os_LogTaskTracepointValue">Os_LogTaskTracepointValue</a><br /></p><h2 xmlns=""><a name="Os_LogTaskTracepointData">Os_LogTaskTracepointData</a></h2><p xmlns="">Log a tracepoint in the specified categories together with associated data.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogTaskTracepointData(Os_TraceTracepointIDType TracepointID, Os_TraceDataPtrType DataPtr, Os_TraceDataLengthType Length, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TracepointID</td><td class="CodeBodyText">Os_TraceTracepointIDType</td><td>in</td><td>Tracepoint Identifier.</td></tr><tr><td class="CodeBodyText">DataPtr</td><td class="CodeBodyText">Os_TraceDataPtrType</td><td>in</td><td>A pointer to the start address of the data block to log.</td></tr><tr><td class="CodeBodyText">Length</td><td class="CodeBodyText">Os_TraceDataLengthType</td><td>in</td><td>The length of the data block in bytes.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the task tracepoint event in the trace buffer and associate some data with it.</p><p xmlns="">TaskTracepointID is recorded only if the OS_TRACE_TASK_TRACEPOINT_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogTaskTracepointData(MyTracePoint, &amp;DataBlock, 4, ACategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogTracepoint">Os_LogTracepoint</a><br /><a href="#Os_LogTracepointValue">Os_LogTracepointValue</a><br /><a href="#Os_LogTracepointData">Os_LogTracepointData</a><br /><a href="#Os_LogTaskTracepoint">Os_LogTaskTracepoint</a><br /><a href="#Os_LogTaskTracepointValue">Os_LogTaskTracepointValue</a><br /></p><h2 xmlns=""><a name="Os_LogTaskTracepointValue">Os_LogTaskTracepointValue</a></h2><p xmlns="">Log a tracepoint in the specified categories together with an associated value.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogTaskTracepointValue(Os_TraceTracepointIDType TracepointID, Os_TraceValueType Value, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TracepointID</td><td class="CodeBodyText">Os_TraceTracepointIDType</td><td>in</td><td>Tracepoint Identifier.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">Os_TraceValueType</td><td>in</td><td>Numerical value to be logged with the tracepoint.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the task tracepoint event in the trace buffer and associate a value with it.</p><p xmlns="">TaskTracepointID is recorded only if the OS_TRACE_TASK_TRACEPOINT_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogTaskTracepointValue(MyTracePoint, 99, ACategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogTracepoint">Os_LogTracepoint</a><br /><a href="#Os_LogTracepointData">Os_LogTracepointData</a><br /><a href="#Os_LogTracepointValue">Os_LogTracepointValue</a><br /><a href="#Os_LogTaskTracepoint">Os_LogTaskTracepoint</a><br /><a href="#Os_LogTaskTracepointData">Os_LogTaskTracepointData</a><br /></p><h2 xmlns=""><a name="Os_LogTracepoint">Os_LogTracepoint</a></h2><p xmlns="">Log a tracepoint in the specified categories.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogTracepoint(Os_TraceTracepointIDType TracepointID, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TracepointID</td><td class="CodeBodyText">Os_TraceTracepointIDType</td><td>in</td><td>Tracepoint Identifier.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the tracepoint event in the trace buffer.</p><p xmlns="">TracepointID is recorded only if the OS_TRACE_TRACEPOINT_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogTracepoint(MyTracepoint, ACategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogTracepoint">Os_LogTracepoint</a><br /><a href="#Os_LogTracepointData">Os_LogTracepointData</a><br /><a href="#Os_LogTracepointValue">Os_LogTracepointValue</a><br /><a href="#Os_LogTracepointData">Os_LogTracepointData</a><br /><a href="#Os_LogTracepointValue">Os_LogTracepointValue</a><br /></p><h2 xmlns=""><a name="Os_LogTracepointData">Os_LogTracepointData</a></h2><p xmlns="">Log a tracepoint in the specified categories together with associated data.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogTracepointData(Os_TraceTracepointIDType TracepointID, Os_TraceDataPtrType DataPtr, Os_TraceDataLengthType Length, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TracepointID</td><td class="CodeBodyText">Os_TraceTracepointIDType</td><td>in</td><td>Tracepoint Identifier.</td></tr><tr><td class="CodeBodyText">DataPtr</td><td class="CodeBodyText">Os_TraceDataPtrType</td><td>in</td><td>A pointer to the start address of the data block to log.</td></tr><tr><td class="CodeBodyText">Length</td><td class="CodeBodyText">Os_TraceDataLengthType</td><td>in</td><td>The length of the data block in bytes.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the tracepoint event in the trace buffer and associate some data with it.</p><p xmlns="">TracepointID is recorded only if the OS_TRACE_TRACEPOINT_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogTracepointData(MyTracePoint, &amp;DataBlock, 4, ACategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogTracepoint">Os_LogTracepoint</a><br /><a href="#Os_LogTracepointValue">Os_LogTracepointValue</a><br /><a href="#Os_LogTracepointData">Os_LogTracepointData</a><br /><a href="#Os_LogTracepoint">Os_LogTracepoint</a><br /><a href="#Os_LogTracepointValue">Os_LogTracepointValue</a><br /></p><h2 xmlns=""><a name="Os_LogTracepointValue">Os_LogTracepointValue</a></h2><p xmlns="">Log a tracepoint in the specified categories together with an associated value.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_LogTracepointValue(Os_TraceTracepointIDType TracepointID, Os_TraceValueType Value, Os_TraceCategoriesType CategoryMask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TracepointID</td><td class="CodeBodyText">Os_TraceTracepointIDType</td><td>in</td><td>Tracepoint Identifier.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">Os_TraceValueType</td><td>in</td><td>Numerical value to be logged with the tracepoint.</td></tr><tr><td class="CodeBodyText">CategoryMask</td><td class="CodeBodyText">Os_TraceCategoriesType</td><td>in</td><td>A category mask.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Log the tracepoint event in the trace buffer and associate a value with it.</p><p xmlns="">TracepointID is recorded only if the OS_TRACE_TRACEPOINT_CLASS class is active and one or more of the categories in CategoryMask are active.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_LogTracepointValue(MyTracePoint, 99, ACategory);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_LogTracepoint">Os_LogTracepoint</a><br /><a href="#Os_LogTracepointData">Os_LogTracepointData</a><br /><a href="#Os_LogTracepointValue">Os_LogTracepointValue</a><br /><a href="#Os_LogTracepoint">Os_LogTracepoint</a><br /><a href="#Os_LogTracepointData">Os_LogTracepointData</a><br /></p><h2 xmlns=""><a name="Os_RemoveDelayedTasks">Os_RemoveDelayedTasks</a></h2><p xmlns="">Remove one or more tasks from the set of tasks that are subject to delayed execution.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_RemoveDelayedTasks(Os_TasksetType Taskset)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Taskset</td><td class="CodeBodyText">Os_TasksetType</td><td>in</td><td>The set of tasks to be removed.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>Delayed tasks cannot be changed by untrusted code</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>A task is being removed that has the same priority as another task on the same core. You have to remove all of the tasks that share the priority.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">When delayed task execution is configured for the project, you can tell RTA-OS to delay execution of a set of tasks. These tasks can be activated, but will not actually run until they are removed from the set.</p><p xmlns="">Os_RemoveDelayedTasks is used to remove tasks from the set of tasks being delayed.</p><p xmlns="">Removed tasks will execute before this call returns (assuming they have higher priority than the caller).</p><p xmlns="">Note that where tasks share priorities on a specific core, you must either remove all of the tasks sharing a priority or none.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">/* Normal case - fewer than 65 tasks */
TASK(LowPrioTask){
  Os_SetDelayedTasks(TASK_MASK(Task1) | TASK_MASK(Task3));
  ... /* Tasks 1 and 3 (only) can be activated, but will not run*/

  Os_RemoveDelayedTasks(TASK_MASK(Task1) | TASK_MASK(Task3));
  ... /* Tasks 1 and 3 can run*/
}

/* 65 tasks or more*/
TASK(LowPrioTask){
  Os_TasksetType no_tasks = OS_NO_TASKS;
  Os_TasksetType t1_and_t3 = TASK_MASK(Task1);
  OS_ADD_TASK(t1_and_t3, Task3);
  Os_SetDelayedTasks(t1_and_t3);
  ... /* Tasks 1 and 3 (only) can be activated, but will not run*/

  Os_RemoveDelayedTasks(t1_and_t3);
  ... /* Tasks 1 and 3 can run*/
}

</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_AddDelayedTasks">Os_AddDelayedTasks</a><br /><a href="#Os_SetDelayedTasks">Os_SetDelayedTasks</a><br /><a href="#OS_ADD_TASK">OS_ADD_TASK</a><br /><a href="#OS_NO_TASKS">OS_NO_TASKS</a><br /><a href="#TASK_MASK">TASK_MASK</a><br /><a href="#Os_TasksetType">Os_TasksetType</a><br /></p><h2 xmlns=""><a name="Os_ResetIdleElapsedTime">Os_ResetIdleElapsedTime</a></h2><p xmlns="">Reset the cumulative idle execution time for a core.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_ResetIdleElapsedTime(Os_IdleType IdleID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">OS_CORE_CURRENT</td><td class="CodeBodyText">Os_IdleType</td><td>in</td><td>Idle on the calling core.</td></tr><tr><td class="CodeBodyText">OS_CORE_ID_0</td><td class="CodeBodyText">Os_IdleType</td><td>in</td><td>Idle on Core 0</td></tr><tr><td class="CodeBodyText">OS_CORE_ID_n</td><td class="CodeBodyText">Os_IdleType</td><td>in</td><td>Idle on Core n</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>IdleID is not valid.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Reset the cumulative idle execution time the core ID to zero.</p><p xmlns="">Note that in a multicore application you can only reliably call this from the core that owns IdleID. Full cross-core protection has not been implemented for reasons of efficiency.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_ResetIdleElapsedTime(OS_CORE_CURRENT);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetElapsedTime">Os_GetElapsedTime</a><br /><a href="#Os_GetTaskElapsedTime">Os_GetTaskElapsedTime</a><br /><a href="#Os_GetISRElapsedTime">Os_GetISRElapsedTime</a><br /><a href="#Os_GetIdleElapsedTime">Os_GetIdleElapsedTime</a><br /><a href="#Os_ResetTaskElapsedTime">Os_ResetTaskElapsedTime</a><br /><a href="#Os_ResetISRElapsedTime">Os_ResetISRElapsedTime</a><br /></p><h2 xmlns=""><a name="Os_ResetISRElapsedTime">Os_ResetISRElapsedTime</a></h2><p xmlns="">Reset the cumulative execution time for an ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_ResetISRElapsedTime(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>Name of the ISR to reset.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ISRID is not a valid ISR.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ISRID is not accessible from the calling OS-Application.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Reset the cumulative execution time for ISRID to zero.</p><p xmlns="">Note that in a multicore application you can only reliably call this from the core that owns IsrID. Full cross-core protection has not been implemented for reasons of efficiency.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_ResetISRElapsedTime(MyISR);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetElapsedTime">Os_GetElapsedTime</a><br /><a href="#Os_GetTaskElapsedTime">Os_GetTaskElapsedTime</a><br /><a href="#Os_GetISRElapsedTime">Os_GetISRElapsedTime</a><br /><a href="#Os_GetIdleElapsedTime">Os_GetIdleElapsedTime</a><br /><a href="#Os_ResetTaskElapsedTime">Os_ResetTaskElapsedTime</a><br /><a href="#Os_ResetIdleElapsedTime">Os_ResetIdleElapsedTime</a><br /></p><h2 xmlns=""><a name="Os_ResetISRMaxExecutionTime">Os_ResetISRMaxExecutionTime</a></h2><p xmlns="">Reset the maximum observed execution time for an ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_ResetISRMaxExecutionTime(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>Name of the ISR to reset.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ISRID is not a valid Category 2 ISR.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ISRID is not accessible from the calling OS-Application.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Reset the maximum observed execution time for the Category 2 ISR identified by ISRID to zero.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(ProfilingTask){
  Os_StopwatchTickType ExecutionTimeLog[SAMPLES];
  ...
  ExecutionTimeLog[index++] = Os_GetISRMaxExecutionTime(ISR1);
  Os_ResetISRMaxExecutionTime(ISR1);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetExecutionTime">Os_GetExecutionTime</a><br /><a href="#Os_GetTaskMaxExecutionTime">Os_GetTaskMaxExecutionTime</a><br /><a href="#Os_GetISRMaxExecutionTime">Os_GetISRMaxExecutionTime</a><br /><a href="#Os_ResetTaskMaxExecutionTime">Os_ResetTaskMaxExecutionTime</a><br /></p><h2 xmlns=""><a name="Os_ResetISRMaxStackUsage">Os_ResetISRMaxStackUsage</a></h2><p xmlns="">Reset the maximum observed stack usage for an ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_ResetISRMaxStackUsage(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>Name of the ISR to reset.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ISRID is not a valid Category 2 ISR.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ISRID is not accessible from the calling OS-Application.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Reset the maximum observed stack usage for ISRID to zero.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(ProfilingTask){
  Os_StackSizeType StackUsageLog[SAMPLES];
  ...
  StackUsageLog[index++] = Os_GetISRMaxStackUsage(ISR1);
  Os_ResetISRMaxStackUsage(ISR1);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetStackUsage">Os_GetStackUsage</a><br /><a href="#Os_GetTaskMaxStackUsage">Os_GetTaskMaxStackUsage</a><br /><a href="#Os_GetISRMaxStackUsage">Os_GetISRMaxStackUsage</a><br /><a href="#Os_ResetTaskMaxStackUsage">Os_ResetTaskMaxStackUsage</a><br /></p><h2 xmlns=""><a name="Os_ResetTaskElapsedTime">Os_ResetTaskElapsedTime</a></h2><p xmlns="">Reset the cumulative execution time for a task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_ResetTaskElapsedTime(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Name of the task to reset.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>TaskID is not a valid task.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not accessible from the calling OS-Application.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Reset the cumulative execution time for TaskID to zero.</p><p xmlns="">Note that in a multicore application you can only reliably call this from the core that owns TaskID. Full cross-core protection has not been implemented for reasons of efficiency.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_ResetTaskElapsedTime(MyTask);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetElapsedTime">Os_GetElapsedTime</a><br /><a href="#Os_GetTaskElapsedTime">Os_GetTaskElapsedTime</a><br /><a href="#Os_GetISRElapsedTime">Os_GetISRElapsedTime</a><br /><a href="#Os_GetIdleElapsedTime">Os_GetIdleElapsedTime</a><br /><a href="#Os_ResetISRElapsedTime">Os_ResetISRElapsedTime</a><br /><a href="#Os_ResetIdleElapsedTime">Os_ResetIdleElapsedTime</a><br /></p><h2 xmlns=""><a name="Os_ResetTaskMaxExecutionTime">Os_ResetTaskMaxExecutionTime</a></h2><p xmlns="">Reset the maximum observed execution time for a task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_ResetTaskMaxExecutionTime(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Name of the task to reset.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>TaskID is not a valid task.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not accessible from the calling OS-Application.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Reset the maximum observed execution time for TaskID to zero.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(ProfilingTask){
  Os_StopwatchTickType ExecutionTimeLog[SAMPLES];
  ...
  ExecutionTimeLog[index++] = Os_GetTaskMaxExecutionTime(Task1);
  Os_ResetTaskMaxExecutionTime(Task1);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetExecutionTime">Os_GetExecutionTime</a><br /><a href="#Os_GetISRMaxExecutionTime">Os_GetISRMaxExecutionTime</a><br /><a href="#Os_GetTaskMaxExecutionTime">Os_GetTaskMaxExecutionTime</a><br /><a href="#Os_ResetISRMaxExecutionTime">Os_ResetISRMaxExecutionTime</a><br /></p><h2 xmlns=""><a name="Os_ResetTaskMaxStackUsage">Os_ResetTaskMaxStackUsage</a></h2><p xmlns="">Reset the maximum observed stack usage for a task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_ResetTaskMaxStackUsage(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Name of the task to reset.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>TaskID is not a valid task.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not accessible from the calling OS-Application.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Reset the maximum observed stack usage for TaskID to zero.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(ProfilingTask){
  Os_StackSizeType StackUsageLog[SAMPLES];
  ...
  StackUsageLog[index++] = Os_GetTaskMaxStackUsage(Task1);
  Os_ResetTaskMaxStackUsage(Task1);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetStackUsage">Os_GetStackUsage</a><br /><a href="#Os_GetISRMaxStackUsage">Os_GetISRMaxStackUsage</a><br /><a href="#Os_GetTaskMaxStackUsage">Os_GetTaskMaxStackUsage</a><br /><a href="#Os_ResetISRMaxStackUsage">Os_ResetISRMaxStackUsage</a><br /></p><h2 xmlns=""><a name="Os_Restart">Os_Restart</a></h2><p xmlns="">Restart the OS by jumping to a previously specified location.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_Restart(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OS_SYS_RESTART</td><td>all</td><td>The call was not made from the ShutdownHook.</td></tr><tr><td class="CodeBodyText">E_OS_SYS_NO_RESTART</td><td>all</td><td>No restart point has been set.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The call re-initializes any necessary context and branches to the restart point set by Os_SetRestartPoint. The call does not return to the calling context.</p><p xmlns="">The restart point must occur before a call to StartOS(), so that all OS re-initialization re-occurs with the subsequent call to StartOS().</p><p xmlns="">Os_Restart() can be used in multicore systems. You must take care to call it for *all* AUTOSAR cores, because the synchronization code in StartOS() will prevent individual cores from restarting.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) ShutdownHook(StatusType Error){
  ...
  Os_Restart();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SetRestartPoint">Os_SetRestartPoint</a><br /><a href="#ShutdownOS">ShutdownOS</a><br /><a href="#ShutdownAllCores">ShutdownAllCores</a><br /><a href="#StartOS">StartOS</a><br /></p><h2 xmlns=""><a name="Os_SetDelayedTasks">Os_SetDelayedTasks</a></h2><p xmlns="">Specify exactly which tasks are subject to delayed execution.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_SetDelayedTasks(Os_TasksetType Taskset)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Taskset</td><td class="CodeBodyText">Os_TasksetType</td><td>in</td><td>The set of tasks that should have their execution delayed.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>Delayed tasks cannot be changed by untrusted code</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>A task is being added or removed that has the same priority as another task on the same core. You have to add/remove all of the tasks that share the priority.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">When delayed task execution is configured for the project, you can tell RTA-OS to delay execution of a set of tasks. These tasks can be activated, but will not actually run until they are removed from the set.</p><p xmlns="">Os_SetDelayedTasks is used to specify which tasks should be delayed.</p><p xmlns="">If a task was being delayed before the call but it is not in the new delayed task set, then it will execute before this call returns (assuming it has a higher priority than the caller).</p><p xmlns="">Note that where tasks share priorities on a specific core, you must either specify all of the tasks sharing a priority or none.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">/* Normal case - fewer than 65 tasks */
TASK(LowPrioTask){
  Os_SetDelayedTasks(TASK_MASK(Task1) | TASK_MASK(Task3));
  ... /* Tasks 1 and 3 (only) can be activated, but will not run*/

  Os_SetDelayedTasks(OS_NO_TASKS);
  ... /* Tasks 1 and 3 can run*/
}

/* 65 tasks or more*/
TASK(LowPrioTask){
  Os_TasksetType no_tasks = OS_NO_TASKS;
  Os_TasksetType t1_and_t3 = TASK_MASK(Task1);
  OS_ADD_TASK(t1_and_t3, Task3);
  Os_SetDelayedTasks(t1_and_t3);
  ... /* Tasks 1 and 3 (only) can be activated, but will not run*/

  Os_SetDelayedTasks(no_tasks);
  ... /* Tasks 1 and 3 can run*/
}

</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_AddDelayedTasks">Os_AddDelayedTasks</a><br /><a href="#Os_RemoveDelayedTasks">Os_RemoveDelayedTasks</a><br /><a href="#OS_ADD_TASK">OS_ADD_TASK</a><br /><a href="#OS_NO_TASKS">OS_NO_TASKS</a><br /><a href="#TASK_MASK">TASK_MASK</a><br /><a href="#Os_TasksetType">Os_TasksetType</a><br /></p><h2 xmlns=""><a name="Os_SetRestartPoint">Os_SetRestartPoint</a></h2><p xmlns="">Mark a location in code before StartOS() from where a restart of the OS can be made.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_SetRestartPoint(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OS_SYS_NO_RESTART</td><td>all</td><td>The call was not made before StartOS.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The call marks the location from which the code should resume following a call to Os_Restart(). The location must be outside of OS control, i.e. at a point before StartOS() was called. Making the call when a restart point is already sets the restart point to the new location.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">OS_MAIN() {
  ...
  Os_SetRestartPoint();
  ...
  StartOS(OSDEFAULTAPPMODE);

}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Restart">Os_Restart</a><br /><a href="#ShutdownOS">ShutdownOS</a><br /><a href="#ShutdownAllCores">ShutdownAllCores</a><br /><a href="#StartOS">StartOS</a><br /></p><h2 xmlns=""><a name="Os_SetTraceRepeat">Os_SetTraceRepeat</a></h2><p xmlns="">Control whether trace repeats or not.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_SetTraceRepeat(boolean Repeat)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Repeat</td><td class="CodeBodyText">boolean</td><td>in</td><td>Control whether bursting/triggering traces repeat.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">When TRUE, bursting and triggering trace modes automatically restart once the most recent trace content has been transmitted from the trace buffer to the RTA-TRACE client.</p><p xmlns="">The API has no effect in free-running trace mode.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_SetTraceRepeat(TRUE);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_StartBurstingTrace">Os_StartBurstingTrace</a><br /><a href="#Os_StartTriggeringTrace">Os_StartTriggeringTrace</a><br /></p><h2 xmlns=""><a name="Os_SetTriggerWindow">Os_SetTriggerWindow</a></h2><p xmlns="">Set the size of the trace buffer window to be uploaded in triggering mode.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_SetTriggerWindow(Os_TraceIndexType Before, Os_TraceIndexType After)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Before</td><td class="CodeBodyText">Os_TraceIndexType</td><td>in</td><td>Number of records to be recorded before the trigger event.</td></tr><tr><td class="CodeBodyText">After</td><td class="CodeBodyText">Os_TraceIndexType</td><td>in</td><td>Number of records to record after the trigger event.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call sets the number of records to be recorded before and after a trigger event.</p><p xmlns="">When the trigger occurs, tracing events continue to be logged until After trace records have been written to the trace buffer, and the data is then uploaded.</p><p xmlns="">The total number of records uploaded (Before + After) is limited by the size of the trace buffer.</p><p xmlns="">Note that a trace event that contains data values may require multiple records to be written to the trace buffer. This means that the number of complete events seen before or after the trigger point may be less than the number of records requested.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) StartupHook(){
  ...
  Os_SetTriggerWindow(100,50);
  Os_StartTriggeringTrace();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_StartBurstingTrace">Os_StartBurstingTrace</a><br /><a href="#Os_StartFreeRunningTrace">Os_StartFreeRunningTrace</a><br /></p><h2 xmlns=""><a name="Os_StartBurstingTrace">Os_StartBurstingTrace</a></h2><p xmlns="">Starts tracing in bursting mode.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_StartBurstingTrace(void)</p><h4 xmlns="">Description</h4><p xmlns="">Bursting trace mode logs trace information into the trace buffer until the buffer is full. When the trace buffer is full, tracing stops and data transfer begins. No attempt is made to upload data to the host until the trace buffer has filled.</p><p xmlns="">Where Os_SetTraceRepeat() has been used to enable repeated bursting traces, tracing resumes once the buffer is empty (i.e. once data transfer is complete).</p><p xmlns="">The trace buffer is cleared and tracing restarts again if this call is made while tracing.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) StartupHook(){
  ...
  Os_StartBurstingTrace();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SetTraceRepeat">Os_SetTraceRepeat</a><br /><a href="#Os_StartFreeRunningTrace">Os_StartFreeRunningTrace</a><br /><a href="#Os_StartTriggeringTrace">Os_StartTriggeringTrace</a><br /></p><h2 xmlns=""><a name="Os_StartCoreGate">Os_StartCoreGate</a></h2><p xmlns="">Control core startup.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, OS_CODE) Os_StartCoreGate(void)</p><h4 xmlns="">Description</h4><p xmlns="">In a multi-core AUTOSAR application it is necessary for the master core to control the start-up behavior of the slave cores. Ideally the slave cores should stay in reset until Os_Cbk_StartCore gets called to release them.</p><p xmlns="">Sometimes this can not be enforced (for example a debugger may not support this). For this reason, the OS provides the Os_StartCoreGate() API that should be placed at the start of 'main'.</p><p xmlns="">If a slave core is released too early, the API will cause it to spin waiting until its Os_Cbk_StartCore has been called.</p><p xmlns="">In normal usage, the OS_MAIN macro hides the call to Os_StartCoreGate. If you choose not to use OS_MAIN, then you should call Os_StartCoreGate explicitly if slave cores cannot be held in reset.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">OS_MAIN() {
  /* The OS_MAIN macro implicitly calls Os_StartCoreGate */
  ...
}

or

int main(void) {
  Os_StartCoreGate();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr /></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_StartCore">Os_Cbk_StartCore</a><br /></p><h2 xmlns=""><a name="Os_StartFreeRunningTrace">Os_StartFreeRunningTrace</a></h2><p xmlns="">Starts tracing in free-running mode.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_StartFreeRunningTrace(void)</p><h4 xmlns="">Description</h4><p xmlns="">Free running trace mode logs trace information while there is space in the trace buffer. Data is uploaded to the host from the buffer as soon as it is available, concurrently with capture.</p><p xmlns="">If the trace buffer becomes full, logging of trace data is suspended until there is space in the buffer. When space in the buffer is available again, tracing resumes. The buffer might become full if the communications link is too slow for the desired volume of trace data.</p><p xmlns="">The trace buffer is cleared and tracing restarts again if this call is made while tracing.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) StartupHook(){
  ...
  Os_StartFreeRunningTrace();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_StartBurstingTrace">Os_StartBurstingTrace</a><br /><a href="#Os_StartTriggeringTrace">Os_StartTriggeringTrace</a><br /></p><h2 xmlns=""><a name="Os_StartTriggeringTrace">Os_StartTriggeringTrace</a></h2><p xmlns="">Starts tracing in triggering mode.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_StartTriggeringTrace(void)</p><h4 xmlns="">Description</h4><p xmlns="">Triggering trace mode logs trace information into the buffer continuously, waiting for a trigger condition. If the buffer overflows, then new trace information overwrites existing information.</p><p xmlns="">A pre- and post-trigger number of buffer records must be specified using Os_SetTriggerWindow() so that only the set of events before and after the trigger event can be seen. Unpredictable behavior may occur if the trigger window is not set.</p><p xmlns="">Trigger events are set using the Os_TriggerOnXXX() APIs.</p><p xmlns="">When a triggering event occurs (for example, when a task starts executing), data collection continues until post-trigger number of trace records are logged. Data transfer to the host then begins.</p><p xmlns="">Tracing resumes after the data transfer completes if Os_SetTraceRepeat() permits this.</p><p xmlns="">The trace buffer is cleared and tracing restarts again if this call is made while tracing.</p><p xmlns="">Each core can have different trigger settings in a multicore application.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) StartupHook(){
  ...
  Os_SetTriggerWindow(100,50);
  Os_StartTriggeringTrace();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_StartBurstingTrace">Os_StartBurstingTrace</a><br /><a href="#Os_StartFreeRunningTrace">Os_StartFreeRunningTrace</a><br /><a href="#Os_SetTriggerWindow">Os_SetTriggerWindow</a><br /><a href="#Os_SetTraceRepeat">Os_SetTraceRepeat</a><br /></p><h2 xmlns=""><a name="Os_StopTrace">Os_StopTrace</a></h2><p xmlns="">Stops tracing.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_StopTrace(void)</p><h4 xmlns="">Description</h4><p xmlns="">Stops data logging to the trace buffer. Any data remaining in the trace buffer is uploaded to the host.</p><p xmlns="">Note that the call does not stop the data link.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StopTrace();
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_StartBurstingTrace">Os_StartBurstingTrace</a><br /><a href="#Os_StartFreeRunningTrace">Os_StartFreeRunningTrace</a><br /><a href="#Os_StartTriggeringTrace">Os_StartTriggeringTrace</a><br /></p><h2 xmlns=""><a name="Os_SyncScheduleTableRel">Os_SyncScheduleTableRel</a></h2><p xmlns="">Provide an adjustment value for an explicitly synchronized schedule table.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Os_SyncScheduleTableRel(ScheduleTableType ScheduleTableID, SignedTickType RelativeValue)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ScheduleTableID</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Name of the schedule table to synchronize.</td></tr><tr><td class="CodeBodyText">RelativeValue</td><td class="CodeBodyText">SignedTickType</td><td>in</td><td>Amount to adjust the synchronizing counter.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>all</td><td>ScheduleTableID is not an explicitly synchronized table.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ScheduleTableID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_VALUE</td><td>all</td><td>Value exceeds the duration of the table.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>all</td><td>The status of ScheduleTableID is SCHEDULETABLE_WAITING, SCHEDULETABLE_STOPPED or SCHEDULETABLE_NEXT.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call provides the synchronization RelativeValue for an explicitly synchronized table ScheduleTableID. ScheduleTableID must be running - you must use the SyncScheduleTable API to start it.</p><p xmlns="">Control of and knowledge about the synchronizing counter is outside the domain of the OS. The OS assumes that the synchronizing counter has a duration equal to ScheduleTableID and that the resolution of the synchronizing counter is equal to the resolution of the OS counter used to drive ScheduleTableID. It is your responsibility to verify that your application satisfies these constraints.</p><p xmlns="">When the ScheduleTableID is in the state SCHEDULETABLE_RUNNING or SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS then RelativeValue is taken to be the current deviation between the notional position on ScheduleTableID and the desired value.</p><p xmlns="">The state of ScheduleTableID is set according to the statically configured precision as follows:</p><p xmlns="">- if RelativeValue &lt;= precision then the state will be set to SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS</p><p xmlns="">- if RelativeValue &gt; precision then the state will be set to SCHEDULETABLE_RUNNING</p><p xmlns="">A positive RelativeValue that exceeds the configured precision will result in the entering the OS_SYNC_RETARDING state (ticks are removed).</p><p xmlns="">A negative RelativeValue that exceeds the configured precision will result in the entering the OS_SYNC_ADVANCING state (extra ticks are inserted).</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  StartScheduleTableSynchron(MyScheduleTable);
  ...
  Os_SyncScheduleTable(MyScheduleTable, 0); /* Start */
  ...
  Os_SyncScheduleTableRel(MyScheduleTable, -2); /* Adjust drift */
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#GetScheduleTableStatus">GetScheduleTableStatus</a><br /><a href="#NextScheduleTable">NextScheduleTable</a><br /><a href="#StartScheduleTableRel">StartScheduleTableRel</a><br /><a href="#StartScheduleTableAbs">StartScheduleTableAbs</a><br /><a href="#StartScheduleTableSynchron">StartScheduleTableSynchron</a><br /><a href="#StopScheduleTable">StopScheduleTable</a><br /><a href="#SetScheduleTableAsync">SetScheduleTableAsync</a><br /><a href="#SyncScheduleTable">SyncScheduleTable</a><br /></p><h2 xmlns=""><a name="Os_TimingFaultDetected">Os_TimingFaultDetected</a></h2><p xmlns="">Report detection of a timing protection fault.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TimingFaultDetected(void)</p><h4 xmlns="">Description</h4><p xmlns="">When timing protection is configured and a timing interrupt is being used to enforce time limits, the timing interrupt must call this API whenever it runs.</p><p xmlns="">The timing interrupt must run whenever the time limit that was set by the most recent call to Os_Cbk_SetTimeLimit() has been reached - unless a subsequent call to Os_Cbk_SuspendTimeLimit() has occurred to cancel it.</p><p xmlns="">The timing interrupt must be a Category 1 ISR, and it should have priority higher than the highest Category 2 ISR. It is recommended that no other Category 1 ISRs are used. If you must have some, you should ensure that the timing interrupt cannot preempt them.</p><p xmlns="">The OS responds to this call by calling ProtectionHook which means that it will normally not return to the timing interrupt. You must therefore perform any interrupt cleanup code that is needed before calling Os_TimingFaultDetected().</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CAT1_ISR(timing_interrupt) {
  /* Reset pending interrupt flags here if needed */
  Os_TimingFaultDetected();
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_SetTimeLimit">Os_Cbk_SetTimeLimit</a><br /><a href="#Os_Cbk_SuspendTimeLimit">Os_Cbk_SuspendTimeLimit</a><br /><a href="#ProtectionHook">ProtectionHook</a><br /></p><h2 xmlns=""><a name="Os_TraceCommInit">Os_TraceCommInit</a></h2><p xmlns="">Initializes external communication support for tracing.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">Os_TraceStatusType Os_TraceCommInit(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_TraceStatusType</p><h4 xmlns="">Description</h4><p xmlns="">This function is used to initialize a trace communications link. It should not be used if you use a debugger link to extract trace data.</p><p xmlns="">It calls the callback Os_Cbk_TraceCommInitTarget() to initialize the appropriate target hardware and its return value indicates the return value from the call to Os_Cbk_TraceCommInitTarget().</p><p xmlns="">RTA-OS will call this during StartOS if automatic tracing is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) StartupHook() {
  ...
  Os_TraceCommInit();
  Os_StartFreeRunningTrace();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_TraceCommInitTarget">Os_Cbk_TraceCommInitTarget</a><br /></p><h2 xmlns=""><a name="Os_TraceDumpAsync">Os_TraceDumpAsync</a></h2><p xmlns="">Uses an asynchronous communication to upload trace data in a single operation.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TraceDumpAsync(Os_AsyncPushCallbackType fn)</p><h4 xmlns="">Description</h4><p xmlns="">This API is normally called in response to Os_Cbk_TraceCommDataReady(). It gets passed a reference to a function that can transmit a single character. It will call this function for each character that needs to be transmitted before returning to the caller.</p><p xmlns="">An appropriate asynchronous serial device must be available and previously initialized. A typical serial link might be set to 115200bps, 8 data bits, no parity and 1 stop bit.</p><p xmlns="">This API will only upload trace data for the core that calls it. If you have more than one core tracing data, each one needs to call this independently.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, OS_CODE) push_async_io(uint8 val) {
  while(!async_tx_ready) {/* wait for room */}
  async_transmit(val)  ;
}
FUNC(void, {memclass}) Os_Cbk_TraceCommDataReady(void) {
  Os_TraceDumpAsync(push_async_io);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_TraceCommDataReady">Os_Cbk_TraceCommDataReady</a><br /></p><h2 xmlns=""><a name="Os_TriggerNow">Os_TriggerNow</a></h2><p xmlns="">Trigger upload of the trace buffer.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerNow(void)</p><h4 xmlns="">Description</h4><p xmlns="">This API call forces a trigger condition to occur. This will cause the trace buffer to be uploaded, regardless of any other trigger conditions.</p><p xmlns="">The call does not modify the state of the trigger conditions.</p><p xmlns="">The call only has an effect in triggering trace mode.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerNow();
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns="" /><h2 xmlns=""><a name="Os_TriggerOnActivation">Os_TriggerOnActivation</a></h2><p xmlns="">Trigger when a task is activated.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnActivation(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Identifier of the task to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when specified task is activated.</p><p xmlns="">TaskID can be set to OS_TRIGGER_ANY, in which case activation of any task will cause the trigger to occur.</p><p xmlns="">The trigger will occur when a task is activated through ActivateTask, StartOS, Alarms or ScheduleTables.</p><p xmlns="">Note that ChainTask(TaskID) does not cause an activation trigger; see Os_TriggerOnChain().</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnActivation(InterestingTask);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnChain">Os_TriggerOnChain</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnAdvanceCounter">Os_TriggerOnAdvanceCounter</a></h2><p xmlns="">Trigger when a counter is advanced.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnAdvanceCounter(CounterType CounterID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CounterID</td><td class="CodeBodyText">CounterType</td><td>in</td><td>Identifier of the hardware counter that triggers on advance.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified hardware counter is advanced.</p><p xmlns="">CounterID can be set to OS_TRIGGER_ANY, in which case advancing any counter will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnAdvanceCounter(HWCounter);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnIncrementCounter">Os_TriggerOnIncrementCounter</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnAlarmExpiry">Os_TriggerOnAlarmExpiry</a></h2><p xmlns="">Trigger when an alarm expires.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnAlarmExpiry(AlarmType AlarmID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">AlarmID</td><td class="CodeBodyText">AlarmType</td><td>in</td><td>Identifier of the alarm.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified alarm expires.</p><p xmlns="">AlarmID can be set to OS_TRIGGER_ANY, in which case any alarm expiry or *expiry point* will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnAlarmExpiry(Alarm_10ms);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns="" /><h2 xmlns=""><a name="Os_TriggerOnCat1ISRStart">Os_TriggerOnCat1ISRStart</a></h2><p xmlns="">Trigger when a Category 1 ISR starts.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnCat1ISRStart(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>Identifier of the Category 1 ISR to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified Category 1 ISR starts running.</p><p xmlns="">ISRID can be set to OS_TRIGGER_ANY, in which case any such ISR will cause the trigger to occur.</p><p xmlns="">Note that Category 1 ISRs are not controlled by RTA-OS, so you are responsible for calling Os_LogCat1ISRStart() at the beginning of your interrupt handler.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnCat1ISRStart(InterestingCat1ISR);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnCat1ISRStop">Os_TriggerOnCat1ISRStop</a><br /><a href="#Os_LogCat1ISREnd">Os_LogCat1ISREnd</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnCat1ISRStop">Os_TriggerOnCat1ISRStop</a></h2><p xmlns="">Trigger when a Category 1 ISR stops.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnCat1ISRStop(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>Identifier of the Category 1 ISR to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified Category 1 ISR stops running.</p><p xmlns="">ISRID can be set to OS_TRIGGER_ANY, in which case any such ISR will cause the trigger to occur.</p><p xmlns="">Note that Category 1 ISRs are not controlled by RTA-OS, so you are responsible for calling Os_LogCat1ISREnd() at the end of your interrupt handler.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnCat1ISRStop(InterestingCat1ISR);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnCat1ISRStart">Os_TriggerOnCat1ISRStart</a><br /><a href="#Os_LogCat1ISRStart">Os_LogCat1ISRStart</a><br /><a href="#Os_LogCat1ISREnd">Os_LogCat1ISREnd</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnCat2ISRStart">Os_TriggerOnCat2ISRStart</a></h2><p xmlns="">Trigger when a Category 2 ISR starts.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnCat2ISRStart(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>Identifier of the Category 2 ISR to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified Category 2 ISR starts running.</p><p xmlns="">ISRID can be set to OS_TRIGGER_ANY, in which case any such ISR will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnCat2ISRStart(InterestingCat2ISR);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnCat2ISRStop">Os_TriggerOnCat2ISRStop</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnCat2ISRStop">Os_TriggerOnCat2ISRStop</a></h2><p xmlns="">Trigger when a Category 2 ISR stops.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnCat2ISRStop(ISRType ISRID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>Identifier of the Category 2 ISR to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified Category 2 ISR stops running.</p><p xmlns="">ISRID can be set to OS_TRIGGER_ANY, in which case any such ISR will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnCat2ISRStop(InterestingCat2ISR);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnCat2ISRStart">Os_TriggerOnCat2ISRStart</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnChain">Os_TriggerOnChain</a></h2><p xmlns="">Trigger when a task is chained.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnChain(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Identifier of the task to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when an attempt is made to chain a specified task. (Noting that chain attempts can fail.)</p><p xmlns="">TaskID can be set to OS_TRIGGER_ANY, in which case chaining of any task will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnChain(InterestingTask);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnActivation">Os_TriggerOnActivation</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnError">Os_TriggerOnError</a></h2><p xmlns="">Trigger when an error occurs.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnError(StatusType Error)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Error</td><td class="CodeBodyText">StatusType</td><td>in</td><td>Identifier of the error to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified error is raised.</p><p xmlns="">Error can be set to OS_TRIGGER_ANY, in which case any error will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnError(E_OS_LIMIT);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns="" /><h2 xmlns=""><a name="Os_TriggerOnGetResource">Os_TriggerOnGetResource</a></h2><p xmlns="">Trigger when a resource is locked.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnGetResource(ResourceType ResourceID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ResourceID</td><td class="CodeBodyText">ResourceType</td><td>in</td><td>Identifier of the resource to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified resource is locked.</p><p xmlns="">ResourceID can be set to OS_TRIGGER_ANY, in which case any resource lock will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnGetResource(CriticalSection);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnReleaseResource">Os_TriggerOnReleaseResource</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnIncrementCounter">Os_TriggerOnIncrementCounter</a></h2><p xmlns="">Trigger when a counter is incremented.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnIncrementCounter(CounterType CounterID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CounterID</td><td class="CodeBodyText">CounterType</td><td>in</td><td>Identifier of the software counter.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified counter is incremented.</p><p xmlns="">CounterID can be set to OS_TRIGGER_ANY, in which case any counter increment will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnIncrementCounter(SWCounter);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnAdvanceCounter">Os_TriggerOnAdvanceCounter</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnIntervalEnd">Os_TriggerOnIntervalEnd</a></h2><p xmlns="">Trigger when a trace interval ends.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnIntervalEnd(Os_TraceIntervalIDType IntervalID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">IntervalID</td><td class="CodeBodyText">Os_TraceIntervalIDType</td><td>in</td><td>Identifier of the interval to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified interval ends.</p><p xmlns="">IntervalID can be set to OS_TRIGGER_ANY, in which case any interval end will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnIntervalEnd(EndToEndTimeMeasurement);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnIntervalStart">Os_TriggerOnIntervalStart</a><br /><a href="#Os_TriggerOnIntervalStop">Os_TriggerOnIntervalStop</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnIntervalStart">Os_TriggerOnIntervalStart</a></h2><p xmlns="">Trigger when a trace interval is started.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnIntervalStart(Os_TraceIntervalIDType IntervalID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">IntervalID</td><td class="CodeBodyText">Os_TraceIntervalIDType</td><td>in</td><td>Identifier of the interval to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified interval starts.</p><p xmlns="">IntervalID can be set to OS_TRIGGER_ANY, in which case any interval start will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnIntervalStart(EndToEndTimeMeasurement);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr /></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnIntervalEnd">Os_TriggerOnIntervalEnd</a><br /><a href="#Os_TriggerOnIntervalStop">Os_TriggerOnIntervalStop</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnIntervalStop">Os_TriggerOnIntervalStop</a></h2><p xmlns="">Trigger when a trace interval ends.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnIntervalStop(Os_TraceIntervalIDType IntervalID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">IntervalID</td><td class="CodeBodyText">Os_TraceIntervalIDType</td><td>in</td><td>Identifier of the interval to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call is a synonym for Os_TriggerOnIntervalEnd.</p><p xmlns="">It causes a trace trigger to occur when a specified interval ends.</p><p xmlns="">IntervalID can be set to OS_TRIGGER_ANY, in which case any interval end will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnIntervalStop(EndToEndTimeMeasurement);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnIntervalEnd">Os_TriggerOnIntervalEnd</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnReleaseResource">Os_TriggerOnReleaseResource</a></h2><p xmlns="">Trigger when a resource is unlocked.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnReleaseResource(ResourceType ResourceID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ResourceID</td><td class="CodeBodyText">ResourceType</td><td>in</td><td>Identifier of the resource to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified resource is unlocked.</p><p xmlns="">ResourceID can be set to OS_TRIGGER_ANY, in which case any resource unlock will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnReleaseResource(CriticalSection);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnGetResource">Os_TriggerOnGetResource</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnScheduleTableExpiry">Os_TriggerOnScheduleTableExpiry</a></h2><p xmlns="">Trigger when a specified expiry point expires.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnScheduleTableExpiry(ExpiryID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ExpiryID</td><td class="CodeBodyText">Os_TraceExpiryIDType</td><td>in</td><td>Identifier of the expiry to trigger on. The ExpiryID is formed by combining the name of the ScheduleTable and Expiry with an underscore character.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specific expiry point is reached.</p><p xmlns="">ExpiryID can be set to OS_TRIGGER_ANY, in which case any expiry *or alarm* will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">StartScheduleTableRel(SchedTable, 1);
Os_TriggerOnScheduleTableExpiry(SchedTable_ep1);
IncrementCounter(SystemCounter);
...
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns="" /><h2 xmlns=""><a name="Os_TriggerOnSetEvent">Os_TriggerOnSetEvent</a></h2><p xmlns="">Trigger when an event is set for a task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnSetEvent(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Identifier of the task to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when an event is set for a specified task.</p><p xmlns="">TaskID can be set to OS_TRIGGER_ANY, in which case any event setting will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnSetEvent(ExtendedTask);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns="" /><h2 xmlns=""><a name="Os_TriggerOnShutdown">Os_TriggerOnShutdown</a></h2><p xmlns="">Trigger when the OS is shutdown.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnShutdown(StatusType Status)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Status</td><td class="CodeBodyText">StatusType</td><td>in</td><td>Identifier of the shutdown exit code.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specific status is passed to ShutdownOS.</p><p xmlns="">Status can be set to OS_TRIGGER_ANY, in which case status value passed to ShutdownOS will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnShutdown(E_OK); /* Trigger on normal shutdown */
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ShutdownOS">ShutdownOS</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnTaskStart">Os_TriggerOnTaskStart</a></h2><p xmlns="">Trigger when a task is started.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnTaskStart(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Identifier of the task to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified task starts running.</p><p xmlns="">TaskID can be set to OS_TRIGGER_ANY, in which case any task start will cause the trigger to occur.</p><p xmlns="">Note that a TaskID is started when its entry function is called, or when it resumes from the WAITING state.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnTaskStart(InterestingTask);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnTaskStop">Os_TriggerOnTaskStop</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnTaskStop">Os_TriggerOnTaskStop</a></h2><p xmlns="">Trigger when a task is stopped.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnTaskStop(TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Identifier of the task to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified task stops running.</p><p xmlns="">TaskID can be set to OS_TRIGGER_ANY, in which case any task stop will cause the trigger to occur.</p><p xmlns="">Note that a TaskID is stopped when its entry function is called, or when it enters the WAITING state.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnTaskStop(InterestingTask);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnTaskStart">Os_TriggerOnTaskStart</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnTaskTracepoint">Os_TriggerOnTaskTracepoint</a></h2><p xmlns="">Trigger when a task tracepoint is logged.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnTaskTracepoint(Os_TraceTracepointIDType TaskTracepointID, TaskType TaskID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskTracepointID</td><td class="CodeBodyText">Os_TraceTracepointIDType</td><td>in</td><td>Identifier of the tracepoint to trigger on.</td></tr><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Identifier of the task.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified task-tracepoint for a specified task is logged.</p><p xmlns="">TaskID can be set to OS_TRIGGER_ANY, in which any task-tracepoint with the specified value will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnTaskTracepoint(MyTaskTracepoint,InterestingTask);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnTracepoint">Os_TriggerOnTracepoint</a><br /></p><h2 xmlns=""><a name="Os_TriggerOnTracepoint">Os_TriggerOnTracepoint</a></h2><p xmlns="">Trigger when a tracepoint is logged.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_TriggerOnTracepoint(Os_TraceTracepointIDType TracepointID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TracepointID</td><td class="CodeBodyText">Os_TraceTracepointIDType</td><td>in</td><td>Identifier of the tracepoint to trigger on.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Causes a trace trigger to occur when a specified tracepoint is logged.</p><p xmlns="">TracepointID can be set to OS_TRIGGER_ANY, in which any tracepoint will cause the trigger to occur.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TriggerOnTracepoint(MyTracepoint);
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TriggerOnTaskTracepoint">Os_TriggerOnTaskTracepoint</a><br /></p><h2 xmlns=""><a name="Os_UploadTraceData">Os_UploadTraceData</a></h2><p xmlns="">Uses asynchronous communication to upload trace data a byte at a time.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void Os_UploadTraceData(void)</p><h4 xmlns="">Description</h4><p xmlns="">This API is responsible for sending individual bytes of trace data over a serial communications link. It uses callbacks into the application code to manage access to the actual communications link.</p><p xmlns="">In polled mode, it is necessary to call this function frequently enough to ensure data is transmitted in a timely manner.</p><p xmlns="">As a special case in interrupt mode, this function should be called from the Os_Cbk_TraceCommDataReady() callback and the transmit-interrupt handler.</p><p xmlns="">An appropriate asynchronous serial device must be available and previously initialized. A typical serial link might be set to 115200bps, 8 data bits, no parity and 1 stop bit.</p><p xmlns="">NOTE: This API should only be called from trusted OS Application code. This is for reasons of efficiency.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">/* This callback occurs when a new frame is ready for upload */
FUNC(void, {memclass}) Os_Cbk_TraceCommDataReady(void) {
  Os_UploadTraceData(); /* Causes call to Os_Cbk_TraceCommTxStart() */
}
ISR(asyncio) {
  Os_UploadTraceData();
}
FUNC(void, {memclass}) Os_Cbk_TraceCommTxStart(void) {
  /* Called from UploadTraceData when the first byte of a frame is ready to send.
   * It is immediately followed by a call to Os_Cbk_TraceCommTxByte().
   * In interrupt mode, this is used to enable the transmit interrupt.
   */
  enable_asyncio_interrupt();
}
FUNC(void, {memclass}) Os_Cbk_TraceCommTxByte(uint8 val) {
  /* Called from UploadTraceData when there is a byte ready to send */
  async_transmit(val);
}
FUNC(void, {memclass}) Os_Cbk_TraceCommTxEnd(void)  {
  /* Called from UploadTraceData when the last byte of data has been sent*/
  disable_asyncio_interrupt();
}
FUNC(boolean, {memclass}) Os_Cbk_TraceCommTxReady(void) {
  /* Called from UploadTraceData to determine whether there is room in the transmit buffer */
  /* This should always return true in interrupt mode, because the interrupt should only
   * fire when there is room to send the next byte. */
  return async_tx_ready();
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_CheckTraceOutput">Os_CheckTraceOutput</a><br /><a href="#Os_Cbk_TraceCommDataReady">Os_Cbk_TraceCommDataReady</a><br /><a href="#Os_Cbk_TraceCommTxStart">Os_Cbk_TraceCommTxStart</a><br /><a href="#Os_Cbk_TraceCommTxByte">Os_Cbk_TraceCommTxByte</a><br /><a href="#Os_Cbk_TraceCommTxEnd">Os_Cbk_TraceCommTxEnd</a><br /><a href="#Os_Cbk_TraceCommTxReady">Os_Cbk_TraceCommTxReady</a><br /></p><h2 xmlns=""><a name="ReleaseResource">ReleaseResource</a></h2><p xmlns="">Release (unlock) a previously held resource to leave a critical section.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType ReleaseResource(ResourceType ResID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ResID</td><td class="CodeBodyText">ResourceType</td><td>in</td><td>The resource to release.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ResID is not a valid resource.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ResID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>Attempt to release a resource which has a lower ceiling priority than the configured priority of the calling task/ISR.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_RESOURCE</td><td>extended</td><td>Called where a new Spinlock was acquired after this resource was locked. Spinlocks and Resources can only be locked and unlocked in strict LIFO order.</td></tr><tr><td class="CodeBodyText">E_OS_NOFUNC</td><td>extended</td><td>The resource is not occupied.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">ReleaseResource is the counterpart of GetResource and serves to quit a critical section in the code.</p><p xmlns="">Resources can not be configured to work across different cores.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  GetResource(Outer);
    /* Outer Critical Section */
    ...
    GetResource(Inner);
      /* Inner Critical Section */
    ReleaseResource(Inner);
    ...
  ReleaseResource(Outer);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareResource">DeclareResource</a><br /><a href="#GetResource">GetResource</a><br /></p><h2 xmlns=""><a name="ReleaseSpinlock">ReleaseSpinlock</a></h2><p xmlns="">ReleaseSpinlock is used to release a spin-lock variable.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">ReleaseSpinlock(SpinlockIdType SpinlockId)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">SpinlockId</td><td class="CodeBodyText">SpinlockIdType</td><td>in</td><td>The Spinlock to release.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>SpinlockId does not refer to a valid Spinlock.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>The Spinlock is not occupied by the calling TASK or ISR.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>SpinlockId is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_NOFUNC</td><td>extended</td><td>A different Spinlock must be released first. Nesting order of Spinlock GetSpinlock/ReleaseSpinlock must be maintained.</td></tr><tr><td class="CodeBodyText">E_OS_RESOURCE</td><td>extended</td><td>A Resource must be released first. Nesting order of Spinlocks and Resources must be maintained.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_RESOURCE</td><td>extended</td><td>Called where a new Resource was locked after this spinlock was acquired. Spinlocks and Resources can only be locked and unlocked in strict LIFO order.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">ReleaseSpinlock is used to release a spinlock that was previously occupied using GetSpinLock or TryToGetSpinLock.</p><p xmlns="">All spinlocks must be released before a Task or ISR terminate.</p><p xmlns="">All spinlocks must be released before an ECC Task calls WaitEvent.</p><p xmlns="">When the spinlock has a lock method with LOCK_ALL_INTERRUPTS semantics, this API will exit with a call to ResumeAllInterrupts().</p><p xmlns="">When the spinlock has a lock method with LOCK_CAT2_INTERRUPTS semantics, this API will exit with a call to ResumeOSInterrupts().</p><p xmlns="">When the spinlock has a lock method with LOCK_WITH_RES_SCHEDULER semantics, this API will exit with a call to ReleaseResource(RES_SCHEDULER).</p><p xmlns="">When the spinlock has a lock method with NESTABLE semantics, this API will only perform the unlock when called by the original locker, and only then when it has made the same number of Release calls as Get calls.</p><p xmlns="">Note that the OS configuration option 'Force spinlock error checks' can be used to cause the error checks to be done in standard as well as extended status builds.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  GetSpinlock(Spinlock1);
  ...
  ReleaseSpinlock(Spinlock1);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TryToGetSpinlock">TryToGetSpinlock</a><br /><a href="#GetSpinLock">GetSpinLock</a><br /><a href="#ResumeAllInterrupts">ResumeAllInterrupts</a><br /><a href="#ResumeOSInterrupts">ResumeOSInterrupts</a><br /><a href="#ReleaseResource">ReleaseResource</a><br /><a href="#UncheckedGetSpinlock">UncheckedGetSpinlock</a><br /><a href="#UncheckedTryToGetSpinlock">UncheckedTryToGetSpinlock</a><br /><a href="#UncheckedReleaseSpinlock">UncheckedReleaseSpinlock</a><br /></p><h2 xmlns=""><a name="ResetSpinlockInfo">ResetSpinlockInfo</a></h2><p xmlns="">Reset run-time statistics for a Spinlock.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType ResetSpinlockInfo(SpinlockIdType SpinlockId)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">SpinlockId</td><td class="CodeBodyText">SpinlockIdType</td><td>in</td><td>The Spinlock</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>SpinlockId does not refer to a valid Spinlock.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">ResetSpinlockInfo is an optional API that is only available when there are spinlocks in the application and the OS option 'Provide spinlock statistics' is set to true.</p><p xmlns="">It is used to reset the statistics belonging to the specified spinlock to all zero values.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  Os_SpinlockInfo Info;
  ResetSpinlockInfo(Spinlock1);
  ...
  GetSpinlock(Spinlock1);
  GetSpinlockInfo(Spinlock1, &amp;Info);
  if ((TaskType)Info.LockFails &gt; 0) {
    ...
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SpinlockInfo">Os_SpinlockInfo</a><br /><a href="#GetSpinlockInfo">GetSpinlockInfo</a><br /></p><h2 xmlns=""><a name="ResumeAllInterrupts">ResumeAllInterrupts</a></h2><p xmlns="">Resume recognition of Category 1 and Category 2 interrupts.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void ResumeAllInterrupts(void)</p><h4 xmlns="">Description</h4><p xmlns="">This API call marks the end of a critical section that is protected from any maskable interrupt occurring. The critical section must have been entered using the SuspendAllInterrupts() call.</p><p xmlns="">No API calls beside SuspendAllInterrupts()/ResumeAllInterrupts() pairs and SuspendOSInterrupts()/ResumeOSInterrupts() pairs are allowed within this critical section.</p><p xmlns="">Interrupt processing is restored to that in effect before the immediately prior SuspendAllInterrupts() call.</p><p xmlns="">When calls to SuspendAllInterrupts() and ResumeAllInterrupts() are nested then the interrupt recognition status saved by the first call of SuspendAllInterrupts() is restored by the last call of the ResumeAllInterrupts().</p><p xmlns="">In a multicore environment, this call only affects the interrupts on the core that it is called from.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  SuspendAllInterrupts():
    /* Critical Section 1 */
    FunctionWithNestedCriticalSection();
  ResumeAllInterrupts():
  ...
}
void FunctionWithNestedCriticalSection(void) {
  ...
  SuspendAllInterrupts():
  /* Critical Section 2 */
  ResumeAllInterrupts():
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DisableAllInterrupts">DisableAllInterrupts</a><br /><a href="#EnableAllInterrupts">EnableAllInterrupts</a><br /><a href="#ResumeOSInterrupts">ResumeOSInterrupts</a><br /><a href="#SuspendAllInterrupts">SuspendAllInterrupts</a><br /><a href="#SuspendOSInterrupts">SuspendOSInterrupts</a><br /></p><h2 xmlns=""><a name="ResumeOSInterrupts">ResumeOSInterrupts</a></h2><p xmlns="">Resume recognition of Category 2 interrupts</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void ResumeOSInterrupts(void)</p><h4 xmlns="">Description</h4><p xmlns="">This API call marks the end of a critical section that is protected from any Category 2 (OS level) interrupt occurring. The critical section must have been entered using the SuspendOSInterrupts() call.</p><p xmlns="">No API calls beside SuspendAllInterrupts()/ResumeAllInterrupts() pairs and SuspendOSInterrupts()/ResumeOSInterrupts() pairs are allowed within this critical section.</p><p xmlns="">Interrupt processing is restored to that in effect before the immediately prior SuspendOSInterrupts() call.</p><p xmlns="">When calls to SuspendOSInterrupts() and ResumeOSInterrupts() are nested then the interrupt recognition status saved by the first call of SuspendOSInterrupts() is restored by the last call of the ResumeOSInterrupts().</p><p xmlns="">In a multicore environment, this call only affects the interrupts on the core that it is called from.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  SuspendOSInterrupts():
    /* Longer Critical Section */
    SuspendAllInterrupts();
      /* Shorter Critical Section  */
    ResumeAllInterrupts();
  ResumeOSInterrupts():
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DisableAllInterrupts">DisableAllInterrupts</a><br /><a href="#EnableAllInterrupts">EnableAllInterrupts</a><br /><a href="#ResumeAllInterrupts">ResumeAllInterrupts</a><br /><a href="#SuspendAllInterrupts">SuspendAllInterrupts</a><br /><a href="#SuspendOSInterrupts">SuspendOSInterrupts</a><br /></p><h2 xmlns=""><a name="Schedule">Schedule</a></h2><p xmlns="">Forces the OS to check if a higher priority task can be run.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType Schedule(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_RESOURCE</td><td>extended</td><td>Calling task still holds resources.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called at interrupt level.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_SPINLOCK</td><td>extended</td><td>Called while the task holds a Spinlock</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The call allows a non-preemptive task or a task/ISR that uses an internal resource to offer a preemption point.</p><p xmlns="">Rescheduling occurs if:</p><p xmlns="">1.    The calling task is non-preemptive and a higher priority task has been activated while the calling task was in the running state.</p><p xmlns="">2.    The calling task/ISR shares an internal resource with a higher priority task/ISR and that higher priority task/ISR has been activated.</p><p xmlns="">If no higher-priority task/ISR is in the ready state the calling task/ISR resumes.</p><p xmlns="">This service has no influence on preemptive tasks or ISRs that do not use internal resources.</p><p xmlns="">Note that allowing ISRs to share internal resources is an RTA-OS specific feature.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  CooperativeProcessA();
  Schedule();
  CooperativeProcessB();
  Schedule();
  CooperativeProcessC();
  Schedule();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareTask">DeclareTask</a><br /><a href="#TerminateTask">TerminateTask</a><br /><a href="#GetTaskState">GetTaskState</a><br /><a href="#GetTaskID">GetTaskID</a><br /></p><h2 xmlns=""><a name="SetAbsAlarm">SetAbsAlarm</a></h2><p xmlns="">Set an alarm for an absolute counter value.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType SetAbsAlarm(AlarmType AlarmID, TickType start, TickType cycle)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">AlarmID</td><td class="CodeBodyText">AlarmType</td><td>in</td><td>Name of the alarm to set.</td></tr><tr><td class="CodeBodyText">start</td><td class="CodeBodyText">TickType</td><td>in</td><td>Absolute tick value at which the alarm is first triggered.</td></tr><tr><td class="CodeBodyText">cycle</td><td class="CodeBodyText">TickType</td><td>in</td><td>Ticks before the alarm is triggered subsequently..</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>all</td><td>AlarmID already running.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>AlarmID is not a valid alarm.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>AlarmID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_VALUE</td><td>extended</td><td>The value of start or cycle is outside the permitted range. 0 &lt;= increment &lt;= maxallowedvalue. cycle = 0 or mincycle &lt;= cycle &lt;= maxallowedvalue.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call starts an alarm running and sets the match value with the associated counter that triggers the alarm.</p><p xmlns="">If cycle is equal to zero then the alarm will be triggered once only. If cycle is nonzero then the alarm will be triggered every cycle ticks after start.</p><p xmlns="">When the alarm expires, the statically configured action (activate a task / set an event / run an alarm callback / increment a counter) occurs.</p><p xmlns="">You must cancel an alarm if it is running before you can restart it with different values.</p><p xmlns="">Note that if the value of start is less than or equal to the current counter value then AlarmID will not be triggered until a full wrap of the underlying counter.</p><p xmlns="">In particular, note that if an absolute alarm is set at startup with a start of zero - SetAbsAlarm(MyAlarm,0,x) - then the alarm will not be triggered until maxallowedvalue+1 ticks of the counter have elapsed.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  /* SingleShotAlarm at tick 42 */
  SetAbsAlarm(SingleShotAlarm, 42, 0);
  ...
  /* PeriodicAlarm at 10, 60, 110, 160,... */
  SetAbsAlarm(PeriodicAlarm, 10, 50);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CancelAlarm">CancelAlarm</a><br /><a href="#DeclareAlarm">DeclareAlarm</a><br /><a href="#GetAlarm">GetAlarm</a><br /><a href="#GetAlarmBase">GetAlarmBase</a><br /><a href="#SetRelAlarm">SetRelAlarm</a><br /></p><h2 xmlns=""><a name="SetEvent">SetEvent</a></h2><p xmlns="">Set event(s) for a task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType SetEvent(TaskType TaskID, EventMaskType Mask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>Name of the Task to set the Event for.</td></tr><tr><td class="CodeBodyText">Mask</td><td class="CodeBodyText">EventMaskType</td><td>in</td><td>A mask of events to set.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_CORE</td><td>all</td><td>The task belongs to a core that is stopped (in Shutdown).</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>TaskID is not a valid task.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>TaskID is not an extended task.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>TaskID is in the suspended state.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This API call sets events for task TaskID according to Mask.</p><p xmlns="">If the task is waiting for any event in Event, it is immediately transferred to the ready state and re-scheduling can occur.</p><p xmlns="">Multiple events can be set simultaneously by logically bitwise or-ing events.</p><p xmlns="">Any unset events in the event mask remain unchanged.</p><p xmlns="">Events cannot be set for extended tasks that are in the suspended state. In extended status this results in the error E_OS_STATE. In standard status, setting an event for a suspended task has no effect.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask) {
  ...
  /* Set a single event */
  SetEvent(MyExtendedTask, Event1);
  ...
  /* Set multiple events */
  SetEvent(MyOtherExtendedTask, Event1 | Event2 | Event3);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ClearEvent">ClearEvent</a><br /><a href="#DeclareEvent">DeclareEvent</a><br /><a href="#SetEvent">SetEvent</a><br /><a href="#WaitEvent">WaitEvent</a><br /></p><h2 xmlns=""><a name="SetRelAlarm">SetRelAlarm</a></h2><p xmlns="">Set an alarm for a relative counter value.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType SetRelAlarm(AlarmType AlarmID, TickType increment, TickType cycle)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">AlarmID</td><td class="CodeBodyText">AlarmType</td><td>in</td><td>Name of the alarm to set.</td></tr><tr><td class="CodeBodyText">increment</td><td class="CodeBodyText">TickType</td><td>in</td><td>Relative number of ticks before the alarm is first triggered.</td></tr><tr><td class="CodeBodyText">cycle</td><td class="CodeBodyText">TickType</td><td>in</td><td>Ticks before the alarm is triggered subsequently.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>all</td><td>AlarmID already running.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>AlarmID is not a valid alarm.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>AlarmID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_VALUE</td><td>extended</td><td>The value of increment or cycle is outside the permitted range. 0 &lt; increment &lt;= maxallowedvalue. cycle =0 or mincycle &lt;= cycle &lt;= maxallowedvalue.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call starts an alarm running and sets the match value with the associated counter that triggers the alarm. The match value is equal to the current counter value plus the increment.</p><p xmlns="">If cycle is equal to zero then the alarm will be triggered once only. If cycle is nonzero then the alarm will be triggered every cycle ticks after start.</p><p xmlns="">When the alarm expires, the statically configured action (activate a task / set an event / run an alarm callback / increment a counter) occurs.</p><p xmlns="">You must cancel an alarm if it is running before you can restart it with different values.</p><p xmlns="">Care must be taken when the value of increment is small because the outcome of SetRelAlarm() can produce different results depending on whether the counter has ticked past the match value before the call completes. It will either result in the alarm expiring almost immediately or when the value is reached again (after the next wrap of the underlying counter).</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  /* SingleShotAlarm in Now+123 ticks */
  SetRelAlarm(SingleShotAlarm, 123, 0);
  ...
  /* PeriodicAlarm at Now+42, Now+142, Now+242... */
  SetRelAlarm(PeriodicAlarm, 42, 100);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CancelAlarm">CancelAlarm</a><br /><a href="#DeclareAlarm">DeclareAlarm</a><br /><a href="#GetAlarm">GetAlarm</a><br /><a href="#GetAlarmBase">GetAlarmBase</a><br /><a href="#SetAbsAlarm">SetAbsAlarm</a><br /></p><h2 xmlns=""><a name="SetScheduleTableAsync">SetScheduleTableAsync</a></h2><p xmlns="">Cancels synchronization on a schedule table.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType SetScheduleTableAsync(ScheduleTableType ScheduleTableID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ScheduleTableID</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Name of the schedule table.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ScheduleTableID is invalid or is not an explicitly synchronized table.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>The current state of ScheduleTableID is not SCHEDULETABLE_STOPPED, SCHEDULETABLE_NEXT or SCHEDULETABLE_WAITING.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ScheduleTableID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call sets the status of ScheduleTableID to SCHEDULETABLE_RUNNING if and only if ScheduleTableID is running and is configured as explicitly synchronized.</p><p xmlns="">The OS will continue to process expiry points on ScheduleTableID, but will stop expiry point synchronization until a SyncScheduleTable() or SyncScheduleTableRel() call is subsequently made.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  StartScheduleTableRel(MyScheduleTable, 2U);
  ...
  SyncScheduleTable(MyScheduleTable, 12U);
  ...
  SetScheduleTableAsync(MyScheduleTable);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#GetScheduleTableStatus">GetScheduleTableStatus</a><br /><a href="#NextScheduleTable">NextScheduleTable</a><br /><a href="#StartScheduleTableRel">StartScheduleTableRel</a><br /><a href="#StartScheduleTableAbs">StartScheduleTableAbs</a><br /><a href="#StartScheduleTableSynchron">StartScheduleTableSynchron</a><br /><a href="#StopScheduleTable">StopScheduleTable</a><br /><a href="#SyncScheduleTable">SyncScheduleTable</a><br /><a href="#Os_SyncScheduleTableRel">Os_SyncScheduleTableRel</a><br /></p><h2 xmlns=""><a name="ShutdownAllCores">ShutdownAllCores</a></h2><p xmlns="">Shutdown all AUTOSAR cores.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void ShutdownAllCores(StatusType Error)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Error</td><td class="CodeBodyText">StatusType</td><td>in</td><td>The reason for the shutdown.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">In a multicore configuration, ShutdownAllCores causes a synchronized shutdown of all AUTOSAR cores.</p><p xmlns="">It forces ShutdownOS to be executed on each AUTOSAR core.</p><p xmlns="">The cores are synchronized just before calling the global ShutdownHook.</p><p xmlns="">The system can be restarted if Os_Restart() is called in the global ShutdownHook (by each core).</p><p xmlns="">ShutdownAllCores is not effective when called by untrusted code, and will simply return to the caller.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  if (ErrorCondition != E_OK) {
    ShutdownAllCores(ErrorCondition);
  }
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Restart">Os_Restart</a><br /><a href="#Os_SetRestartPoint">Os_SetRestartPoint</a><br /><a href="#StartOS">StartOS</a><br /><a href="#ShutdownOS">ShutdownOS</a><br /></p><h2 xmlns=""><a name="ShutdownOS">ShutdownOS</a></h2><p xmlns="">Shutdown the operating system.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void ShutdownOS(StatusType Error)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Error</td><td class="CodeBodyText">StatusType</td><td>in</td><td>The reason for the shutdown.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This API causes the OS to shut down. Task scheduling, all Category 2 interrupts, alarms and schedule tables are stopped immediately.</p><p xmlns="">PostTaskHook (if configured) is not called when ShutdownOS() occurs.</p><p xmlns="">ShutdownHook is called (if configured) and is passed the Error argument as the OS shuts down.</p><p xmlns="">If ShutdownHook() returns, or is absent, the operating system then disables all Category 1 interrupts and enters an endless loop.</p><p xmlns="">ShutdownOS() can be called internally by the operating system in response to an unrecoverable error.</p><p xmlns="">ShutdownOS() is not effective when called by untrusted code, and will simply return to the caller.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  if (ErrorCondition != E_OK) {
    ShutdownOS(ErrorCondition);
  }
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td><td>True</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Restart">Os_Restart</a><br /><a href="#Os_SetRestartPoint">Os_SetRestartPoint</a><br /><a href="#StartOS">StartOS</a><br /><a href="#ShutdownAllCores">ShutdownAllCores</a><br /></p><h2 xmlns=""><a name="StartCore">StartCore</a></h2><p xmlns="">Start a core that is configured to run AUTOSAR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void StartCore(CoreIdType CoreID, StatusType* Status)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CoreID</td><td class="CodeBodyText">CoreIdType</td><td>in</td><td>The core to activate.</td></tr><tr><td class="CodeBodyText">Status</td><td class="CodeBodyText">StatusType</td><td>out</td><td>The return status.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>The core does not exist or it is not configured to run AUTOSAR.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>The API was called after StartOS().</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>The core is already started.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">In a multicore configuration, StartCore is used to start cores that are configured to run the AUTOSAR OS. It must be called for each of the AUTOSAR cores, including the master core if it is so configured.</p><p xmlns="">All cores start execution at OS_MAIN(), so take care not to start cores more than once.</p><p xmlns="">StartCore can be invoked from the master core, or from slave cores.</p><p xmlns="">StartOS() must be called for each AUTOSAR OS core. Each call must pass the same AppModeType, or DONOTCARE.</p><p xmlns="">This API is only provided with multicore project configurations.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">OS_MAIN(){
  StatusType status;
  ...
  if (GetCoreID() == OS_CORE_ID_MASTER) {
    StartCore(OS_CORE_ID_0, &amp;status);
    StartCore(OS_CORE_ID_1, &amp;status);
  }
  StartOS(OSDEFAULTAPPMODE);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartNonAutosarCore">StartNonAutosarCore</a><br /><a href="#StartOS">StartOS</a><br /><a href="#GetCoreID">GetCoreID</a><br /><a href="#GetNumberOfActivatedCores">GetNumberOfActivatedCores</a><br /></p><h2 xmlns=""><a name="StartNonAutosarCore">StartNonAutosarCore</a></h2><p xmlns="">Start a core that is not configured to run AUTOSAR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void StartNonAutosarCore(CoreIdType CoreID, StatusType* Status)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">CoreID</td><td class="CodeBodyText">CoreIdType</td><td>in</td><td>The core to activate.</td></tr><tr><td class="CodeBodyText">Status</td><td class="CodeBodyText">StatusType</td><td>out</td><td>The return status.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>The core does not exist or it is configured to run AUTOSAR.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>The API was called after StartOS().</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>The core is already started.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">In a multicore configuration, StartNonAutosarCore is used to start cores that are NOT configured to run the AUTOSAR OS. It may be called for each of the non-AUTOSAR cores, including the master core if it is so configured.</p><p xmlns="">All cores start execution at OS_MAIN(), so take care not to start cores more than once.</p><p xmlns="">StartNonAutosarCore can be invoked from the master core, or from slave cores.</p><p xmlns="">This API is only provided with multicore project configurations.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">OS_MAIN(){
  StatusType status;
  ...
  if (GetCoreID() == OS_CORE_ID_MASTER) {
    StartNonAutosarCore(OS_CORE_ID_0, &amp;status);
    StartNonAutosarCore(OS_CORE_ID_1, &amp;status);
  }
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartCore">StartCore</a><br /><a href="#GetCoreID">GetCoreID</a><br /></p><h2 xmlns=""><a name="StartOS">StartOS</a></h2><p xmlns="">Start the operating system in a specified mode.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void StartOS(AppModeType Mode)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Mode</td><td class="CodeBodyText">AppModeType</td><td>in</td><td>The application mode to use for startup.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">StartOS() initializes all internal OS data structures and starts the OS in the specified Mode.</p><p xmlns="">Any tasks that are autostarted in the specified Mode are set to the ready state.</p><p xmlns="">Any alarms or schedule tables that are autostarted in the specified Mode are initialized appropriately.</p><p xmlns="">Software counters are initialized to zero.</p><p xmlns="">The Mode OSDEFAULTAPPMODE must always exist, but other names can be configured as needed.</p><p xmlns="">StartOS() is only allowed outside the context of the OS. It has no effect if called while the OS is already running.</p><p xmlns="">Restarting the OS can be achieved using Os_SetRestartPoint() to set a restart point before the call the StartOS() and jumping to the point using Os_Restart().</p><p xmlns="">If StartOS() is called with invalid preconditions, it may call ShutdownOS(E_OS_STATE). The preconditions are port-specific, so are documented in the port user guide. They may include issues such as the CPU being in the wrong mode, or the stack not being set up correctly.</p><p xmlns="">Where there is more than one core configured to use AUTOSAR OS, each OS core must call StartOS. At least one of these must provide a Mode value that is different to DONOTCARE. Other than DONOTCARE, all calls to StartOS must use the same Mode value.</p><p xmlns="">When called correctly by an OS core, StartOS() does not return to the caller.</p><p xmlns="">When called by a non-OS core, StartOS() returns without any effect.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">OS_MAIN() {
  /* Initialize target hardware before starting OS */
  StartOS(OSDEFAULTAPPMODE);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Restart">Os_Restart</a><br /><a href="#Os_SetRestartPoint">Os_SetRestartPoint</a><br /><a href="#ShutdownOS">ShutdownOS</a><br /><a href="#ShutdownAllCores">ShutdownAllCores</a><br /><a href="#Os_Cbk_Idle">Os_Cbk_Idle</a><br /><a href="#DONOTCARE">DONOTCARE</a><br /></p><h2 xmlns=""><a name="StartScheduleTableAbs">StartScheduleTableAbs</a></h2><p xmlns="">Set the counter tick at which a schedule table starts.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType StartScheduleTableAbs(ScheduleTableType ScheduleTableID, TickType Start)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ScheduleTableID</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Name of the schedule table to start.</td></tr><tr><td class="CodeBodyText">Start</td><td class="CodeBodyText">TickType</td><td>in</td><td>Absolute counter tick value at which the schedule table starts.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>all</td><td>ScheduleTableID already running.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ScheduleTableID is not a valid ScheduleTable.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ScheduleTableID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_VALUE</td><td>extended</td><td>Start &gt; maxallowedvalue of the underlying counter.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">If the parameters are valid, this call starts ScheduleTableID running and sets the state of ScheduleTableID to SCHEDULETABLE_RUNNING.</p><p xmlns="">The first expiry point is processed at Start+InitialOffset ticks, where InitialOffset is the numerically lowest of the statically configured offsets defined for expiry points on ScheduleTableID.</p><p xmlns="">Note that if this gives a value less than or equal to the current counter value then the first expiry will not happen until a full modulus wrap of the underlying counter has occurred.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  /* Start MyScheduleTable when the associated counter reaches 100 */
  StartScheduleTableAbs(MyScheduleTable, 100);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#GetScheduleTableStatus">GetScheduleTableStatus</a><br /><a href="#NextScheduleTable">NextScheduleTable</a><br /><a href="#SetScheduleTableAsync">SetScheduleTableAsync</a><br /><a href="#StartScheduleTableRel">StartScheduleTableRel</a><br /><a href="#StartScheduleTableSynchron">StartScheduleTableSynchron</a><br /><a href="#StopScheduleTable">StopScheduleTable</a><br /><a href="#SyncScheduleTable">SyncScheduleTable</a><br /><a href="#Os_SyncScheduleTableRel">Os_SyncScheduleTableRel</a><br /></p><h2 xmlns=""><a name="StartScheduleTableRel">StartScheduleTableRel</a></h2><p xmlns="">Set the number of counter ticks before a schedule table starts.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType StartScheduleTableRel(ScheduleTableType ScheduleTableID, TickType Offset)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ScheduleTableID</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Name of the schedule table to start.</td></tr><tr><td class="CodeBodyText">Offset</td><td class="CodeBodyText">TickType</td><td>in</td><td>Relative number of ticks before the schedule table starts.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>all</td><td>ScheduleTableID is not in the state SCHEDULETABLE_STOPPED.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ScheduleTableID is not a valid ScheduleTable.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ScheduleTableID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_VALUE</td><td>extended</td><td>Offset == zero or Offset &gt; maxallowedvalue - InitialOffset.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">If the parameters are valid, this call starts ScheduleTableID running and sets the state of ScheduleTableID to SCHEDULETABLE_RUNNING.</p><p xmlns="">The first expiry point on ScheduleTableID is processed after Offset+InitialOffset ticks have elapsed,  where InitialOffset is the numerically lowest of the statically configured offsets defined for expiry points on ScheduleTableID.</p><p xmlns="">The call is not permitted for a schedule table that is configured as implicitly synchronized. If ScheduleTableID is an implicitly synchronized schedule table then the call will return E_OS_ID.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  /* Start MyScheduleTable at Now+42 ticks */
  StartScheduleTableRel(MyScheduleTable, 42);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#GetScheduleTableStatus">GetScheduleTableStatus</a><br /><a href="#NextScheduleTable">NextScheduleTable</a><br /><a href="#StartScheduleTableAbs">StartScheduleTableAbs</a><br /><a href="#StartScheduleTableSynchron">StartScheduleTableSynchron</a><br /><a href="#StopScheduleTable">StopScheduleTable</a><br /><a href="#SyncScheduleTable">SyncScheduleTable</a><br /><a href="#Os_SyncScheduleTableRel">Os_SyncScheduleTableRel</a><br /></p><h2 xmlns=""><a name="StartScheduleTableSynchron">StartScheduleTableSynchron</a></h2><p xmlns="">Start an explicitly synchronized schedule table and wait for a synchronization call.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType StartScheduleTableSynchron(ScheduleTableType ScheduleTableID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ScheduleTableID</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Name of the schedule table to start.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ScheduleTableID is not a valid ScheduleTable.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ScheduleTableID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>The state of ScheduleTableID is not SCHEDULETABLE_STOPPED.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call primes the explicitly synchronized ScheduleTableID to start synchronously once a synchronization count to be provided by the call SyncScheduleTable(). The call returns E_OS_ID if ScheduleTableID is not explicitly synchronized.</p><p xmlns="">A successful call results in ScheduleTableID entering the state SCHEDULETABLE_WAITING. Expiry point processing for ScheduleTableID does not start until a call to SyncScheduleTable() is made while the schedule table is in state SCHEDULETABLE_WAITING.</p><p xmlns="">Note that if no call to SyncScheduleTable() (or StopScheduleTable()) is made after ScheduleTableID is started synchronously, then it will remain in the state SCHEDULETABLE_WAITING indefinitely.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  StartScheduleTableSynchron(MyScheduleTable);
  ...
  SyncScheduleTable(MyScheduleTable, 12U);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#GetScheduleTableStatus">GetScheduleTableStatus</a><br /><a href="#NextScheduleTable">NextScheduleTable</a><br /><a href="#StartScheduleTableRel">StartScheduleTableRel</a><br /><a href="#StartScheduleTableAbs">StartScheduleTableAbs</a><br /><a href="#SyncScheduleTable">SyncScheduleTable</a><br /><a href="#Os_SyncScheduleTableRel">Os_SyncScheduleTableRel</a><br /><a href="#StopScheduleTable">StopScheduleTable</a><br /></p><h2 xmlns=""><a name="StopScheduleTable">StopScheduleTable</a></h2><p xmlns="">Stop a schedule table.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType StopScheduleTable(ScheduleTableType ScheduleTableID)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ScheduleTableID</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Name of the schedule table to stop.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_NOFUNC</td><td>all</td><td>ScheduleTableID is not running.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>ScheduleTableID is not a valid ScheduleTable.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ScheduleTableID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call stops ScheduleTableID immediately. A call to StartScheduleTableAbs(), StartScheduleTableRel() or StartScheduleTableSynchron() (where appropriate) will re-start ScheduleTableID at the start.</p><p xmlns="">Note that any schedule table that was nexted from ScheduleTableID will not start and will remain in the state SCHEDULETABLE_NEXT. StopScheduleTable() will need to be called on such tables in order to reset their state.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  StopScheduleTable(MyScheduleTable);
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#GetScheduleTableStatus">GetScheduleTableStatus</a><br /><a href="#NextScheduleTable">NextScheduleTable</a><br /><a href="#StartScheduleTableAbs">StartScheduleTableAbs</a><br /><a href="#StartScheduleTableRel">StartScheduleTableRel</a><br /><a href="#StartScheduleTableSynchron">StartScheduleTableSynchron</a><br /></p><h2 xmlns=""><a name="SuspendAllInterrupts">SuspendAllInterrupts</a></h2><p xmlns="">Suspend recognition of Category 1 and Category 2 interrupts.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void SuspendAllInterrupts(void)</p><h4 xmlns="">Description</h4><p xmlns="">This API call marks the start of a critical section that is protected from any maskable Category 1 or Category 2 interrupt occurring. The critical section must be left by using the ResumeAllInterrupts() call.</p><p xmlns="">No API calls beside SuspendAllInterrupts()/ResumeAllInterrupts() pairs and SuspendOSInterrupts()/ResumeOSInterrupts() pairs are allowed within this critical section.</p><p xmlns="">The call saves the current interrupt mask so that it can be restored later by the ResumeAllInterrupts() call.</p><p xmlns="">When calls to SuspendAllInterrupts() and ResumeAllInterrupts() are nested then the interrupt recognition status saved by the first call of SuspendAllInterrupts() is restored by the last call of the ResumeAllInterrupts().</p><p xmlns="">In a multicore environment, this call only affects the interrupts on the core that it is called from.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  SuspendAllInterrupts();
  ...
  ResumeAllInterrupts();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DisableAllInterrupts">DisableAllInterrupts</a><br /><a href="#EnableAllInterrupts">EnableAllInterrupts</a><br /><a href="#ResumeAllInterrupts">ResumeAllInterrupts</a><br /><a href="#ResumeOSInterrupts">ResumeOSInterrupts</a><br /><a href="#SuspendOSInterrupts">SuspendOSInterrupts</a><br /></p><h2 xmlns=""><a name="SuspendOSInterrupts">SuspendOSInterrupts</a></h2><p xmlns="">Suspend recognition of Category 2 interrupts.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">void SuspendOSInterrupts(void)</p><h4 xmlns="">Description</h4><p xmlns="">This API call marks the start of a critical section that is protected from any Category 2 interrupt occurring. Category 1 interrupts may still occur. The critical section must be left using the ResumeOSInterrupts() call.</p><p xmlns="">No API calls beside SuspendAllInterrupts()/ResumeAllInterrupts() pairs and SuspendOSInterrupts()/ResumeOSInterrupts() pairs are allowed within this critical section.</p><p xmlns="">The call saves the current interrupt mask so that it can be restored later by the ResumeOSInterrupts() call.</p><p xmlns="">When calls to SuspendOSInterrupts() and ResumeOSInterrupts() are nested then the interrupt recognition status saved by the first call of SuspendOSInterrupts() is restored by the last call of the ResumeOSInterrupts().</p><p xmlns="">In a multicore environment, this call only affects the interrupts on the core that it is called from.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  SuspendOSInterrupts();
    /* Longer Critical Section */
    ...
    SuspendAllInterrupts();
    /* Shorter Critical Section  */
    ResumeAllInterrupts();
    ...
  ResumeOSInterrupts();
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DisableAllInterrupts">DisableAllInterrupts</a><br /><a href="#EnableAllInterrupts">EnableAllInterrupts</a><br /><a href="#ResumeAllInterrupts">ResumeAllInterrupts</a><br /><a href="#ResumeOSInterrupts">ResumeOSInterrupts</a><br /><a href="#SuspendOSInterrupts">SuspendOSInterrupts</a><br /></p><h2 xmlns=""><a name="SyncScheduleTable">SyncScheduleTable</a></h2><p xmlns="">Provide the synchronization count for an explicitly synchronized schedule table.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType SyncScheduleTable(ScheduleTableType ScheduleTableID, TickType Value)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ScheduleTableID</td><td class="CodeBodyText">ScheduleTableType</td><td>in</td><td>Name of the schedule table to start.</td></tr><tr><td class="CodeBodyText">Value</td><td class="CodeBodyText">TickType</td><td>in</td><td>Absolute value of the synchronizing counter.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>all</td><td>ScheduleTableID is not an explicitly synchronized table.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>ScheduleTableID is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_VALUE</td><td>all</td><td>Value exceeds the duration of the table.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>all</td><td>The status of ScheduleTableID is SCHEDULETABLE_STOPPED or SCHEDULETABLE_NEXT.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call provides the synchronization Value for an explicitly synchronized table ScheduleTableID. ScheduleTableID must be either waiting for a synchronization value or be running.</p><p xmlns="">Control of and knowledge about the synchronizing counter is outside the domain of the OS. The OS assumes that the synchronizing counter has a duration equal to ScheduleTableID and that the resolution of the synchronizing counter is equal to the resolution of the OS counter used to drive ScheduleTableID. It is your responsibility to verify that your application satisfies these constraints.</p><p xmlns="">If ScheduleTableID is in the state SCHEDULETABLE_WAITING then SyncScheduleTable() causes ScheduleTableID to change state to SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS and the OS to start processing expiry points. The current deviation between ScheduleTableID and the synchronization count will be zero.</p><p xmlns="">The first expiry point that will be processed is the one with the smallest statically configured offset. The smallest offset is known as the InitialOffset. The point at which the first expiry point is processed is determined as follows:</p><p xmlns="">- if Value is less than the InitialOffset, then the first expiry point will be processed when InitialOffset-Value ticks have elapsed on the counter driving ScheduleTableID.</p><p xmlns="">- if Value is greater than or equal to InitialOffset, then the first expiry point will be processed when (Duration-Value)+InitialOffset ticks have elapsed. This may require a full wrap of the underlying drive counter before the first expiry point is processed.</p><p xmlns="">This means that calling SyncScheduleTable() when ScheduleTableID is in the state SCHEDULETABLE_WAITING has behavior that is logically equivalent to calling StartScheduleTableRel() with an Offset equal to InitialOffset-Value or (Duration-Value)+InitialOffset accordingly.</p><p xmlns="">If the ScheduleTableID is in the state SCHEDULETABLE_RUNNING or SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS then SyncScheduleTable() will calculate the current deviation between the notional position on ScheduleTableID and Value. The deviation is equal to P-Value mod Duration. The state of ScheduleTableID is set according to the difference between the calculated deviation and the statically configured precision as follows:</p><p xmlns="">- if deviation &lt;= precision then the state will be set to SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS</p><p xmlns="">- if deviation &gt; precision then the state will be set to SCHEDULETABLE_RUNNING</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  StartScheduleTableSynchron(MyScheduleTable);
  ...
  SyncScheduleTable(MyScheduleTable, 12U);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareScheduleTable">DeclareScheduleTable</a><br /><a href="#GetScheduleTableStatus">GetScheduleTableStatus</a><br /><a href="#NextScheduleTable">NextScheduleTable</a><br /><a href="#StartScheduleTableRel">StartScheduleTableRel</a><br /><a href="#StartScheduleTableAbs">StartScheduleTableAbs</a><br /><a href="#StartScheduleTableSynchron">StartScheduleTableSynchron</a><br /><a href="#StopScheduleTable">StopScheduleTable</a><br /><a href="#SetScheduleTableAsync">SetScheduleTableAsync</a><br /><a href="#Os_SyncScheduleTableRel">Os_SyncScheduleTableRel</a><br /></p><h2 xmlns=""><a name="TerminateApplication">TerminateApplication</a></h2><p xmlns="">Terminates an OS-Application</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType TerminateApplication(ApplicationType Application /* AUTOSAR R4.0 only */, RestartType RestartOption)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Application</td><td class="CodeBodyText">ApplicationType</td><td>in</td><td>(AUTOSAR R4.0 only) The OS-Application from which the state is requested.</td></tr><tr><td class="CodeBodyText">RestartOption</td><td class="CodeBodyText">RestartType</td><td>in</td><td>RESTART or NO_RESTART.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_VALUE</td><td>all</td><td>RestartOption is neither RESTART nor NO_RESTART.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>all</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>all</td><td>(AUTOSAR R4.0) Called when the state of the OS-Application is already APPLICATION_TERMINATED, or APPLICATION_RESTARTING and RestartOption is RESTART, or APPLICATION_RESTARTING and the caller does not belong to the OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>all</td><td>(AUTOSAR R4.0) Called from a different OS-Application that is untrusted.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>all</td><td>Called for a Trusted OS-Application when optimization 'Only Terminate Untrusted Applications' is configured.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>all</td><td>(AUTOSAR R4.0) Application is not a valid OS-Application.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">NOTE: Prior to AUTOSAR R4.0, this call operates only on the OS-Application that owns the calling task or ISR.</p><p xmlns="">NOTE: From AUTOSAR R4.0 onwards, trusted tasks and interrupts can specify which OS-Application to terminate.</p><p xmlns="">This call terminates the OS-Application. Any running task/ISR of the OS-Application is forcibly terminated. The ready tasks/ISRs of the OS-Application are forcibly terminated before they can resume.</p><p xmlns="">The interrupt sources for all Category 2 ISRs owned by the OS-Application are disabled by the OS calling Os_Cbk_Disable_&lt;ISRName&gt;() for each ISRName owned by the OS-Application.</p><p xmlns="">All alarms owned by the OS-Application are cancelled. All schedule tables owned by the OS-Application are stopped.</p><p xmlns="">If any of the tasks/ISRs holds any resources (whether standard, linked or internal) then the resources are released. Similarly, if any of the tasks/ISRs had masked interrupts using the Suspend[All|OS]Interrupts() or DisableAllInterrupts() service calls then OS will automatically call the services Resume[All|OS]Interrupts() or EnableAllInterrupts() as appropriate.</p><p xmlns="">If any of the tasks/ISRs holds any Spinlocks then they are released. (Multicore only.)</p><p xmlns="">If the RestartOption is RESTART, the OS-Application's restart task will be activated.</p><p xmlns="">Applications should take note of the following race conditions when using TerminateApplication():</p><p xmlns="">- if resources had been locked and/or interrupts masked to protect a critical section shared between OS-Applications, then be aware that the forced termination of tasks/ISRs may leave the data which is manipulated in the critical section in an unknown state. It is the application's responsibility to protect the system against the impact of this possibility.</p><p xmlns="">- there is no guarantee that the restart task will execute before any other task in the OS-Application unless the restart task has the highest priority</p><p xmlns="">- counters that are accessed by other OS-Applications will cease to be operational after termination until the interrupts that drive them are re-enabled. This may cause failures to propagate to other OS-Applications.</p><p xmlns="">- tasks (and events set for them) in other OS-Applications that are triggered by alarms or schedule in terminated OS-Application will not be activated (or set). This may cause other OS-Applications to fail.</p><p xmlns="">- (AUTOSAR R3.x) other OS-Applications that have access to any of the terminated OS-Application's objects may use those objects even if the application has been terminated. For example, another OS-Application may activate a task in a terminated OS-Application.</p><p xmlns="">TerminateApplication can be used to terminate application on other cores if needed. However there may be subtle timing issues involved in doing this, so it is recommended that TerminateApplication is called on the core that contains the application.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  if (ErrorDetected == TRUE) {
#if (OS_AR_MAJOR_VERSION &lt; (4U))
    TerminateApplication(RESTART);
#else
    TerminateApplication(GetApplicationID(), RESTART);
#endif
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TerminateTask">TerminateTask</a><br /><a href="#GetApplicationState">GetApplicationState</a><br /><a href="#AllowAccess">AllowAccess</a><br /><a href="#Os_Cbk_Terminated_&lt;ISRName&gt;">Os_Cbk_Terminated_&lt;ISRName&gt;</a><br /><a href="#Os_Cbk_Disable_&lt;ISRName&gt;">Os_Cbk_Disable_&lt;ISRName&gt;</a><br /></p><h2 xmlns=""><a name="TerminateTask">TerminateTask</a></h2><p xmlns="">Terminates the calling task</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType TerminateTask(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_RESOURCE</td><td>extended</td><td>Calling task still holds resources.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called at interrupt level.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_SPINLOCK</td><td>extended</td><td>Called while the task holds a Spinlock</td></tr><tr><td class="CodeBodyText">E_OS_MISSINGEND</td><td>extended</td><td>A task finished without calling TerminateTask or ChainTask (when protection is configured)</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This call terminates the calling task. This transfers the calling task from the running state to the suspended state. The call does not return to the calling context if successful.</p><p xmlns="">If the calling task has queued activations pending then the next instance of the task is  automatically transferred into the ready state.</p><p xmlns="">Internal resources are released automatically.</p><p xmlns="">Standard or linked resources are also released automatically and this is reported as an error condition in extended status.</p><p xmlns="">TerminateTask() always causes re-scheduling.</p><p xmlns="">If the 'Fast Terminate' is enabled in Optimizations for RTA-OS then TerminateTask() must only be called from the task entry function and the return status should not be checked (ErrorHook, when configured, will be called if there is an error). This optimization saves memory and execution time. For further savings, you can actually omit the call to TerminateTask() in SC1 and SC2.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  TerminateTask():
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareTask">DeclareTask</a><br /><a href="#TerminateTask">TerminateTask</a><br /><a href="#GetTaskState">GetTaskState</a><br /><a href="#GetTaskID">GetTaskID</a><br /></p><h2 xmlns=""><a name="TryToGetSpinlock">TryToGetSpinlock</a></h2><p xmlns="">TryToGetSpinlock attempts to occupy a spin-lock variable.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">TryToGetSpinlock(SpinlockIdType SpinlockId, TryToGetSpinlockType* Success)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">SpinlockId</td><td class="CodeBodyText">SpinlockIdType</td><td>in</td><td>The Spinlock to occupy.</td></tr><tr><td class="CodeBodyText">Success</td><td class="CodeBodyText">Os_TryToGetSpinlockRefType</td><td>out</td><td>Result of the call: TRYTOGETSPINLOCK_SUCCESS or TRYTOGETSPINLOCK_NOSUCCESS</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>extended</td><td>SpinlockId does not refer to a valid Spinlock.</td></tr><tr><td class="CodeBodyText">E_OS_STATE</td><td>extended</td><td>The Spinlock is already occupied by the calling TASK or ISR (pre 4.0.3).</td></tr><tr><td class="CodeBodyText">E_OS_INTERFERENCE_DEADLOCK</td><td>extended</td><td>The Spinlock is already occupied by a TASK/ISR on the same core. This would cause a deadlock.</td></tr><tr><td class="CodeBodyText">E_OS_NESTING_DEADLOCK</td><td>extended</td><td>Attempt to occupy the Spinlock while already holding a different Spinlock in a way that may cause a deadlock.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>SpinlockId is not accessible from the calling OS-Application.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">TryToGetSpinlock has the same behavior as GetSpinlock, except that if the spinlock is already occupied by a different core, TryToGetSpinlock does not wait for the spinlock but returns E_OK and sets *Success to TRYTOGETSPINLOCK_NOSUCCESS.</p><p xmlns="">If it is able to occupy the spinlock then it returns E_OK and sets *Success to TRYTOGETSPINLOCK_SUCCESS.</p><p xmlns="">For a spinlock with a lock method with LOCK_ALL_INTERRUPTS, LOCK_CAT2_INTERRUPTS or LOCK_WITH_RES_SCHEDULER semantics, the lock method is only in effect if the lock succeeds. If the lock is not successful then no change is made to system schedulability.</p><p xmlns="">When the spinlock has a lock method with NESTABLE semantics, this API will indicate a successful lock if the lock is already held by a TASK or ISR on the same core. The lock is only released by the original locker, and only then when it has made the same number of Release calls as Get calls.</p><p xmlns="">When the spinlock has a lock method with COMMONABLE semantics, it can be followed by any spinlock that has no successors of its own, and is not also COMMONABLE. It can follow a normal lock without being on its list of successors.</p><p xmlns="">Note that the OS configuration option 'Force spinlock error checks' can be used to cause the error checks to be done in standard as well as extended status builds.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  TryToGetSpinlockType try_result;
  ...
  TryToGetSpinlock(Spinlock1, &amp;try_result);
  if (TRYTOGETSPINLOCK_SUCCESS == try_result) {
    ...
    ReleaseSpinlock(Spinlock1);
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>True</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetSpinlock">GetSpinlock</a><br /><a href="#ReleaseSpinlock">ReleaseSpinlock</a><br /><a href="#UncheckedGetSpinlock">UncheckedGetSpinlock</a><br /><a href="#UncheckedTryToGetSpinlock">UncheckedTryToGetSpinlock</a><br /><a href="#UncheckedReleaseSpinlock">UncheckedReleaseSpinlock</a><br /></p><h2 xmlns=""><a name="UncheckedGetSpinlock">UncheckedGetSpinlock</a></h2><p xmlns="">UncheckedGetSpinlock tries to occupy a spin-lock variable.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">UncheckedGetSpinlock(SpinlockIdType SpinlockId)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">SpinlockId</td><td class="CodeBodyText">SpinlockIdType</td><td>in</td><td>The Spinlock to occupy.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This is a version of GetSpinlock that can be called (with care) from Category 1 ISRs. Few checks can be done within Category 1 ISRs, so it is sensible to only use this API for spinlocks with LOCK_ALL behavior.</p><p xmlns="">This API is only available if you set the OS option 'Add Spinlock APIs for CAT1 ISRs' to TRUE.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CAT1ISR(MyISR){
  ...
  UncheckedGetSpinlock(Spinlock1);
  ...
  UncheckedReleaseSpinlock(Spinlock1);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetSpinlock">GetSpinlock</a><br /><a href="#TryToGetSpinlock">TryToGetSpinlock</a><br /><a href="#ReleaseSpinlock">ReleaseSpinlock</a><br /><a href="#UncheckedTryToGetSpinlock">UncheckedTryToGetSpinlock</a><br /><a href="#UncheckedReleaseSpinlock">UncheckedReleaseSpinlock</a><br /></p><h2 xmlns=""><a name="UncheckedReleaseSpinlock">UncheckedReleaseSpinlock</a></h2><p xmlns="">UncheckedReleaseSpinlock is used to release a spin-lock variable.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">UncheckedReleaseSpinlock(SpinlockIdType SpinlockId)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">SpinlockId</td><td class="CodeBodyText">SpinlockIdType</td><td>in</td><td>The Spinlock to release.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This is a version of ReleaseSpinlock that can be called (with care) from Category 1 ISRs. Few checks can be done within Category 1 ISRs, so it is sensible to only use this API for spinlocks with LOCK_ALL behavior.</p><p xmlns="">This API is only available if you set the OS option 'Add Spinlock APIs for CAT1 ISRs' to TRUE.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CAT1ISR(MyISR){
  ...
  UncheckedGetSpinlock(Spinlock1);
  ...
  UncheckedReleaseSpinlock(Spinlock1);
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetSpinlock">GetSpinlock</a><br /><a href="#TryToGetSpinlock">TryToGetSpinlock</a><br /><a href="#ReleaseSpinlock">ReleaseSpinlock</a><br /><a href="#UncheckedGetSpinlock">UncheckedGetSpinlock</a><br /><a href="#UncheckedTryToGetSpinlock">UncheckedTryToGetSpinlock</a><br /></p><h2 xmlns=""><a name="UncheckedTryToGetSpinlock">UncheckedTryToGetSpinlock</a></h2><p xmlns="">UncheckedTryToGetSpinlock attempts to occupy a spin-lock variable.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">UncheckedTryToGetSpinlock(SpinlockIdType SpinlockId, TryToGetSpinlockType* Success)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">SpinlockId</td><td class="CodeBodyText">SpinlockIdType</td><td>in</td><td>The Spinlock to occupy.</td></tr><tr><td class="CodeBodyText">Success</td><td class="CodeBodyText">Os_TryToGetSpinlockRefType</td><td>out</td><td>Result of the call: TRYTOGETSPINLOCK_SUCCESS or TRYTOGETSPINLOCK_NOSUCCESS</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This is a version of TryToGetSpinlock that can be called (with care) from Category 1 ISRs. Few checks can be done within Category 1 ISRs, so it is sensible to only use this API for spinlocks with LOCK_ALL behavior.</p><p xmlns="">This API is only available if you set the OS option 'Add Spinlock APIs for CAT1 ISRs' to TRUE.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CAT1ISR(MyISR){
  UncheckedTryToGetSpinlockType try_result;
  ...
  UncheckedTryToGetSpinlock(Spinlock1, &amp;try_result);
  if (TRYTOGETSPINLOCK_SUCCESS == try_result) {
    ...
    UncheckedReleaseSpinlock(Spinlock1);
  }
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td><td>True</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetSpinlock">GetSpinlock</a><br /><a href="#TryToGetSpinlock">TryToGetSpinlock</a><br /><a href="#ReleaseSpinlock">ReleaseSpinlock</a><br /><a href="#UncheckedGetSpinlock">UncheckedGetSpinlock</a><br /><a href="#UncheckedReleaseSpinlock">UncheckedReleaseSpinlock</a><br /></p><h2 xmlns=""><a name="WaitEvent">WaitEvent</a></h2><p xmlns="">Wait for one or more events.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">StatusType WaitEvent(EventMaskType Mask)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Mask</td><td class="CodeBodyText">EventMaskType</td><td>in</td><td>The event(s) to be waited upon.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ACCESS</td><td>extended</td><td>Not called from an extended task.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from interrupt level.</td></tr><tr><td class="CodeBodyText">E_OS_RESOURCE</td><td>extended</td><td>The calling task holds a resource.</td></tr><tr><td class="CodeBodyText">E_OS_CALLEVEL</td><td>extended</td><td>Called from an invalid context (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_DISABLEDINT</td><td>extended</td><td>Called while interrupts are disabled (only when Service Protection is configured).</td></tr><tr><td class="CodeBodyText">E_OS_SPINLOCK</td><td>extended</td><td>Called while the task holds a Spinlock</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">Puts the calling task into the waiting state until one of the specified events is set.</p><p xmlns="">If one or more of the events is already set, then the task remains in the running state.</p><p xmlns="">The API call may cause re-scheduling to take place.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyExtendedTask){
  ...
  WaitEvent(Event1);
  /* Task resumes here when Event1 is set */
  ...
}
</p></pre><h4 xmlns="">Calling Environment</h4><p xmlns=""><table border="1"><thead><tr><th>Cat1 ISR</th><th>Cat2 ISR</th><th>Task</th><th>PreTask Hook</th><th>PostTask Hook</th><th>Startup Hook</th><th>Shutdown Hook</th><th>Error Hook</th><th>Stack Hook</th><th>Time Hook</th><th>Protection Hook</th></tr></thead><tr><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></table></p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#DeclareEvent">DeclareEvent</a><br /><a href="#ClearEvent">ClearEvent</a><br /><a href="#GetEvent">GetEvent</a><br /><a href="#SetEvent">SetEvent</a><br /></p><h1><a name="CBACK">Callbacks</a></h1><h2 xmlns=""><a name="ErrorHook">ErrorHook</a></h2><p xmlns="">Callback routine used for trapping errors resulting from incorrect use of the OS API.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) ErrorHook(StatusType Error)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Error</td><td class="CodeBodyText">StatusType</td><td>in</td><td>The type of the error that has occurred.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This is called when an API call returns a StatusType not equal to E_OK. The StatusType is passed into ErrorHook().</p><p xmlns="">Macros are provided for obtaining information about the source of the error ErrorHook(), but they are only available if the OS has been configured to generate them.</p><p xmlns="">The macros should only be used within ErrorHook().</p><p xmlns="">(1) The macro OSErrorGetServiceId() returns an OSServiceIdType that indicates the API that raised the error. The values take the form OSServiceId_xxx where xxx is the name of an API call. e.g. OSServiceId_ActivateTask.</p><p xmlns="">(2) Macros of the form OSError_&lt;APIName&gt;_&lt;ParameterName&gt;() return the values of the parameters were passed to API. e.g. OSError_ActivateTask_TaskID()</p><p xmlns="">ErrorHook runs at OS level and will not be preempted by Tasks or Category 2 ISRs.</p><p xmlns="">A sample ErrorHook can be generated automatically by rtaosgen. See the RTA-OS User Guide for further details.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_ERRORHOOK_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) ErrorHook(StatusType Error){
  switch (Error){
    case E_OS_ID:
      /* Handle illegal identifier error */
      break;
    case E_OS_VALUE:
      /* Handle illegal value error */
      break;
    case E_OS_STATE:
      /* Handle illegal state error */
      break;
    default:
      /* Handle all other types of error */
      break;
  }
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required when the ErrorHook is configured.</p><h2 xmlns=""><a name="Os_Cbk_Cancel_&lt;CounterID&gt;">Os_Cbk_Cancel_&lt;CounterID&gt;</a></h2><p xmlns="">Callback routine to cancel the interrupt from a hardware counter.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_Cancel_&lt;CounterID&gt;(void)</p><h4 xmlns="">Description</h4><p xmlns="">The callback must prevent interrupts related to the hardware counter occurring.</p><p xmlns="">The interrupt source should be disabled and any interrupt that has become pending while the callback was running should be cleared.</p><p xmlns="">It is not required to stop the associated hardware from incrementing.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_CANCEL_&lt;COUNTERID&gt;_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_Cancel_MyCounter(void) {
  DISABLE_HW_COUNTER_INTERRUPT_SOURCE;
  CLEAR_HW_COUNTER_PENDING_INTERRUPT;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required for each hardware counter configured.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_Now_&lt;CounterID&gt;">Os_Cbk_Now_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_Set_&lt;CounterID&gt;">Os_Cbk_Set_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_State_&lt;CounterID&gt;">Os_Cbk_State_&lt;CounterID&gt;</a><br /></p><h2 xmlns=""><a name="Os_Cbk_CheckMemoryAccess">Os_Cbk_CheckMemoryAccess</a></h2><p xmlns="">Check if a memory region is read/write/execute/stack accessible by a specified OS-Application.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(AccessType, {memclass}) Os_Cbk_CheckMemoryAccess(ApplicationType Application, TaskType TaskID, ISRType ISRID, MemoryStartAddressType Address, MemorySizeType Size)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Application</td><td class="CodeBodyText">ApplicationType</td><td>in</td><td>The OS-Application to which the task or ISR belongs.</td></tr><tr><td class="CodeBodyText">TaskID</td><td class="CodeBodyText">TaskType</td><td>in</td><td>If not INVALID_TASK, the task for which the memory access is being checked.</td></tr><tr><td class="CodeBodyText">ISRID</td><td class="CodeBodyText">ISRType</td><td>in</td><td>If not INVALID_ISR, the ISR for which the memory access is being checked.</td></tr><tr><td class="CodeBodyText">Address</td><td class="CodeBodyText">MemoryStartAddressType</td><td>in</td><td>The start address of the memory area.</td></tr><tr><td class="CodeBodyText">Size</td><td class="CodeBodyText">MemorySizeType</td><td>in</td><td>The size in bytes of the memory area.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type AccessType</p><h4 xmlns="">Description</h4><p xmlns="">The OS calls this when the CheckTaskMemoryAccess() or CheckISRMemoryAccess() service calls are made.</p><p xmlns="">It is provided so that you have full control over the access permissions that you wish to apply on a particular project. For example, you may choose to limit write-access for untrusted code but allow any read and execute access. Alternatively you may wish to limit read/write and execute access for untrusted code.</p><p xmlns="">The callback needs to determine whether the memory locations bounded by Address and (Address + Size) are available for read/write/execute/stack access by the OS-Application (and optionally the Task or ISR that is currently executing).</p><p xmlns="">If called in response to a CheckTaskMemoryAccess() service call, then the OS will set ISRID to INVALID_ISR. Similarly, if called in response to a CheckISRMemoryAccess() call, the OS will set TaskID to INVALID_TASK.</p><p xmlns="">The returned AccessType can be constructed using the following constants:</p><p xmlns="">OS_ACCESS_READ - the memory range is readable</p><p xmlns="">OS_ACCESS_EXECUTE - the memory range is executable</p><p xmlns="">OS_ACCESS_WRITE - the memory range is writeable</p><p xmlns="">OS_ACCESS_STACK - the memory range is stack</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_CHECKMEMORYACCESS_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(AccessType, {memclass}) Os_Cbk_CheckMemoryAccess(ApplicationType Application, TaskType TaskID, ISRType ISRID, MemoryStartAddressType Address, MemorySizeType Size) {
  AccessType Access = OS_ACCESS_EXECUTE;
  /* Check for stack space in address range */
  if ((Address &gt;= STACK_BASE) &amp;&amp; (Address + Size &lt; STACK_BASE + STACK_SIZE) ) {
      Access |= OS_ACCESS_STACK;
  }
  /* Address range is read/write if it is in RAM */
  if ((Address &gt;= RAM_BASE) &amp;&amp; (Address + Size &lt; RAM_BASE + RAM_SIZE) ) {
      Access |= (OS_ACCESS_WRITE | OS_ACCESS_READ);
  }
  switch (Application) {
    case APP1:
      /* Trusted application - no further restrictions */
      break;
    case APP2:
      /* Untrusted application - write restrictions */
      if ((Address &lt;= APP2_BASE) || (Address + Size &gt; APP2_BASE + APP2_SIZE) ) {
        Access &amp;= ~OS_ACCESS_WRITE;
      }
      break;
  }
  return Access;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required when memory protection is configured.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#CheckISRMemoryAccess">CheckISRMemoryAccess</a><br /><a href="#CheckTaskMemoryAccess">CheckTaskMemoryAccess</a><br /><a href="#Os_Cbk_SetMemoryAccess">Os_Cbk_SetMemoryAccess</a><br /></p><h2 xmlns=""><a name="Os_Cbk_CheckStackDepth">Os_Cbk_CheckStackDepth</a></h2><p xmlns="">Callback routine used to monitor system stack usage at run time.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_CheckStackDepth(CoreIdType Core_id, Os_StackSizeType Depth, Os_StackSizeType CurrentPos)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Core_id</td><td class="CodeBodyText">CoreIdType</td><td>in</td><td>The ID of the calling core (OS_CORE_ID_MASTER for single core configurations).</td></tr><tr><td class="CodeBodyText">Depth</td><td class="CodeBodyText">Os_StackSizeType</td><td>in</td><td>The amount of stack used since StartOS.</td></tr><tr><td class="CodeBodyText">CurrentPos</td><td class="CodeBodyText">Os_StackOverrunType</td><td>in</td><td>The value of the stack pointer(s) at the point of the call.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This hook routine is only called if the OS option 'Stack Sampling' is configured.</p><p xmlns="">It is intended to be used to help track the stack usage of the overall system, rather than of individual TASKs and ISRs.</p><p xmlns="">It gets called just before any TASK or ISR starts.</p><p xmlns="">It also gets called from within the Os_GetStackUsage API, so that you can insert monitoring points in your application code.</p><p xmlns="">The APIs GetISRID and GetTaskID can be used within the callback to check what TASK/ID is running (or just about to run).</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_CHECKSTACKDEPTH_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if OS option 'Stack Sampling' is enabled.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetStackUsage">Os_GetStackUsage</a><br /><a href="#Os_GetISRMaxStackUsage">Os_GetISRMaxStackUsage</a><br /><a href="#Os_GetTaskMaxStackUsage">Os_GetTaskMaxStackUsage</a><br /><a href="#Os_ResetISRMaxStackUsage">Os_ResetISRMaxStackUsage</a><br /><a href="#Os_ResetTaskMaxStackUsage">Os_ResetTaskMaxStackUsage</a><br /><a href="#GetISRID">GetISRID</a><br /><a href="#GetTaskID">GetTaskID</a><br /></p><h2 xmlns=""><a name="Os_Cbk_CrosscoreISREnd">Os_Cbk_CrosscoreISREnd</a></h2><p xmlns="">Callback routine indicating the end of a cross-core ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_CrosscoreISREnd(CoreIdType core_id)</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_CrosscoreISREnd() must be implemented in a multi-core configuration if OS option 'Additional ISR Hooks' is enabled. It gets called at the point that a cross-core ISR handler finishes execution.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_CROSSCOREISREND_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint32 CrosscoreEndCount[OS_NUM_CORES];
FUNC(void, {memclass}) Os_Cbk_CrosscoreISREnd(CoreIdType core_id) {
  CrosscoreEndCount[core_id] += 1;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided in a multi-core configuration if OS option 'Additional ISR Hooks' is enabled.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_ISRStart">Os_Cbk_ISRStart</a><br /><a href="#Os_Cbk_ISREnd">Os_Cbk_ISREnd</a><br /><a href="#Os_Cbk_CrosscoreISRStart">Os_Cbk_CrosscoreISRStart</a><br /></p><h2 xmlns=""><a name="Os_Cbk_CrosscoreISRStart">Os_Cbk_CrosscoreISRStart</a></h2><p xmlns="">Callback routine indicating the start of a cross-core ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_CrosscoreISRStart(CoreIdType core_id)</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_CrosscoreISRStart() must be implemented in a multi-core configuration if OS option 'Additional ISR Hooks' is enabled. It gets called at the point that a cross-core ISR handler starts execution.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_CROSSCOREISRSTART_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint32 CrosscoreStartCount[OS_NUM_CORES];
FUNC(void, {memclass}) Os_Cbk_CrosscoreISRStart(CoreIdType core_id) {
  CrosscoreStartCount[core_id] += 1;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided in a multi-core configuration if OS option 'Additional ISR Hooks' is enabled.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_ISREnd">Os_Cbk_ISREnd</a><br /><a href="#Os_Cbk_ISRStart">Os_Cbk_ISRStart</a><br /><a href="#Os_Cbk_CrosscoreISREnd">Os_Cbk_CrosscoreISREnd</a><br /></p><h2 xmlns=""><a name="Os_Cbk_Disable_&lt;ISRName&gt;">Os_Cbk_Disable_&lt;ISRName&gt;</a></h2><p xmlns="">Callback routine indicating that the ISR &lt;ISRName&gt; must be disabled.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_Disable_&lt;ISRName&gt;(void)</p><h4 xmlns="">Description</h4><p xmlns="">The OS calls this function during TerminateApplication to request that the interrupt source associated with the named ISR is disabled.</p><p xmlns="">AUTOSAR requires that all interrupts belonging to an OS Application are disabled when it is terminated.</p><p xmlns="">You would normally re-enable an OS Application's interrupts in its Restart Task.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_DISABLE_&lt;ISRNAME&gt;_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_Disable_App2Isr1(void) {
    disable_interrupt_source(_App2Isr1_);
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required for each ISR if TerminateApplication is supported.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ProtectionHook">ProtectionHook</a><br /><a href="#TerminateApplication">TerminateApplication</a><br /></p><h2 xmlns=""><a name="Os_Cbk_GetStopwatch">Os_Cbk_GetStopwatch</a></h2><p xmlns="">Callback routine to get the current value of a free-running counter.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(Os_StopwatchTickType, {memclass}) Os_Cbk_GetStopwatch(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_StopwatchTickType</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_GetStopwatch() must return the current value of a free-running timer which increments and overflows at the end of its range.</p><p xmlns="">This timer provides the timebase for execution time and trace measurements.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_GETSTOPWATCH_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(Os_StopwatchTickType, {memclass}) Os_Cbk_GetStopwatch(void){
  return (Os_StopwatchTickType) HARDWARE_TIMER_CHANNEL;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if time monitoring or tracing is configured in the OS.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetExecutionTime">Os_GetExecutionTime</a><br /><a href="#Os_GetISRMaxExecutionTime">Os_GetISRMaxExecutionTime</a><br /><a href="#Os_GetTaskMaxExecutionTime">Os_GetTaskMaxExecutionTime</a><br /><a href="#Os_ResetISRMaxExecutionTime">Os_ResetISRMaxExecutionTime</a><br /><a href="#Os_ResetTaskMaxExecutionTime">Os_ResetTaskMaxExecutionTime</a><br /></p><h2 xmlns=""><a name="Os_Cbk_Idle">Os_Cbk_Idle</a></h2><p xmlns="">Runs when the OS becomes idle.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(boolean, {memclass}) Os_Cbk_Idle(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type boolean</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_Idle() is called when the OS first becomes idle after startup. Any autostarted tasks will have run before it gets called.</p><p xmlns="">If Os_Cbk_Idle() exits with a return value TRUE then it will be called again immediately. If Os_Cbk_Idle() exits with a return value FALSE then it will not be called again and the OS will busy wait when there are no tasks or ISRs ready to run.</p><p xmlns="">A default implementation is supplied in the library that returns FALSE.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_IDLE_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(boolean, {memclass}) Os_Cbk_Idle(void) {
  sleep();
  return TRUE;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Optional in user code. No configuration required.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartOS">StartOS</a><br /><a href="#ShutdownOS">ShutdownOS</a><br /><a href="#ShutdownAllCores">ShutdownAllCores</a><br /></p><h2 xmlns=""><a name="Os_Cbk_ISREnd">Os_Cbk_ISREnd</a></h2><p xmlns="">Callback routine indicating the end of a Category 2 ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_ISREnd(ISRType isr)</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_ISREnd() must be implemented if OS option 'Additional ISR Hooks' is enabled. It gets called at the point that a Category 2 ISR finishes execution.</p><p xmlns="">It does not get called when a ISR is pre-empted.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_ISREND_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StopwatchTickType isr_exe_time[OS_NUM_ISRS];
FUNC(void, {memclass}) Os_Cbk_ISREnd(ISRType isr) {
  isr_exe_time[OS_ISRTYPE_TO_INDEX(isr)] = GetExecutionTime();
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if OS option 'Additional ISR Hooks' is enabled.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a><br /><a href="#Os_Cbk_TaskStart">Os_Cbk_TaskStart</a><br /><a href="#Os_Cbk_ISRStart">Os_Cbk_ISRStart</a><br /><a href="#Os_Cbk_TaskEnd">Os_Cbk_TaskEnd</a><br /><a href="#Os_Cbk_CrosscoreISRStart">Os_Cbk_CrosscoreISRStart</a><br /><a href="#Os_Cbk_CrosscoreISREnd">Os_Cbk_CrosscoreISREnd</a><br /></p><h2 xmlns=""><a name="Os_Cbk_ISRStart">Os_Cbk_ISRStart</a></h2><p xmlns="">Callback routine indicating the start of a Category 2 ISR.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_ISRStart(ISRType isr)</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_ISRStart() must be implemented if OS option 'Additional ISR Hooks' is enabled. It gets called at the point that a Category 2 ISR is about to start execution.</p><p xmlns="">It does not get called when a ISR is pre-empted.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_ISRSTART_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint32 isr_starts[OS_NUM_ISRS];
FUNC(void, {memclass}) Os_Cbk_ISRStart(ISRType isr) {
  isr_starts[OS_ISRTYPE_TO_INDEX(isr)] += 1;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if OS option 'Additional ISR Hooks' is enabled.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a><br /><a href="#Os_Cbk_TaskEnd">Os_Cbk_TaskEnd</a><br /><a href="#Os_Cbk_TaskStart">Os_Cbk_TaskStart</a><br /><a href="#Os_Cbk_ISREnd">Os_Cbk_ISREnd</a><br /><a href="#Os_Cbk_CrosscoreISRStart">Os_Cbk_CrosscoreISRStart</a><br /><a href="#Os_Cbk_CrosscoreISREnd">Os_Cbk_CrosscoreISREnd</a><br /></p><h2 xmlns=""><a name="Os_Cbk_Now_&lt;CounterID&gt;">Os_Cbk_Now_&lt;CounterID&gt;</a></h2><p xmlns="">Callback routine that returns the current tick value of the counter.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(TickType, {memclass}) Os_Cbk_Now_&lt;CounterID&gt;(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type TickType</p><h4 xmlns="">Description</h4><p xmlns="">The callback must return the current value of hardware counter.'</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_NOW_&lt;COUNTERID&gt;_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(TickType, {memclass}) Os_Cbk_Now_MyCounter(void){
  return (TickType) HW_COUNTER_NOW_VALUE;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required for each hardware counter configured.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_Cancel_&lt;CounterID&gt;">Os_Cbk_Cancel_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_Set_&lt;CounterID&gt;">Os_Cbk_Set_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_State_&lt;CounterID&gt;">Os_Cbk_State_&lt;CounterID&gt;</a><br /></p><h2 xmlns=""><a name="Os_Cbk_RegSetRestore_&lt;RegisterSetID&gt;">Os_Cbk_RegSetRestore_&lt;RegisterSetID&gt;</a></h2><p xmlns="">Callback routine requiring that the context for register set &lt;RegisterSetID&gt; gets restored.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_RegSetRestore_&lt;RegisterSetID&gt;(Os_RegSetDepthType Depth)</p><h4 xmlns="">Description</h4><p xmlns="">This callback is provided so that the application can restore the current context for register set &lt;RegisterSetID&gt;.</p><p xmlns="">Depth gives the position in the application-provided save buffer from which the context must be read. It ranges from zero to (OS_REGSET_&lt;RegisterSetID&gt;_SIZE - 1).</p><p xmlns="">The RegisterSet implementation is multicore aware. Note that it is possible for the callback to be running on 2 cores at the same time.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_REGSETRESTORE_&lt;REGISTERSETID&gt;_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_REGSET_FP_SIZE
static fp_context_save_area fpsave[OS_REGSET_FP_SIZE];
FUNC(void, {memclass}) Os_Cbk_RegSetRestore_FP(Os_RegSetDepthType Depth){
  ... = fpsave[Depth];
}
#endif /* OS_REGSET_FP_SIZE */
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if Register Set &lt;RegisterSetID&gt; exists and preemption may require its context to be restored.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#OS_REGSET_&lt;RegisterSetID&gt;_SIZE">OS_REGSET_&lt;RegisterSetID&gt;_SIZE</a><br /><a href="#Os_Cbk_RegSetSave_&lt;RegisterSetID&gt;">Os_Cbk_RegSetSave_&lt;RegisterSetID&gt;</a><br /></p><h2 xmlns=""><a name="Os_Cbk_RegSetSave_&lt;RegisterSetID&gt;">Os_Cbk_RegSetSave_&lt;RegisterSetID&gt;</a></h2><p xmlns="">Callback routine requiring that the context for register set &lt;RegisterSetID&gt; gets saved.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_RegSetSave_&lt;RegisterSetID&gt;(Os_RegSetDepthType Depth)</p><h4 xmlns="">Description</h4><p xmlns="">This callback is provided so that the application can save the current context for register set &lt;RegisterSetID&gt;.</p><p xmlns="">Depth gives the position in the application-provided save buffer into which the context must be stored. It ranges from zero to (OS_REGSET_&lt;RegisterSetID&gt;_SIZE - 1).</p><p xmlns="">The RegisterSet implementation is multicore aware. It saves context from different cores in different locations. RegisterSets cannot protect shared context across cores, however. Note that it is possible for the callback to be running on 2 cores at the same time.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_REGSETSAVE_&lt;REGISTERSETID&gt;_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_REGSET_FP_SIZE
static fp_context_save_area fpsave[OS_REGSET_FP_SIZE];
FUNC(void, {memclass}) Os_Cbk_RegSetSave_FP(Os_RegSetDepthType Depth){
  fpsave[Depth] = ...;
}
#endif /* OS_REGSET_FP_SIZE */
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if Register Set &lt;RegisterSetID&gt; exists and preemption may require its context to be saved.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#OS_REGSET_&lt;RegisterSetID&gt;_SIZE">OS_REGSET_&lt;RegisterSetID&gt;_SIZE</a><br /><a href="#Os_Cbk_RegSetRestore_&lt;RegisterSetID&gt;">Os_Cbk_RegSetRestore_&lt;RegisterSetID&gt;</a><br /></p><h2 xmlns=""><a name="Os_Cbk_Set_&lt;CounterID&gt;">Os_Cbk_Set_&lt;CounterID&gt;</a></h2><p xmlns="">Callback routine to set the next match value for a hardware counter.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_Set_&lt;CounterID&gt;(TickType Match)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Match</td><td class="CodeBodyText">TickType</td><td>in</td><td>The next absolute match value.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">The callback must set up the hardware counter to raise the appropriate interrupt when its value reaches the new Match value.</p><p xmlns="">Match is an absolute value at which the next counter action needs to be processed.</p><p xmlns="">This is called from within Os_AdvanceCounter_&lt;CounterID&gt;() to set the match value appropriate for the next alarm or expiry point.</p><p xmlns="">It can also be called from SetAbsAlarm() or SetRelAlarm() if the newly started alarm has to execute before the currently set time.</p><p xmlns="">Care must be taken to cope with the following situations:</p><p xmlns="">- Where intervals are short, it is possible for the hardware count to have already moved past the Match value at the point this get called. If so, it is important to ensure that the interrupt pending bit gets set in software.</p><p xmlns="">- Where an alarm can be started with an interval shorter than one already set, the code must be able to reduce the match value and detect if this means that the hardware count has already passed this point.</p><p xmlns="">The callback does not normally initialize the underlying hardware. This is normally done in initialization code before the OS is started.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_SET_&lt;COUNTERID&gt;_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_Set_MyCounter(TickType Match){
  /* Prevent match interrupts for maxallowedvalue+1 ticks*/
  HW_OUTPUT_COMPARE_VALUE = COUNTER - 1u;
  dismiss_interrupt();
  HW_OUTPUT_COMPARE = Match;
  enable_interrupt();
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required for each hardware counter configured.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_AdvanceCounter">Os_AdvanceCounter</a><br /><a href="#SetAbsAlarm">SetAbsAlarm</a><br /><a href="#SetRelAlarm">SetRelAlarm</a><br /><a href="#Os_Cbk_Cancel_&lt;CounterID&gt;">Os_Cbk_Cancel_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_Now_&lt;CounterID&gt;">Os_Cbk_Now_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_State_&lt;CounterID&gt;">Os_Cbk_State_&lt;CounterID&gt;</a><br /></p><h2 xmlns=""><a name="Os_Cbk_SetMemoryAccess">Os_Cbk_SetMemoryAccess</a></h2><p xmlns="">Callback routine used to prepare the memory protection system for a switch from trusted to untrusted mode.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_SetMemoryAccess(Os_UntrustedContextRefType ApplicationContext)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">ApplicationContext</td><td class="CodeBodyText">Os_UntrustedContextRefType</td><td>in</td><td>A reference to an Os_UntrustedContextType that describes the Untrusted context.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This callback is provided so that you have full control over the memory protection hardware on your device, and so that you can decide the degree of protection that you want to apply on a particular project. For example, you may choose to limit write-access for untrusted code but allow any read and execute access. Alternatively you may wish to limit read/write and execute access for untrusted code.</p><p xmlns="">In an AUTOSAR OS, code that runs in the context of a Trusted OS Application is assumed to have full access to any area of RAM, ROM or IO space that is available. Such code runs in a privileged mode. On the other hand, code that runs in the context of an Untrusted OS Application may have restrictions placed on it that prevent it from being able access certain areas. Such code typically runs in 'user' mode.</p><p xmlns="">Whenever RTA-OS is about to switch from Trusted to Untrusted code, it makes a call to Os_Cbk_SetMemoryAccess. It passes in a reference to an Os_UntrustedContextType data structure that you can use to determine what permissions to set for untrusted code. The Os_UntrustedContextType structure contains information about the OS Application, Task/ISR and stack region that applies to the code that is about to be executed. Depending on the context of the switch, some of these may contain NULL values. Os_Cbk_SetMemoryAccess is only called from trusted code.</p><p xmlns="">Os_Cbk_SetMemoryAccess gets called in the following cases:</p><p xmlns="">1) Before calling a TASK that belongs to an Untrusted OS-Application.</p><p xmlns="">2) Before calling a Category 2 ISR that belongs to an Untrusted OS-Application.</p><p xmlns="">3) Before calling an Untrusted OS-Application Startup, Shutdown or Error hook.</p><p xmlns="">4) Before calling a 'TrustedFunction' that belongs to an Untrusted OS-Application. (This extends the AUTOSAR concept, and allows a core trusted task to call out to untrusted code supplied by third parties.)</p><p xmlns="">When using memory protection features, you must initialize the memory protection hardware before calling StartOS(). You can choose what hardware to use, how many regions to protect and what restrictions to apply.</p><p xmlns="">If you want to run all untrusted code with the same memory protection settings, then you can set the 'Single Memory Protection Zone' OS option. In this case Os_Cbk_SetMemoryAccess will not be called. You must set up the MPU before running any untrusted code.</p><p xmlns="">If you want to run all untrusted code with the same basic memory protection settings but apply protection to the stack, then you can set the 'Stack Only Memory Protection' OS option. In this case Os_Cbk_SetMemoryAccess will only be passed the stack-related fields (Address and Size) plus Application. You must ensure that the memory protection settings limit the stack to the specified range.</p><p xmlns="">* Note *</p><p xmlns="">On certain target processors supported by RTA-OS, there are restrictions on the addresses that can be used to configure MPU protection regions. For example they may have to be aligned on a 64 byte boundary. If you wish to fully protect the stack in these cases, RTA-OS supports an extra field in the Os_UntrustedContextType called 'AlignedAddress'.</p><p xmlns="">When 'AlignedAddress' is present, its value is initially set to the same value as  'Address'. You may change its value so that it reflects the next address on the stack that would be legal for the MPU. For example you might change it from 0x580 to 0x500 if the region has to start on a 256-byte boundary (and the stack grows to lower addresses!).</p><p xmlns="">On targets that support this, RTA-OS will detect the change in 'AlignedAddress' and ensure that the stack is moved to this position just before the untrusted code is run so that it operates in the memory protection region that you set up.</p><p xmlns="">You will have to account for these adjustments in any stack budgets that you declare.</p><p xmlns="">You must not attempt to move the stack to a position that would not be on the normal stack. This will invalidate many of the assumptions and optimizations in RTA-OS.</p><p xmlns="">This mechanism is only available on the RTA-OS target ports that support it and provide the command-line option 'Enable stack repositioning'.</p><p xmlns="">Note that with Stack repositioning in effect, the stack budgets that you need to assign are typically larger than normal by a value equal to the positioning granularity.</p><p xmlns="">* Note *</p><p xmlns="">'FunctionID' and 'FunctionParams' are only present when there are untrusted functions. The value of 'FunctionID' will be INVALID_FUNCTION except when the callback is for an untrusted function. In this case, 'FunctionID' contains the function identifier and 'FunctionParams' is a copy of the pointer to the parameters of the function.</p><p xmlns="">* Note *</p><p xmlns="">'CoreID' is only present where there are multiple AUTOSAR cores, and it holds the number of the current core.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_SETMEMORYACCESS_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_SetMemoryAccess(Os_UntrustedContextRefType ApplicationContext) {
  /*
   * When called for an Untrusted TASK:
   *  ApplicationContext-&gt;Application contains the ID of the OS Application that the TASK belongs to.
   *  ApplicationContext-&gt;TaskID is the ID of the TASK
   *  ApplicationContext-&gt;ISRID is INVALID_ISR
   *  ApplicationContext-&gt;Address is the starting address for the TASK's stack.
   *  ApplicationContext-&gt;Size is the stack budget configured for the TASK. (Zero if no budget or if stack monitoring is disabled.)
   *
   * When called for an Untrusted ISR:
   *  ApplicationContext-&gt;Application contains the ID of the OS Application that the ISR belongs to.
   *  ApplicationContext-&gt;TaskID is INVALID_TASK
   *  ApplicationContext-&gt;ISRID is the ID of the ISR
   *  ApplicationContext-&gt;Address is the starting address for the ISR's stack.
   *  ApplicationContext-&gt;Size is the stack budget configured for the ISR. (Zero if no budget or if stack monitoring is disabled.)
   *
   * When called for:
   *    - an Untrusted Function
   *    - an Untrusted OS Application error hook
   *    - an Untrusted OS Application startup hook
   *    - an Untrusted OS Application shutdown hook
   *  ApplicationContext-&gt;Application contains the ID of the OS Application that the function/hook belongs to.
   *  ApplicationContext-&gt;TaskID is INVALID_TASK
   *  ApplicationContext-&gt;ISRID is INVALID_ISR
   *  ApplicationContext-&gt;Address is the value of the stack pointer just before the untrusted code gets called.
   *  ApplicationContext-&gt;Size is zero
   *
   * Where there are Untrusted Functions, there are two more fields:
   *  ApplicationContext-&gt;FunctionID contains the ID of the function (INVALID_FUNCTION unless being called for an Untrusted Function)
   *  ApplicationContext-&gt;FunctionParams contains FunctionParams for the Untrusted Function call (undefined for INVALID_FUNCTION)
   *
   * On systems where the hardware does not allow protection regions to be set at any address/size combination,
   * it may be necessary to adjust the stack to a position that can be protected efficiently.
   * For example, the protection region may have to be aligned on a 64-byte address boundary.
   * In these cases, RTA-OS may provide the 'AlignUntrustedStacks' configuration option.
   * When this is set, a further field 'ApplicationContext-&gt;AlignedAddress' becomes available.
   * Its initial value will be the same as ApplicationContext-&gt;Address. However you can
   * change its value to signal to the OS that the untrusted code should start at a different location.
   * For the earlier example, if ApplicationContext-&gt;AlignedAddress initially has value 0x1020, you
   * might change it to 0x1000 before returning so that the OS will start running the code at an
   * address that is a multiple of 64. (This example assumes that the stack grows towards lower addresses.)
   * You will have set the stack protection region to start from 0x1000.
   *
   * Be aware that on some target devices (Power PC, for example) the EABI might specify that a
   * back link will be written before the stack pointer on entry.
   * You will have to account for this in your calculations.
   *
   * For a multicore system, ApplicationContext-&gt;CoreID contains the ID of the calling core.
   *  (This is omitted if the OS is only running on one core)
   */

  /*  Force AlignedAddress to the the next 64-byte value below Address */
  (uint32)ApplicationContext-&gt;AlignedAddress &amp;= ((uint32)ApplicationContext-&gt;Address % 64U);
  SET_STACK_RANGE(ApplicationContext-&gt;AlignedAddress, STACK_ALLOWANCE);

  if (ApplicationContext-&gt;Application == App2) {
    /* Set memory protection regions that apply for the overall application 'App2' */
    SET_UNTRUSTED_WRITE_RANGE(App2_BASE, App2_SIZE); /* Example */
    if (ApplicationContext-&gt;TaskID == App2TaskB) {
      /* Extend or restrict ranges as desired for Task 'App2TaskB' */
    }
    if (ApplicationContext-&gt;ISRID == App2ISR1) {
      /* Extend or restrict ranges as desired for ISR 'App2ISR1' */
    }
    if (ApplicationContext-&gt;FunctionID == UTF1) {
      /* Extend or restrict ranges as desired for Untrusted Function 'tf1' */
    }
  }
  if (ApplicationContext-&gt;Application == App3) {
    /* Set memory protection regions that apply for the overall application 'App3' */
    SET_UNTRUSTED_WRITE_RANGE(App3_BASE, App3_SIZE); /* Example */
    if (ApplicationContext-&gt;TaskID == App3TaskB) {
      /* Extend or restrict ranges as desired for Task 'App3TaskB' */
    }
    if (ApplicationContext-&gt;FunctionID == UTF2) {
      /* Extend or restrict ranges as desired for Untrusted Function 'tf2' */
    }
    if (ApplicationContext-&gt;FunctionID == UTF3) {
      /* Extend or restrict ranges as desired for Untrusted Function 'tf3' */
    }
  }
  ...
}
OS_MAIN() {
  ...
  InitializeMemoryProtectionHardware();
  ...
  StartOS(OSDEFAULTAPPMODE);

}

</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided memory protection is selected and there are untrusted OS Applications.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_CheckMemoryAccess">Os_Cbk_CheckMemoryAccess</a><br /><a href="#Os_UntrustedContextType">Os_UntrustedContextType</a><br /><a href="#CallTrustedFunction">CallTrustedFunction</a><br /><a href="#CallAndProtectFunction">CallAndProtectFunction</a><br /></p><h2 xmlns=""><a name="Os_Cbk_SetTimeLimit">Os_Cbk_SetTimeLimit</a></h2><p xmlns="">Callback routine to enable the timing interrupt and set a time limit for it.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void,{memclass}) Os_Cbk_SetTimeLimit(Os_TimeLimitType Limit)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_TimeLimitType</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_SetTimeLimit() must be implemented if timing protection is configured and a timing interrupt is being used to enforce time limits.</p><p xmlns="">You must use it to ensure that the timing interrupt is enabled and that it will fire after 'Limit' ticks from now, unless cancelled by Os_Cbk_SuspendTimeLimit().</p><p xmlns="">Note that an Os_TimeLimitType tick is expected to have the same duration as a Stopwatch tick.</p><p xmlns="">If called with a value zero, you may call Os_TimingFaultDetected() immediately and skip enabling the interrupt.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_SETTIMELIMIT_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void,{memclass}) Os_Cbk_SetTimeLimit(Os_TimeLimitType Limit) {
  Os_TimeLimitType now = &lt;read current counter value&gt;;
  if (Limit == 0) {
    Os_TimingFaultDetected();
  }
  &lt;set current counter compare value&gt;(now + Limit + 1);
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if timing protection is configured and a timing interrupt is being used to enforce time limits.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TimingFaultDetected">Os_TimingFaultDetected</a><br /><a href="#Os_Cbk_SuspendTimeLimit">Os_Cbk_SuspendTimeLimit</a><br /><a href="#ProtectionHook">ProtectionHook</a><br /><a href="#Os_TimeLimitType">Os_TimeLimitType</a><br /></p><h2 xmlns=""><a name="Os_Cbk_StackOverrunHook">Os_Cbk_StackOverrunHook</a></h2><p xmlns="">Callback routine to trap stack-related errors.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_StackOverrunHook(Os_StackSizeType Overrun, Os_StackOverrunType Reason)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Overrun</td><td class="CodeBodyText">Os_StackSizeType</td><td>in</td><td>The amount of the overrun.</td></tr><tr><td class="CodeBodyText">Reason</td><td class="CodeBodyText">Os_StackOverrunType</td><td>in</td><td>The cause of the overrun.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This hook routine is called if configured and any of the following events occur:</p><p xmlns="">(a) a stack allocation budget has been specified for a task/ISR and this budget has been exceeded.</p><p xmlns="">(b) an ECC task failed to start because there was no space on the stack</p><p xmlns="">(c) an ECC task failed to resume from wait because there was no space on the stack</p><p xmlns="">(d) an ECC task failed to wait because it was using too much stack (and its state could not, therefore, be safely preserved)</p><p xmlns="">GetTaskID() and GetISRID() can be used to determine which Task or ISR is involved.</p><p xmlns="">A default version of the hook is present in the kernel that calls ProtectionHook() (if configured, otherwise ShutdownOS()) with the status E_OS_STACKFAULT. You can implement Os_Cbk_StackOverrunHook within your application to override this behavior.</p><p xmlns="">Budget overruns are detected at preemption points (or when Os_GetStackUsage() is called) and are only reported the first time that the overrun is first detected in a given run.</p><p xmlns="">A budget overrun does not result in a Task/ISR being forcibly terminated. (Note that it is not permissible to call TerminateTask within the hook.)</p><p xmlns="">ECC related overruns occur when lower priority tasks exceed their stack budget, or when the stack preemption overheads are set to values that are too small.</p><p xmlns="">An ECC overrun does result in the Task being forcibly terminated.</p><p xmlns="">OS_BUDGET can only occur when Stack Monitoring is configured.</p><p xmlns="">OS_ECC_START, OS_ECC_RESUME and OS_ECC_WAIT can occur independently of whether Stack Monitoring is configured.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_STACKOVERRUNHOOK_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_StackOverrunHook(Os_StackSizeType Overrun, Os_StackOverrunType Reason) {
  switch (Reason) {
    case OS_BUDGET:
      /* The currently running task or ISR has exceeded its stack budget */
      break;
    case OS_ECC_START:
      /* An ECC task has failed to start because there is insufficient room on the stack */
      break;
    case OS_ECC_RESUME:
      /* An ECC task has failed to resume from wait because there is insufficient room on the stack */
      break;
    case OS_ECC_WAIT:
      /* An ECC task has failed to enter the waiting state because it is exceeding its waiting stack budget */
      break;
  }
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Optional when Stack Monitoring is configured and budgets are assigned, or when there are ECC tasks.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetStackUsage">Os_GetStackUsage</a><br /><a href="#Os_GetISRMaxStackUsage">Os_GetISRMaxStackUsage</a><br /><a href="#Os_GetTaskMaxStackUsage">Os_GetTaskMaxStackUsage</a><br /><a href="#Os_ResetISRMaxStackUsage">Os_ResetISRMaxStackUsage</a><br /><a href="#Os_ResetTaskMaxStackUsage">Os_ResetTaskMaxStackUsage</a><br /><a href="#GetISRID">GetISRID</a><br /><a href="#GetTaskID">GetTaskID</a><br /></p><h2 xmlns=""><a name="Os_Cbk_StartCore">Os_Cbk_StartCore</a></h2><p xmlns="">Callback routine used to start a non master core on a multicore variant.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(StatusType, {memclass}) Os_Cbk_StartCore(uint16 CoreID)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type StatusType</p><p xmlns=""><table border="1"><thead><tr><th>Value</th><th>Build</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">E_OK</td><td>all</td><td>No error.</td></tr><tr><td class="CodeBodyText">E_OS_ID</td><td>all</td><td>The core does not exist or can not be started.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">In a multi-core application, the StartCore and StartNonAutosarCore OS APIs have to be called prior to StartOS for each core that is to run.</p><p xmlns="">For this target port, these APIs make a call to Os_Cbk_StartCore which is responsible for starting the specified core and causing it to enter OS_MAIN.</p><p xmlns="">RTA-OS provides a default implementation of Os_Cbk_StartCore that will be appropriate for most normal situations.</p><p xmlns="">Os_Cbk_StartCore does not get called for core 0, because core 0 must start first.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_STARTCORE_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(StatusType, {memclass}) Os_Cbk_StartCore(uint16 CoreID) {
  SET_CORE_RSTVEC(CoreID);
  RELEASE_CORE(CoreID);
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required for non master cores that will be started.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#StartCore">StartCore</a><br /><a href="#StartNonAutosarCore">StartNonAutosarCore</a><br /><a href="#StartOS">StartOS</a><br /></p><h2 xmlns=""><a name="Os_Cbk_State_&lt;CounterID&gt;">Os_Cbk_State_&lt;CounterID&gt;</a></h2><p xmlns="">Callback routine to read the current state of a hardware counter.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_State_&lt;CounterID&gt;(Os_CounterStatusRefType State)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">State</td><td class="CodeBodyText">Os_CounterStatusRefType</td><td>out</td><td>The counter state.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This function must update the counter status structure to indicate if it is running, whether a counter interrupt is pending, and how long the interval is to the next match.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_STATE_&lt;COUNTERID&gt;_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_State_MyCounter(Os_CounterStatusRefType State) {
  State.Delay = HW_OUTPUT_COMPARE_VALUE - HW_COUNTER_NOW_VALUE;
  State.Pending = counter_interrupt_pending();
  State.Running = counter_interrupt_enabled();
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required for each hardware counter configured.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_Cancel_&lt;CounterID&gt;">Os_Cbk_Cancel_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_Now_&lt;CounterID&gt;">Os_Cbk_Now_&lt;CounterID&gt;</a><br /><a href="#Os_Cbk_Set_&lt;CounterID&gt;">Os_Cbk_Set_&lt;CounterID&gt;</a><br /></p><h2 xmlns=""><a name="Os_Cbk_SuspendTimeLimit">Os_Cbk_SuspendTimeLimit</a></h2><p xmlns="">Callback routine to cancel the timing interrupt and determine how much time was left.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(Os_TimeLimitType,{memclass}) Os_Cbk_SuspendTimeLimit(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_TimeLimitType</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_SuspendTimeLimit() must be implemented if timing protection is configured and a timing interrupt is being used to enforce time limits.</p><p xmlns="">The OS calls it to cancel a previous call to Os_Cbk_SetTimeLimit(). You must ensure that the timing interrupt does not fire when the time limit is reached, and if it is currently pending, that its pending status is cleared.</p><p xmlns="">The return value must be the number of ticks that were remaining to the limit at the point that the call was made.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_SUSPENDTIMELIMIT_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(Os_TimeLimitType,{memclass}) Os_Cbk_SuspendTimeLimit(void) {
  Os_TimeLimitType now = &lt;read current counter value&gt;;
  &lt;disable timing interrupt&gt;;
  &lt;clear timing interrupt pending flag&gt;;
  return now - &lt;read current counter compare value&gt;;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if timing protection is configured and a timing interrupt is being used to enforce time limits.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TimingFaultDetected">Os_TimingFaultDetected</a><br /><a href="#Os_Cbk_SetTimeLimit">Os_Cbk_SetTimeLimit</a><br /><a href="#ProtectionHook">ProtectionHook</a><br /><a href="#Os_TimeLimitType">Os_TimeLimitType</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TaskActivated">Os_Cbk_TaskActivated</a></h2><p xmlns="">Callback routine indicating the activation of a TASK.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_TaskActivated(TaskType task)</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_TaskActivated() must be implemented if OS option 'Task Activation Hook' is enabled. It gets called at the point that a TASK is successfully activated.</p><p xmlns="">Activation can be via ActivateTask, ChainTask, Alarms or ScheduleTables.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TASKACTIVATED_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint32 task_activations[OS_NUM_TASKS];
FUNC(void, {memclass}) Os_Cbk_TaskActivated(TaskType task) {
  task_activations[OS_TASKTYPE_TO_INDEX(task)] += 1;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if OS option 'Task Activation Hook' is enabled.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#PreTaskHook">PreTaskHook</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /><a href="#Os_Cbk_Start">Os_Cbk_Start</a><br /><a href="#Os_Cbk_TaskEnd">Os_Cbk_TaskEnd</a><br /><a href="#Os_Cbk_ISRStart">Os_Cbk_ISRStart</a><br /><a href="#Os_Cbk_ISREnd">Os_Cbk_ISREnd</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TaskEnd">Os_Cbk_TaskEnd</a></h2><p xmlns="">Callback routine indicating the end of a TASK.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_TaskEnd(TaskType task)</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_TaskEnd() must be implemented if OS option 'Additional Task Hooks' is enabled.. It gets called at the point that a TASK finishes execution.</p><p xmlns="">For an ECC TASK, it is also called when starting to WAIT.</p><p xmlns="">Unlike PostTaskHook, it does not get called when a TASK is pre-empted.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TASKEND_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StopwatchTickType task_exe_time[OS_NUM_TASKS];
FUNC(void, {memclass}) Os_Cbk_TaskEnd(TaskType task) {
  task_exe_time[OS_TASKTYPE_TO_INDEX(task)] = GetExecutionTime();
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if OS option 'Additional Task Hooks' is enabled.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#PostTaskHook">PostTaskHook</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /><a href="#Os_Cbk_TaskStart">Os_Cbk_TaskStart</a><br /><a href="#Os_Cbk_ISRStart">Os_Cbk_ISRStart</a><br /><a href="#Os_Cbk_ISREnd">Os_Cbk_ISREnd</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TaskStart">Os_Cbk_TaskStart</a></h2><p xmlns="">Callback routine indicating the start of a TASK.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_TaskStart(TaskType task)</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_TaskStart() must be implemented if OS option 'Additional Task Hooks' is enabled.. It gets called at the point that a TASK is about to start execution.</p><p xmlns="">For an ECC TASK, it is also called when resuming from WAITING.</p><p xmlns="">Unlike PreTaskHook, it does not get called when a TASK is pre-empted.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TASKSTART_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint32 task_starts[OS_NUM_TASKS];
FUNC(void, {memclass}) Os_Cbk_TaskStart(TaskType task) {
  task_starts[OS_TASKTYPE_TO_INDEX(task)] += 1;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if OS option 'Additional Task Hooks' is enabled.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#PreTaskHook">PreTaskHook</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /><a href="#Os_Cbk_TaskActivated">Os_Cbk_TaskActivated</a><br /><a href="#Os_Cbk_TaskEnd">Os_Cbk_TaskEnd</a><br /><a href="#Os_Cbk_ISRStart">Os_Cbk_ISRStart</a><br /><a href="#Os_Cbk_ISREnd">Os_Cbk_ISREnd</a><br /></p><h2 xmlns=""><a name="Os_Cbk_Terminated_&lt;ISRName&gt;">Os_Cbk_Terminated_&lt;ISRName&gt;</a></h2><p xmlns="">Callback routine indicating that the Category 2 ISR &lt;ISRName&gt; has been forcibly terminated.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_Terminated_&lt;ISRName&gt;(void)</p><h4 xmlns="">Description</h4><p xmlns="">This callback is provided so that the application can take appropriate action when a Category 2 ISR is forcibly terminated by the OS.</p><p xmlns="">An ISR can be terminated in the following situations:</p><p xmlns="">1) You call TerminateApplication() while the ISR is running (including when it has been interrupted by a higher priority interrupt).</p><p xmlns="">2) There is a timing or memory protection violation while the ISR is running and you return PRO_TERMINATETASKISR from ProtectionHook().</p><p xmlns="">3) There is a timing or memory protection violation while a preempting ISR is running and you return PRO_TERMINATEAPPL or PRO_TERMINATEAPPL_RESTART from ProtectionHook().</p><p xmlns="">On target processors where you have to clear some 'interrupt pending' status for the interrupt source, you must use this callback to clear the status. If you fail to do this, the interrupt will be re-entered when the processor priority is subsequently lowered.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TERMINATED_&lt;ISRNAME&gt;_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_Terminated_App2Isr1(void) {
    clear_interrupt_source(_App2Isr1_);
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required for each Category 2 ISR if forced termination of interrupts is supported.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ProtectionHook">ProtectionHook</a><br /><a href="#TerminateApplication">TerminateApplication</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TimeOverrunHook">Os_Cbk_TimeOverrunHook</a></h2><p xmlns="">Callback routine to trap errors detected during time monitoring.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_TimeOverrunHook(Os_StopwatchTickType Overrun)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Overrun</td><td class="CodeBodyText">Os_StopwatchTickType</td><td>in</td><td>The amount of the overrun in stopwatch ticks.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">This hook routine is called if an execution budget has been specified for a task/ISR and the execution time has exceeded this budget.</p><p xmlns="">Budget overruns are detected at preemption points or when the Task/ISR terminated. This hook is called once, when the overrun is first detected.</p><p xmlns="">A budget overrun does not result in a Task/ISR being forcibly terminated. (Note that it is not permissible to call TerminateTask within the hook.)</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TIMEOVERRUNHOOK_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_TimeOverrunHook(Os_StopwatchTickType Overrun) {
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required when Time Monitoring is configured and budgets are assigned.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetExecutionTime">Os_GetExecutionTime</a><br /><a href="#Os_GetISRMaxExecutionTime">Os_GetISRMaxExecutionTime</a><br /><a href="#Os_GetTaskMaxExecutionTime">Os_GetTaskMaxExecutionTime</a><br /><a href="#Os_ResetISRMaxExecutionTime">Os_ResetISRMaxExecutionTime</a><br /><a href="#Os_ResetTaskMaxExecutionTime">Os_ResetTaskMaxExecutionTime</a><br /><a href="#GetISRID">GetISRID</a><br /><a href="#GetTaskID">GetTaskID</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TraceCommDataReady">Os_Cbk_TraceCommDataReady</a></h2><p xmlns="">Callback routine that signals when there is trace data ready to be sent.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_TraceCommDataReady(void)</p><h4 xmlns="">Description</h4><p xmlns="">When tracing in Bursting or Triggering modes, this gets called automatically when there is a new frame of data to be uploaded to RTA-TRACE.</p><p xmlns="">When tracing in Free-running mode, this gets called from Os_CheckTraceOutput(), which must be called regularly by the application.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TRACECOMMDATAREADY_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_TraceCommDataReady(void) {
  Os_UploadTraceData(); /* Causes call to Os_Cbk_TraceCommTxStart() */
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback may be provided if a communications link is used with tracing. A default version is present in the kernel library.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_UploadTraceData">Os_UploadTraceData</a><br /><a href="#Os_CheckTraceOutput">Os_CheckTraceOutput</a><br /><a href="#Os_Cbk_TraceCommTxStart">Os_Cbk_TraceCommTxStart</a><br /><a href="#Os_Cbk_TraceCommTxByte">Os_Cbk_TraceCommTxByte</a><br /><a href="#Os_Cbk_TraceCommTxEnd">Os_Cbk_TraceCommTxEnd</a><br /><a href="#Os_Cbk_TraceCommTxReady">Os_Cbk_TraceCommTxReady</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TraceCommInitTarget">Os_Cbk_TraceCommInitTarget</a></h2><p xmlns="">Callback routine used to allow the application to perform initialization of external communication for tracing.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(Os_TraceStatusType, {memclass}) Os_Cbk_TraceCommInitTarget(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type Os_TraceStatusType</p><h4 xmlns="">Description</h4><p xmlns="">Os_Cbk_TraceCommInitTarget supports the Os_TraceCommInit by providing application-specific code to initialize the communication link to RTA-TRACE. Typically it sets up an RS232 link.</p><p xmlns="">E_OK should be returned if the initialization succeeded. Any other value will result in trace communication being disabled.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TRACECOMMINITTARGET_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(Os_TraceStatusType, {memclass}) Os_Cbk_TraceCommInitTarget(void){
  initialize_uart();
  return E_OK;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if Os_TraceCommInit is used to initialize tracing using an external communications link.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TraceCommInit">Os_TraceCommInit</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TraceCommTxByte">Os_Cbk_TraceCommTxByte</a></h2><p xmlns="">Callback routine that supplies a byte of trace data for sending.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_TraceCommTxByte(uint8 val)</p><h4 xmlns="">Description</h4><p xmlns="">This is called from UploadTraceData when there is a byte of data to send.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TRACECOMMTXBYTE_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_TraceCommTxByte(uint8 val) {
  /* Called from UploadTraceData when there is a byte ready to send */
  async_transmit(val);
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if Os_UploadTraceData is used.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_UploadTraceData">Os_UploadTraceData</a><br /><a href="#Os_CheckTraceOutput">Os_CheckTraceOutput</a><br /><a href="#Os_Cbk_TraceCommDataReady">Os_Cbk_TraceCommDataReady</a><br /><a href="#Os_Cbk_TraceCommTxStart">Os_Cbk_TraceCommTxStart</a><br /><a href="#Os_Cbk_TraceCommTxEnd">Os_Cbk_TraceCommTxEnd</a><br /><a href="#Os_Cbk_TraceCommTxReady">Os_Cbk_TraceCommTxReady</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TraceCommTxEnd">Os_Cbk_TraceCommTxEnd</a></h2><p xmlns="">Callback routine that signals that the last byte of trace data has been sent.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_TraceCommTxEnd(void)</p><h4 xmlns="">Description</h4><p xmlns="">This is called from UploadTraceData when the last byte of a frame has been sent.</p><p xmlns="">In interrupt mode, this is used to disable the transmit interrupt.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TRACECOMMTXEND_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_TraceCommTxEnd(void)  {
  disable_asyncio_interrupt();
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if Os_UploadTraceData is used.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_UploadTraceData">Os_UploadTraceData</a><br /><a href="#Os_CheckTraceOutput">Os_CheckTraceOutput</a><br /><a href="#Os_Cbk_TraceCommDataReady">Os_Cbk_TraceCommDataReady</a><br /><a href="#Os_Cbk_TraceCommTxStart">Os_Cbk_TraceCommTxStart</a><br /><a href="#Os_Cbk_TraceCommTxByte">Os_Cbk_TraceCommTxByte</a><br /><a href="#Os_Cbk_TraceCommTxReady">Os_Cbk_TraceCommTxReady</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TraceCommTxReady">Os_Cbk_TraceCommTxReady</a></h2><p xmlns="">Callback routine used to discover if there is room to send the next trace data byte.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(boolean, {memclass}) Os_Cbk_TraceCommTxReady(void)</p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type boolean</p><h4 xmlns="">Description</h4><p xmlns="">This is called from UploadTraceData to determine whether there is room in the transmit buffer to send the next byte.</p><p xmlns="">This should always return true in interrupt mode, because the interrupt should only fire when there is room to send the next byte.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TRACECOMMTXREADY_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(boolean, {memclass}) Os_Cbk_TraceCommTxReady(void) {
  return async_tx_ready();
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if Os_UploadTraceData is used.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_UploadTraceData">Os_UploadTraceData</a><br /><a href="#Os_CheckTraceOutput">Os_CheckTraceOutput</a><br /><a href="#Os_Cbk_TraceCommDataReady">Os_Cbk_TraceCommDataReady</a><br /><a href="#Os_Cbk_TraceCommTxStart">Os_Cbk_TraceCommTxStart</a><br /><a href="#Os_Cbk_TraceCommTxByte">Os_Cbk_TraceCommTxByte</a><br /><a href="#Os_Cbk_TraceCommTxEnd">Os_Cbk_TraceCommTxEnd</a><br /></p><h2 xmlns=""><a name="Os_Cbk_TraceCommTxStart">Os_Cbk_TraceCommTxStart</a></h2><p xmlns="">Callback routine that signals that the first byte of trace data is ready to be sent.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) Os_Cbk_TraceCommTxStart(void)</p><h4 xmlns="">Description</h4><p xmlns="">This is called from UploadTraceData when the first byte of a frame is ready to send.</p><p xmlns="">It is immediately followed by a call to Os_Cbk_TraceCommTxByte().</p><p xmlns="">In interrupt mode, this is used to enable the transmit interrupt.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_OS_CBK_TRACECOMMTXSTART_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_TraceCommTxStart(void) {
  enable_asyncio_interrupt();
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">The callback must be provided if Os_UploadTraceData is used.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_UploadTraceData">Os_UploadTraceData</a><br /><a href="#Os_CheckTraceOutput">Os_CheckTraceOutput</a><br /><a href="#Os_Cbk_TraceCommDataReady">Os_Cbk_TraceCommDataReady</a><br /><a href="#Os_Cbk_TraceCommTxByte">Os_Cbk_TraceCommTxByte</a><br /><a href="#Os_Cbk_TraceCommTxEnd">Os_Cbk_TraceCommTxEnd</a><br /><a href="#Os_Cbk_TraceCommTxReady">Os_Cbk_TraceCommTxReady</a><br /></p><h2 xmlns=""><a name="PostTaskHook">PostTaskHook</a></h2><p xmlns="">Callback routine called when context switching from a task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) PostTaskHook(void)</p><h4 xmlns="">Description</h4><p xmlns="">This hook routine is called by the operating system immediately before it leaves the running state.</p><p xmlns="">This means it is safe to evaluate the TaskID.</p><p xmlns="">The PostTaskHook is not called if a task is leaving the running state because the ShutdownOS() call has been made.</p><p xmlns="">A sample PostTaskHook can be generated automatically by rtaosgen. See the RTA-OS User Guide for further details.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_POSTTASKHOOK_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) PostTaskHook(void){
  TaskType LeavingTask;
  GetTaskID(&amp;LeavingTask);
  if (LeavingTask == TaskA) {
    /* Do action for leaving A */
  } else if (LeavingTask == TaskB) {
    /* Do action for leaving B */
  }
  ...
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required when the PostTaskHook is configured.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#PreTaskHook">PreTaskHook</a><br /><a href="#Os_Cbk_TaskEnd">Os_Cbk_TaskEnd</a><br /><a href="#Os_Cbk_ISREnd">Os_Cbk_ISREnd</a><br /></p><h2 xmlns=""><a name="PreTaskHook">PreTaskHook</a></h2><p xmlns="">Callback routine called when context switching into a task.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) PreTaskHook(void)</p><h4 xmlns="">Description</h4><p xmlns="">This hook routine is called by the operating system immediately after it enters the running state but before the task itself begins to execute.</p><p xmlns="">This means it is safe to evaluate the TaskID.</p><p xmlns="">A sample PreTaskHook can be generated automatically by rtaosgen. See the RTA-OS User Guide for further details.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_PRETASKHOOK_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) PreTaskHook(void){
  TaskType EnteringTask;
  GetTaskID(&amp;EnteringTask);
  if (EnteringTask == TaskA) {
    /* Do action for entering A */
  } else if (EnteringTask == TaskB) {
    /* Do action for entering B */
  }
  ...
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required when the PreTaskHook is configured.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#PostTaskHook">PostTaskHook</a><br /><a href="#Os_Cbk_TaskStart">Os_Cbk_TaskStart</a><br /><a href="#Os_Cbk_TaskActivated">Os_Cbk_TaskActivated</a><br /><a href="#Os_Cbk_ISRStart">Os_Cbk_ISRStart</a><br /></p><h2 xmlns=""><a name="ProtectionHook">ProtectionHook</a></h2><p xmlns="">Callback routine used for trapping protection faults.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(ProtectionReturnType, {memclass}) ProtectionHook(StatusType FatalError)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">FatalError</td><td class="CodeBodyText">StatusType</td><td>in</td><td>The type of the error that has occurred.</td></tr></table></p><h4 xmlns="">Return values</h4><p xmlns="">The call returns values of type ProtectionReturnType</p><h4 xmlns="">Description</h4><p xmlns="">This is called when a timing or memory protection fault occurs. The type of fault is passed into ProtectionHook().</p><p xmlns="">The return type determines what action the OS takes after the callback:</p><p xmlns="">PRO_IGNORE: The fault is ignored and processing continues. Only allowed for E_OS_PROTECTION_ARRIVAL.</p><p xmlns="">PRO_TERMINATETASKISR: The task, ISR or protected function that caused the fault is forcibly terminated. Only valid when memory or timing protection are configured.</p><p xmlns="">PRO_TERMINATEAPPL: The OS Application that contains the faulting task or ISR is forcibly terminated. Only valid when memory or timing protection are configured.</p><p xmlns="">PRO_TERMINATEAPPL_RESTART: The OS Application that contains the faulting task or ISR is forcibly terminated and then restarted. Only valid when memory or timing protection are configured.</p><p xmlns="">PRO_SHUTDOWN: ShutdownOS() is called.</p><p xmlns="">If any Category 2 ISR is terminated, the OS will use the callback Os_Cbk_Terminated_&lt;ISRName&gt;() to allow you to ensure that the interrupt source is dealt with appropriately.</p><p xmlns="">ProtectionHook runs at OS level and will not be preempted by Tasks or Category 2 ISRs.</p><p xmlns="">A sample ProtectionHook can be generated automatically by rtaosgen. See the RTA-OS User Guide for further details.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_PROTECTIONHOOK_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(ProtectionReturnType, {memclass}) ProtectionHook(StatusType FatalError) {
  switch (FatalError) {
    case E_OS_PROTECTION_MEMORY:
          /* A memory protection error has been detected */
          break;
    case E_OS_PROTECTION_TIME:
          /* Task, Category 2 ISR or time-limited function exceeds its execution time */
          break;
    case E_OS_PROTECTION_ARRIVAL:
          /* Task/Category 2 arrives before its timeframe has expired */
          return PRO_IGNORE;  /* This is the only case where PRO_IGNORE is allowed */
    case E_OS_PROTECTION_LOCKED:
          /* Task/Category 2 ISR blocks for too long */
          break;
    case E_OS_PROTECTION_EXCEPTION:
          /* Trap occurred */
          break;
  }
  return PRO_SHUTDOWN;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required when the ProtectionHook is configured. Should be configured when timing or memory protection are required.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_Terminated_&lt;ISRName&gt;">Os_Cbk_Terminated_&lt;ISRName&gt;</a><br /></p><h2 xmlns=""><a name="ShutdownHook">ShutdownHook</a></h2><p xmlns="">Callback routine called during OS shutdown.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) ShutdownHook(StatusType Error)</p><h4 xmlns="">Parameters</h4><p xmlns=""><table border="1"><thead><tr><th>Name</th><th>Type</th><th>Mode</th><th>Description</th></tr></thead><tr><td class="CodeBodyText">Error</td><td class="CodeBodyText">StatusType</td><td>in</td><td>The reason for the shutdown.</td></tr></table></p><h4 xmlns="">Description</h4><p xmlns="">If a ShutdownHook() is configured, this hook routine is called by the operating system when the OS API call ShutdownOS() has been called.</p><p xmlns="">This routine is called during the operating system shutdown. The OS can be restarted from the ShutdownHook() using Os_Restart()</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_SHUTDOWNHOOK_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) ShutdownHook(StatusType Error){
  if (Error == E_OS_STACKFAULT) {
    /* Attempt recovery by restart */
    Os_Restart();
    /* Never reach here... */
  } else if (Error == E_OK) {
    /* Normal shutdown procedure */
  }
  ...
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required when the ShutdownHook is configured.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Restart">Os_Restart</a><br /><a href="#StartupHook">StartupHook</a><br /></p><h2 xmlns=""><a name="StartupHook">StartupHook</a></h2><p xmlns="">Callback routine called during OS startup.</p><h4 xmlns="">Syntax</h4><p class="CodeNormal" xmlns="">FUNC(void, {memclass}) StartupHook(void)</p><h4 xmlns="">Description</h4><p xmlns="">If a StartupHook() is configured, this hook routine is called by the OS at the end of the OS initialization, but before the scheduler is running.</p><p xmlns="">The application can start tasks, initialize device drivers and so on within StartupHook().</p><p xmlns="">StartupHook() runs with Category2 ISRs disabled so it is safe to enable interrupt sources from the hook.</p><p xmlns="">Note: {memclass} is OS_APPL_CODE for AUTOSAR 3.x, OS_CALLOUT_CODE for AUTOSAR 4.0, OS_STARTUPHOOK_CODE for AUTOSAR 4.1.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) StartupHook(void){
  /* Enable timer interrupt */
  CHANNEL0_CONTROL_REG |= ONE_MILLISECOND_TIMER;
  CHANNEL0_CONTROL_REG |= ENABLE;
}
</p></pre><h4 xmlns="">Existence Condition</h4><p xmlns="">Required when the StartupHook is configured.</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ShutdownHook">ShutdownHook</a><br /></p><h1><a name="TYPES">Types</a></h1><h2 xmlns=""><a name="AccessType">AccessType</a></h2><p xmlns="">An integral value that holds information about how a specific memory region can be accessed.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Constants</h4><p class="CodeNormal" xmlns="">OS_ACCESS_READ<br />OS_ACCESS_WRITE<br />OS_ACCESS_EXECUTE<br />OS_ACCESS_STACK<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(AccessType,{memclass}) Os_Cbk_CheckMemoryAccess(ApplicationType Application, TaskType TaskID, ISRType ISRID, MemoryStartAddressType Address, MemorySizeType Size) {
  AccessType Access = OS_ACCESS_EXECUTE;
  /* Address range is read/write if it is in RAM */
  if ((Address &gt;= RAM_BASE) &amp;&amp; (Address + Size &lt; RAM_BASE + RAM_SIZE) ) {
      Access |= (OS_ACCESS_WRITE | OS_ACCESS_READ);
  }
  ...
  return Access;
}
</p></pre><h2 xmlns=""><a name="AlarmBaseRefType">AlarmBaseRefType</a></h2><p xmlns="">A pointer to an object of AlarmBaseType.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">AlarmBaseType AlarmBase;
AlarmBaseRefType AlarmBaseRef = &amp;AlarmBase;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#AlarmBaseType">AlarmBaseType</a><br /></p><h2 xmlns=""><a name="AlarmBaseType">AlarmBaseType</a></h2><p xmlns="">Defines the configuration of a counter. The type is a C struct that contains the fields maxallowedvalue, ticksperbase and mincycle.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">All values are of type TickType.<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TickType         max,min,ticks;
AlarmBaseType    SomeAlarmBase;
AlarmBaseRefType PointerToSomeAlarmBase = &amp;SomeAlarmBase;
max   = SomeAlarmBase.maxallowedvalue;
ticks = SomeAlarmBase.ticksperbase;
min   = SomeAlarmBase.mincycle;
</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#AlarmBaseRefType">AlarmBaseRefType</a><br /><a href="#TickType">TickType</a><br /></p><h2 xmlns=""><a name="AlarmType">AlarmType</a></h2><p xmlns="">The type of an Alarm.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">AlarmType SomeAlarm;</p></pre><h2 xmlns=""><a name="ApplicationStateRefType">ApplicationStateRefType</a></h2><p xmlns="">A pointer to an object of ApplicationStateType.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ApplicationStateRefType SomeState = &amp;state_variable;
GetApplicationState(MyApp, SomeState);</p></pre><h2 xmlns=""><a name="ApplicationStateType">ApplicationStateType</a></h2><p xmlns="">Enumerated type defining the state of an OS-Application.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">APPLICATION_ACCESSIBLE<br />APPLICATION_RESTARTING<br />APPLICATION_TERMINATED<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">GetApplicationState(MyApp, &amp;MyAppState);
if (MyAppState == APPLICATION_RESTARTING) {...}</p></pre><h2 xmlns=""><a name="ApplicationType">ApplicationType</a></h2><p xmlns="">The type of an OS-Application.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">Symbolic names of the OS-Applications declared at configuration time.<br /></p><h4 xmlns="">Constants</h4><p class="CodeNormal" xmlns="">INVALID_OSAPPLICATION<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ApplicationType SomeOSApplication;</p></pre><h2 xmlns=""><a name="AppModeType">AppModeType</a></h2><p xmlns="">The type of an application mode.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">Symbolic names of the application modes declared at configuration time. (Must include OSDEFAULTAPPMODE)<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">AppModeType SomeAppMode;</p></pre><h2 xmlns=""><a name="boolean">boolean</a></h2><p xmlns="">Addressable 8 bits only for use with TRUE/FALSE. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">0=FALSE<br />1=TRUE<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">if (Condition == TRUE) {
  x = y;
}</p></pre><h2 xmlns=""><a name="CoreIdType">CoreIdType</a></h2><p xmlns="">Scalar representing the ID of a processor core.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CoreIdType core = GetCoreID();</p></pre><h2 xmlns=""><a name="CounterType">CounterType</a></h2><p xmlns="">The type of a Counter.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CounterType SomeCounter;</p></pre><h2 xmlns=""><a name="EventMaskRefType">EventMaskRefType</a></h2><p xmlns="">A pointer to an object of EventMaskType.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">EventMaskRefType SomeEventRef;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#EventMaskType">EventMaskType</a><br /></p><h2 xmlns=""><a name="EventMaskType">EventMaskType</a></h2><p xmlns="">The type of an event.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">Symbolic names of the EventMasks declared at configuration time.<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">EventMaskType SomeEvent;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#EventMaskRefType">EventMaskRefType</a><br /></p><h2 xmlns=""><a name="float32">float32</a></h2><p xmlns="">Single precision floating point number. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">float32 x;</p></pre><h2 xmlns=""><a name="float64">float64</a></h2><p xmlns="">Double precision floating point number. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">float64 x;</p></pre><h2 xmlns=""><a name="ISRRefType">ISRRefType</a></h2><p xmlns="">A pointer to an object of ISRType.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ISRType SomeISR;
ISRRefType PointerToSomeISR = &amp;SomeISR;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ISRType">ISRType</a><br /></p><h2 xmlns=""><a name="ISRType">ISRType</a></h2><p xmlns="">The type of a ISR.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">The symbolic names of ISRs declared at configuration time.<br /></p><h4 xmlns="">Constants</h4><p class="CodeNormal" xmlns="">INVALID_ISR<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ISRType SomeISR;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ISRRefType">ISRRefType</a><br /><a href="#OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a><br /><a href="#OS_INDEX_TO_ISRTYPE">OS_INDEX_TO_ISRTYPE</a><br /></p><h2 xmlns=""><a name="MemorySizeType">MemorySizeType</a></h2><p xmlns="">This data type holds the size (in bytes) of a memory region.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">MemorySizeType DatumSize = sizeof(datum);
CheckISRMemoryAccess(SomeISR, &amp;datum, DatumSize);
</p></pre><h2 xmlns=""><a name="MemoryStartAddressType">MemoryStartAddressType</a></h2><p xmlns="">This data type is a pointer which is able to point to any location in the address space.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">MemoryStartAddressType StartAddress  = &amp;datum;
CheckISRMemoryAccess(SomeISR, StartAddress, sizeof(datum));
</p></pre><h2 xmlns=""><a name="ObjectAccessType">ObjectAccessType</a></h2><p xmlns="">Enumerated type defining whether an OS-Application has access to an object.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">ACCESS<br />NO_ACCESS<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">if (ACCESS == CheckObjectAccess(MyOSApp, OBJECT_TASK, MyTask) {...}</p></pre><h2 xmlns=""><a name="ObjectTypeType">ObjectTypeType</a></h2><p xmlns="">Enumerated type defining the type of an OS object.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">OBJECT_TASK<br />OBJECT_ISR<br />OBJECT_ALARM<br />OBJECT_RESOURCE<br />OBJECT_COUNTER<br />OBJECT_SCHEDULETABLE<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">if (ACCESS == CheckObjectAccess(MyOSApp, OBJECT_TASK, MyTask) {...}</p></pre><h2 xmlns=""><a name="Os_AnyType">Os_AnyType</a></h2><p xmlns="">A reference to an OS object.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CheckObjectOwnership(OBJECT_TASK, Task1);</p></pre><h2 xmlns=""><a name="Os_AsyncPushCallbackType">Os_AsyncPushCallbackType</a></h2><p xmlns="">Type that represents a pointer to a void function that gets passed a single uint8 value. Used by Os_TraceDumpAsync()</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="Os_CounterStatusRefType">Os_CounterStatusRefType</a></h2><p xmlns="">A pointer to an object of Os_CounterStatusType.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_CounterStatusType MyHwCounterStatus;
do {
  Os_AdvanceCounter_MyHWCounter();
  Os_Cbk_State_MyHWCounter(&amp;MyHwCounterStatus);
} while (MyHwCounterStatus.Running &amp;&amp; MyHwCounterStatus.Pending);
</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_CounterStatusType">Os_CounterStatusType</a><br /></p><h2 xmlns=""><a name="Os_CounterStatusType">Os_CounterStatusType</a></h2><p xmlns="">Defines the status of a hardware counter. The type is a C struct that contains the fields Running, Pending and Delay.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_CounterStatusType CounterStatus;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TickType">TickType</a><br /><a href="#CounterType">CounterType</a><br /></p><h2 xmlns=""><a name="Os_SpinlockInfo">Os_SpinlockInfo</a></h2><p xmlns="">Contains the spinlock statistics information that can be returned from the GetSpinlockInfo API</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">CoreIdType CurrentLockingCore<br />Os_StopwatchTickType CurrentLockTime<br />Os_LockerRefType CurrentLocker<br />uint32 LockAttempts[OS_NUM_CORES]<br />uint32 LockSucceeds[OS_NUM_CORES]<br />uint32 LockFails[OS_NUM_CORES]<br />Os_StopwatchTickType MaxLockTime[OS_NUM_CORES]<br />Os_LockerRefType MaxLockTimeLocker[OS_NUM_CORES]<br />Os_StopwatchTickType MaxSpinTime[OS_NUM_CORES]<br />Os_LockerRefType MaxSpinTimeLocker[OS_NUM_CORES]<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_SpinlockInfo Info;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetSpinlockInfo">GetSpinlockInfo</a><br /><a href="#ResetSpinlockInfo">ResetSpinlockInfo</a><br /><a href="#Os_SpinlockInfoRefType">Os_SpinlockInfoRefType</a><br /></p><h2 xmlns=""><a name="Os_SpinlockInfoRefType">Os_SpinlockInfoRefType</a></h2><p xmlns="">A pointer to an object of Os_LockerRefType.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  Os_SpinlockInfo Info;
  GetSpinlockInfo(Spinlock1, &amp;Info);
  if ((TaskType)Info.CurrentLocker == MyTask) {
    ...
  }
}
</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SpinlockInfo">Os_SpinlockInfo</a><br /></p><h2 xmlns=""><a name="Os_StackOverrunType">Os_StackOverrunType</a></h2><p xmlns="">Enumerated type defining the reason for a stack overrun.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">OS_BUDGET<br />OS_ECC_START<br />OS_ECC_RESUME<br />OS_ECC_WAIT<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_StackOverrunHook(Os_StackSizeType Overrun, Os_StackOverrunType Reason) {
  switch (Reason) {
    case OS_BUDGET:
      /* The currently running task or ISR has exceeded its stack budget */
      break;
    case OS_ECC_START:
      /* An ECC task has failed to start because there is insufficient room on the stack */
      break;
    case OS_ECC_RESUME:
      /* An ECC task has failed to resume from wait because there is insufficient room on the stack */
      break;
    case OS_ECC_WAIT:
      /* An ECC task has failed to enter the waiting state because it is exceeding its stack budget */
      break;
  }
}
</p></pre><h2 xmlns=""><a name="Os_StatusRefType">Os_StatusRefType</a></h2><p xmlns="">A pointer to a StatusType.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">StatusType status;
Os_StatusRefType status_ref = &amp;status;
...
StartCore(OS_CORE_ID_0, status_ref);</p></pre><h2 xmlns=""><a name="Os_StopwatchTickRefType">Os_StopwatchTickRefType</a></h2><p xmlns="">A pointer to an object of Os_StopwatchTickType.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StopwatchTickRefType SomeTick = &amp;tickvalue;
Os_GetTaskActivationTime(MyTask, SomeTick);</p></pre><h2 xmlns=""><a name="Os_StopwatchTickType">Os_StopwatchTickType</a></h2><p xmlns="">Scalar representing ticks of a stopwatch (time monitoring or protection) counter.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_StopwatchTickType Duration;
GetExecutionTime(&amp;Duration);</p></pre><h2 xmlns=""><a name="Os_TasksetType">Os_TasksetType</a></h2><p xmlns="">This type may only be used when delayed task execution is configured. It is used to contain a set of Tasks.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Constants</h4><p class="CodeNormal" xmlns="">OS_NO_TASKS<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TasksetType t1 = TASK_MASK(Task1);</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SetDelayedTasks">Os_SetDelayedTasks</a><br /><a href="#Os_AddDelayedTasks">Os_AddDelayedTasks</a><br /><a href="#Os_RemoveDelayedTasks">Os_RemoveDelayedTasks</a><br /><a href="#OS_NO_TASKS">OS_NO_TASKS</a><br /><a href="#TASK_MASK">TASK_MASK</a><br /><a href="#TaskType">TaskType</a><br /></p><h2 xmlns=""><a name="Os_TimeLimitType">Os_TimeLimitType</a></h2><p xmlns="">Scalar representing an execution time limit, used with timing protection. The duration of one Os_TimeLimitType is the same as one Os_StopwatchTickType</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TimeLimitType limit = 100;
CallAndProtectFunction(Func3, &amp;data, limit);</p></pre><h2 xmlns=""><a name="Os_TraceCategoriesType">Os_TraceCategoriesType</a></h2><p xmlns="">Type that is used to contain mask values relating to user-defined trace filter categories. An all and a non category are defined by default.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">OS_TRACE_NO_CATEGORIES<br />OS_TRACE_ALL_CATEGORIES<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TraceCategoriesType ExtraTracing = DebugTracePoints | DataLogTracePoints;</p></pre><h2 xmlns=""><a name="Os_TraceClassesType">Os_TraceClassesType</a></h2><p xmlns="">Type that is used to contain mask values relating to trace filter classes.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">OS_TRACE_ACTIVATIONS_CLASS<br />OS_TRACE_RESOURCES_CLASS<br />OS_TRACE_INTERRUPT_LOCKS_CLASS<br />OS_TRACE_SWITCHING_OVERHEADS_CLASS<br />OS_TRACE_TASKS_AND_ISRS_CLASS<br />OS_TRACE_ERRORS_CLASS<br />OS_TRACE_TASK_TRACEPOINT_CLASS<br />OS_TRACE_TRACEPOINT_CLASS<br />OS_TRACE_INTERVALS_CLASS<br />OS_TRACE_MESSAGE_DATA_CLASS<br />OS_TRACE_STARTUP_AND_SHUTDOWN_CLASS<br />OS_TRACE_ALARMS_CLASS<br />OS_TRACE_SCHEDULETABLES_CLASS<br />OS_TRACE_OSEK_EVENTS_CLASS<br />OS_TRACE_EXPIRY_POINTS_CLASS<br />OS_TRACE_NO_CLASSES<br />OS_TRACE_ALL_CLASSES<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TraceClassesType AllTracepoints = OS_TRACE_TRACEPOINT_CLASS | OS_TRACE_TASK_TRACEPOINT_CLASS;</p></pre><h2 xmlns=""><a name="Os_TraceDataLengthType">Os_TraceDataLengthType</a></h2><p xmlns="">The length of a data block (in bytes).</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TraceDataLengthType BlockLength = 8;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TraceDataPtrType">Os_TraceDataPtrType</a><br /></p><h2 xmlns=""><a name="Os_TraceDataPtrType">Os_TraceDataPtrType</a></h2><p xmlns="">A pointer to a block of data to log at a trace point or interval.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TraceDataPtrType DataPtr;
uint8 DataValues[10];
...
 DataPtr = &amp;DataValue;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_TraceDataLengthType">Os_TraceDataLengthType</a><br /></p><h2 xmlns=""><a name="Os_TraceExpiryIDType">Os_TraceExpiryIDType</a></h2><p xmlns="">Enumerated type that defines Expiry points.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">The names of expiry points. These are generated using the pattern &lt;scheduletable_name&gt;_&lt;expiry_name&gt;.<br /></p><h2 xmlns=""><a name="Os_TraceIndexType">Os_TraceIndexType</a></h2><p xmlns="">An unsigned integer value of at least 16 bits representing a number of trace records.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TraceIndexType PreTriggerRecords = 100;</p></pre><h2 xmlns=""><a name="Os_TraceInfoType">Os_TraceInfoType</a></h2><p xmlns="">An unsigned integer value representing a traced object.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="Os_TraceIntervalIDType">Os_TraceIntervalIDType</a></h2><p xmlns="">Enumerated type that defines RTA-TRACE trace intervals.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">The names of user defined trace intervals.<br /></p><h2 xmlns=""><a name="Os_TraceStatusType">Os_TraceStatusType</a></h2><p xmlns="">Type containing the status of a trace API call.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">OS_TRACE_STATUS_OK<br />OS_TRACE_STATUS_COMM_INIT_FAILURE<br /></p><h2 xmlns=""><a name="Os_TraceTracepointIDType">Os_TraceTracepointIDType</a></h2><p xmlns="">Enumerated type that defines RTA-TRACE tracepoints.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">The names of user defined trace points.<br /></p><h2 xmlns=""><a name="Os_TraceValueType">Os_TraceValueType</a></h2><p xmlns="">An unsigned integer value representing either 16 or 32 bits depending on the configuration of compact time.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="Os_UntrustedContextRefType">Os_UntrustedContextRefType</a></h2><p xmlns="">A pointer to an object of Os_UntrustedContextType.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_SetMemoryAccess(Os_UntrustedContextRefType ApplicationContext) {}</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_UntrustedContextType">Os_UntrustedContextType</a><br /></p><h2 xmlns=""><a name="Os_UntrustedContextType">Os_UntrustedContextType</a></h2><p xmlns="">Defines the context of the untrusted code that is about to be executed. It is only used by the Os_Cbk_SetMemoryAccess() callback when memory protection features are configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">ApplicationType Application<br />TaskType TaskID<br />ISRType ISRID<br />MemoryStartAddressType Address<br />MemorySizeType Size<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) Os_Cbk_SetMemoryAccess(Os_UntrustedContextRefType ApplicationContext) {}</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_SetMemoryAccess">Os_Cbk_SetMemoryAccess</a><br /><a href="#Os_UntrustedContextRefType">Os_UntrustedContextRefType</a><br /></p><h2 xmlns=""><a name="OSServiceIdType">OSServiceIdType</a></h2><p xmlns="">The type of a OS API call. Used only in the ErrorHook(). The values take the form OSServiceId__APICallName_ where _APICallName_ represents the name of an API call (without any leading Os_).</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(void, {memclass}) ErrorHook(StatusType Error){
  OSServiceIdType ServiceExecuting;
  ServiceExecuting = OSError_GetServiceID();
  switch ( ServiceExecuting ) {
    case OSServiceId_None: /* Used for errors detected when an ISR exits with resources or interrupts locked */
      ...
      break;
    case OSServiceId_ActivateTask:
      ...
      break;
    case OSServiceId_CancelAlarm:
      ...
      break;
    case OSServiceId_ChainTask:
      ...
      break;
    ...
    default:
      ...
  }
}
</p></pre><h2 xmlns=""><a name="OsTrapInfoRefType">OsTrapInfoRefType</a></h2><p xmlns="">A pointer to an object of OsTrapInfoType.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">OsTrapInfoRefType trap_info_ref = &amp;trap_info;
Os_GetTrapInfo(trap_info_ref);</p></pre><h2 xmlns=""><a name="OsTrapInfoType">OsTrapInfoType</a></h2><p xmlns="">Structure used by the Os_GetTrapInfo() API to return information about unhandled traps.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_GetTrapInfo">Os_GetTrapInfo</a><br /></p><h2 xmlns=""><a name="PhysicalTimeType">PhysicalTimeType</a></h2><p xmlns="">Scalar representing a units of physical (wall clock) time.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">PhysicalTimeType Milliseconds = OS_TICKS2MS_MyCounter(42);</p></pre><h2 xmlns=""><a name="ProtectionReturnType">ProtectionReturnType</a></h2><p xmlns="">Enumerated type defining the action taken following a protection fault.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">PRO_IGNORE<br />PRO_TERMINATETASKISR<br />PRO_TERMINATEAPPL<br />PRO_TERMINATEAPPL_RESTART<br />PRO_SHUTDOWN<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(ProtectionReturnType, {memclass}) ProtectionHook(StatusType FatalError) {
  switch (FatalError) {
    case E_OS_PROTECTION_MEMORY:
          /* A memory protection error has been detected */
          break;
    case E_OS_PROTECTION_TIME:
          /* Task, Category 2 ISR or time-limited function exceeds its execution time */
          break;
    case E_OS_PROTECTION_ARRIVAL:
          /* Task/Category 2 arrives before its timeframe has expired */
          return PRO_IGNORE;  /* This is the only case where PRO_IGNORE is allowed */
    case E_OS_PROTECTION_LOCKED:
          /* Task/Category 2 ISR blocks for too long */
          break;
    case E_OS_PROTECTION_EXCEPTION:
          /* Trap occurred */
          break;
  }
  return PRO_SHUTDOWN;
}
</p></pre><h2 xmlns=""><a name="ResourceType">ResourceType</a></h2><p xmlns="">The type of a Resource.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">RES_SCHEDULER plus the symbolic names of Resources declared at configuration time.<br /></p><h4 xmlns="">Constants</h4><p class="CodeNormal" xmlns="">RES_SCHEDULER<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ResourceType SomeResource;</p></pre><h2 xmlns=""><a name="RestartType">RestartType</a></h2><p xmlns="">Enumerated type defining the action to be taken in TerminateApplication().</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">RESTART<br />NO_RESTART<br /></p><h2 xmlns=""><a name="ScheduleTableRefType">ScheduleTableRefType</a></h2><p xmlns="">A pointer to an object of ScheduleTableType.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ScheduleTableType SomeScheduleTable;
ScheduleTableRefType PointerToSomeScheduleTable = &amp;SomeScheduleTable;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ScheduleTableStatusType">ScheduleTableStatusType</a><br /></p><h2 xmlns=""><a name="ScheduleTableStatusRefType">ScheduleTableStatusRefType</a></h2><p xmlns="">A pointer to an object of ScheduleTableStatusType.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ScheduleTableStatusType SomeScheduleTableStatus;
GetScheduleTableStatus(&amp;SomeScheduleTableStatus);</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ScheduleTableStatusType">ScheduleTableStatusType</a><br /></p><h2 xmlns=""><a name="ScheduleTableStatusType">ScheduleTableStatusType</a></h2><p xmlns="">Enumerated type defining the runtime state of a schedule table.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">SCHEDULETABLE_STOPPED<br />SCHEDULETABLE_NEXT<br />SCHEDULETABLE_WAITING<br />SCHEDULETABLE_RUNNING<br />SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ScheduleTableStatusType SomeScheduleTableStatus;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ScheduleTableStatusRefType">ScheduleTableStatusRefType</a><br /></p><h2 xmlns=""><a name="ScheduleTableType">ScheduleTableType</a></h2><p xmlns="">The type of a ScheduleTable.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ScheduleTableType SomeScheduleTable;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ScheduleTableStatusType">ScheduleTableStatusType</a><br /><a href="#ScheduleTableStatusRefType">ScheduleTableStatusRefType</a><br /></p><h2 xmlns=""><a name="SignedTickType">SignedTickType</a></h2><p xmlns="">Signed Scalar representing a ticks of a counter.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">SignedTickType drift = -2;
Os_SyncScheduleTableRel(MyTable, drift);</p></pre><h2 xmlns=""><a name="sint16">sint16</a></h2><p xmlns="">Signed 16-bit integer. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">-32768..32767<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">sint16 x;</p></pre><h2 xmlns=""><a name="sint16_least">sint16_least</a></h2><p xmlns="">Signed integer at least 16-bits wide. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">At least -32768..32767<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">sint16_least x;</p></pre><h2 xmlns=""><a name="sint32">sint32</a></h2><p xmlns="">Signed 32-bit integer. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">-2147483648..2147483647<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">sint32 x;</p></pre><h2 xmlns=""><a name="sint32_least">sint32_least</a></h2><p xmlns="">Signed integer at least 32-bits wide. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">At least -2147483648..2147483647<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">sint32_least x;</p></pre><h2 xmlns=""><a name="sint8">sint8</a></h2><p xmlns="">Signed 8-bit integer. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">-128..127<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">sint8 x;</p></pre><h2 xmlns=""><a name="sint8_least">sint8_least</a></h2><p xmlns="">Signed integer at least 8-bits wide. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">At least -128..127<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">sint8_least x;</p></pre><h2 xmlns=""><a name="SpinlockIdType">SpinlockIdType</a></h2><p xmlns="">The type of a Spinlock.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">The symbolic names of spinlocks declared at configuration time.<br /></p><h4 xmlns="">Constants</h4><p class="CodeNormal" xmlns="">INVALID_SPINLOCK<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask){
  ...
  GetSpinlock(Spinlock1);
  ...
  ReleaseSpinlock(Spinlock1);
}
</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#GetSpinlock">GetSpinlock</a><br /><a href="#TryToGetSpinlock">TryToGetSpinlock</a><br /><a href="#ReleaseSpinlock">ReleaseSpinlock</a><br /><a href="#UncheckedGetSpinlock">UncheckedGetSpinlock</a><br /><a href="#UncheckedTryToGetSpinlock">UncheckedTryToGetSpinlock</a><br /><a href="#UncheckedReleaseSpinlock">UncheckedReleaseSpinlock</a><br /></p><h2 xmlns=""><a name="StatusType">StatusType</a></h2><p xmlns="">Enumeration type defining the status of an API call.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">E_OK<br />E_OS_ACCESS<br />E_OS_CALLEVEL<br />E_OS_ID<br />E_OS_LIMIT<br />E_OS_NOFUNC<br />E_OS_RESOURCE<br />E_OS_STATE<br />E_OS_VALUE<br />E_OS_SERVICEID<br />E_OS_ILLEGAL_ADDRESS<br />E_OS_MISSINGEND<br />E_OS_DISABLEDINT<br />E_OS_STACKFAULT<br />E_OS_PROTECTION_MEMORY<br />E_OS_PROTECTION_TIME<br />E_OS_PROTECTION_ARRIVAL<br />E_OS_PROTECTION_LOCKED<br />E_OS_PROTECTION_EXCEPTION<br />E_OS_CORE<br />E_OS_SPINLOCK<br />E_OS_INTERFERENCE_DEADLOCK<br />E_OS_NESTING_DEADLOCK<br />E_OS_SYS_NO_RESTART<br />E_OS_SYS_RESTART<br />E_OS_SYS_OVERRUN<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">StatusType ErrorCode;
ErrorCode = ActivateTask(MyTask);</p></pre><h2 xmlns=""><a name="Std_ReturnType">Std_ReturnType</a></h2><p xmlns="">AUTOSAR's standard API service return type. This is only used by AUTOSAR OS for the IOC API. The type is an 8-bit unsigned integer whose top 6 bits may encode module-specific error codes.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">E_OK=0<br />E_NOT_OK<br />IOC_E_OK<br />IOC_E_NOK<br />IOC_E_LIMIT<br />IOC_E_LOST_DATA<br />IOC_E_NO_DATA<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Std_ReturnType ErrorCode;
ErrorCode = IocSend_OverTheRainbow(Dorothy);
if (ErrorCode == IOC_E_OK)  {
  /* call succeeded */
} else {
  /* call failed */
}
</p></pre><h2 xmlns=""><a name="Std_VersionInfoType">Std_VersionInfoType</a></h2><p xmlns="">A C struct whose fields contained AUTOSAR version information for a module. (Defined in Std_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">The field vendorID for ETAS is 11<br />The field moduleID for AUTOSAR OS is 1<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Std_VersionInfoType Version;
GetVersionInfo(&amp;Version);
if (Version.vendorID == 11) {
  /* Make ETAS-specific API call */
  AdvanceCounter(HardwareCounter);
}
</p></pre><h2 xmlns=""><a name="TaskRefType">TaskRefType</a></h2><p xmlns="">A pointer to an object of TaskType.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TaskType SomeTask;
TaskRefType TaskRef = &amp;SomeTask;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TaskType">TaskType</a><br /></p><h2 xmlns=""><a name="TaskStateRefType">TaskStateRefType</a></h2><p xmlns="">A pointer to an object of TaskStateType.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TaskStateType TaskState;
TaskStateRefType TaskStateRef = &amp;TaskState;</p></pre><h2 xmlns=""><a name="TaskStateType">TaskStateType</a></h2><p xmlns="">Enumerated type defining the current state of a task.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">SUSPENDED<br />READY<br />WAITING<br />RUNNING<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TaskStateType TaskState;
GetTaskState(&amp;TaskState);</p></pre><h2 xmlns=""><a name="TaskType">TaskType</a></h2><p xmlns="">The type of a task.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">The symbolic names of tasks declared at configuration time.<br /></p><h4 xmlns="">Constants</h4><p class="CodeNormal" xmlns="">INVALID_TASK<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TaskType SomeTask;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TaskRefType">TaskRefType</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /><a href="#OS_INDEX_TO_TASKTYPE">OS_INDEX_TO_TASKTYPE</a><br /></p><h2 xmlns=""><a name="TickRefType">TickRefType</a></h2><p xmlns="">A pointer to an object of TickType.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TickRefType SomeTick = &amp;tickvalue;
GetCounterValue(MyCounter,SomeTick);</p></pre><h2 xmlns=""><a name="TickType">TickType</a></h2><p xmlns="">Scalar representing ticks of a counter.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TickType StartTime = 42;
TickType NoRepeat = 0;
SetAbsAlarm(MyAlarm,StartTime,NoRepeat);</p></pre><h2 xmlns=""><a name="TrustedFunctionIndexType">TrustedFunctionIndexType</a></h2><p xmlns="">The index value of a Trusted function.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">Symbolic names of the Trusted functions declared at configuration time.<br /></p><h4 xmlns="">Constants</h4><p class="CodeNormal" xmlns="">INVALID_FUNCTION<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CallTrustedFunction(Func3, &amp;data);</p></pre><h2 xmlns=""><a name="TrustedFunctionParameterRefType">TrustedFunctionParameterRefType</a></h2><p xmlns="">A reference to the parameters for a Trusted function.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">CallTrustedFunction(Func3, &amp;data);</p></pre><h2 xmlns=""><a name="TryToGetSpinlockType">TryToGetSpinlockType</a></h2><p xmlns="">Enumerated type defining the result of a call to TryToGetSpinlock.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">TRYTOGETSPINLOCK_SUCCESS<br />TRYTOGETSPINLOCK_NOSUCCESS<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TryToGetSpinlock(MyLock, &amp;retval);
if (retval == TRYTOGETSPINLOCK_SUCCESS) {...}</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TryToGetSpinlock">TryToGetSpinlock</a><br /></p><h2 xmlns=""><a name="uint16">uint16</a></h2><p xmlns="">Unsigned 16-bit integer. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">0..65535<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint16 x;</p></pre><h2 xmlns=""><a name="uint16_least">uint16_least</a></h2><p xmlns="">Unsigned integer at least 16-bits wide. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">At least 0..65535<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint16_least x;</p></pre><h2 xmlns=""><a name="uint32">uint32</a></h2><p xmlns="">Unsigned 32-bit integer. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">0..4294967295<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint32 x;</p></pre><h2 xmlns=""><a name="uint32_least">uint32_least</a></h2><p xmlns="">Unsigned integer at least 32-bits wide. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">At least 0..4294967295<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint32_least x;</p></pre><h2 xmlns=""><a name="uint8">uint8</a></h2><p xmlns="">Unsigned 8-bit integer. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">0..255<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint8 x;</p></pre><h2 xmlns=""><a name="uint8_least">uint8_least</a></h2><p xmlns="">Unsigned integer at least 8-bits wide. (Defined in Platform_Types.h)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Values</h4><p class="CodeNormal" xmlns="">At least 0..255<br /></p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint8_least x;</p></pre><h1><a name="MACROS">Macros</a></h1><h2 xmlns=""><a name="ALARMCALLBACK">ALARMCALLBACK</a></h2><p xmlns="">Declares an alarm callback. The only OS API calls that can be made in an alarm callback are SuspendAllInterrupts() and ResumeAllInterrupts().</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ALARMCALLBACK(MyCallback){...}</p></pre><h2 xmlns=""><a name="DeclareAlarm">DeclareAlarm</a></h2><p xmlns="">This is used to declare an alarm and works similarly to external declaration of variables in C. You will not normally need to use this because RTA-OS automatically declares all Alarms in your configuration.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">DeclareAlarm(MyAlarm);</p></pre><h2 xmlns=""><a name="DeclareCounter">DeclareCounter</a></h2><p xmlns="">This is used to declare a Counter and works similarly to external declaration of variables in C. You will not normally need to use this because RTA-OS automatically declares all Counters in your configuration.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">DeclareCounter(MyCounter);</p></pre><h2 xmlns=""><a name="DeclareEvent">DeclareEvent</a></h2><p xmlns="">This is used to declare an Event and works similarly to external declaration of variables in C. You will not normally need to use this because RTA-OS automatically declares all Events in your configuration.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">DeclareEvent(MyEvent);</p></pre><h2 xmlns=""><a name="DeclareISR">DeclareISR</a></h2><p xmlns="">This is used to declare an ISR and works similarly to external declaration of variables in C. You will not normally need to use this because RTA-OS automatically declares all ISRs in your configuration.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">DeclareISR(MyISR);</p></pre><h2 xmlns=""><a name="DeclareResource">DeclareResource</a></h2><p xmlns="">This is used to declare a Resource and works similarly to external declaration of variables in C. You will not normally need to use this because RTA-OS automatically declares all Resources in your configuration.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">DeclareResource(MyResource);</p></pre><h2 xmlns=""><a name="DeclareResource">DeclareResource</a></h2><p xmlns="">This is used to declare a Resource and works similarly to external declaration of variables in C. You will not normally need to use this because RTA-OS automatically declares all Resources in your configuration.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">DeclareResource(MyResource);</p></pre><h2 xmlns=""><a name="DeclareScheduleTable">DeclareScheduleTable</a></h2><p xmlns="">This is used to declare a ScheduleTable and works similarly to external declaration of variables in C. You will not normally need to use this because RTA-OS automatically declares all ScheduleTables in your configuration.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">DeclareScheduleTable(MyScheduleTable);</p></pre><h2 xmlns=""><a name="DeclareTask">DeclareTask</a></h2><p xmlns="">This is used to declare a Task and works similarly to external declaration of variables in C. You will not normally need to use this because RTA-OS automatically declares all Tasks in your configuration.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">DeclareTask(MyTask);</p></pre><h2 xmlns=""><a name="DONOTCARE">DONOTCARE</a></h2><p xmlns="">In a multicore system, all but one call to StartOS can pass DONOTCARE as the AppModeType.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="INVALID_SPINLOCK">INVALID_SPINLOCK</a></h2><p xmlns="">Represents 'no spinlock'.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="ISR">ISR</a></h2><p xmlns="">Macro that must be used to create a Category 2 ISR entry function.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ISR(MyISR) {...}</p></pre><h2 xmlns=""><a name="OS_ACTIVATION_MONITORING">OS_ACTIVATION_MONITORING</a></h2><p xmlns="">This macro is only defined if task activation monitoring is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_ACTIVATION_MONITORING
Os_StopwatchTickType t;
Os_GetTaskActivationTime(MyTask,&amp;t);
#endif
</p></pre><h2 xmlns=""><a name="OS_ADD_TASK">OS_ADD_TASK</a></h2><p xmlns="">This macro is used to add a Task to an Os_TasksetType. It may only be used when delayed task execution is configured. It must be used when there are more than 64 tasks in the system, but below this you can OR task masks together.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TasksetType t1_and_t3 = TASK_MASK(Task1);
OS_ADD_TASK(t1_and_t3, Task3);</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SetDelayedTasks">Os_SetDelayedTasks</a><br /><a href="#Os_AddDelayedTasks">Os_AddDelayedTasks</a><br /><a href="#Os_RemoveDelayedTasks">Os_RemoveDelayedTasks</a><br /><a href="#OS_NO_TASKS">OS_NO_TASKS</a><br /><a href="#TASK_MASK">TASK_MASK</a><br /><a href="#Os_TasksetType">Os_TasksetType</a><br /></p><h2 xmlns=""><a name="OS_CORE_CURRENT">OS_CORE_CURRENT</a></h2><p xmlns="">The ID of the calling core for the APIs Os_GetIdleElapsedTime and Os_ResetIdleElapsedTime.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_CORE_FOR_&lt;TaskOrISR&gt;">OS_CORE_FOR_&lt;TaskOrISR&gt;</a></h2><p xmlns="">Returns the ID of the core on which the Task or ISR runs. Only available on multi-core.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">  CoreIdType core;
  core = OS_CORE_FOR_MyTask;
  core = OS_CORE_FOR_MyCat2ISR;
  core = OS_CORE_FOR_MyCat1ISR;
</p></pre><h2 xmlns=""><a name="OS_CORE_FOR_ISR">OS_CORE_FOR_ISR</a></h2><p xmlns="">Returns the ID of the core on which the ISR runs. Only available on multi-core. May only be passed the name of the ISR.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">  CoreIdType core;
  core = OS_CORE_FOR_ISR(MyCat2ISR);
  core = OS_CORE_FOR_ISR(MyCat1ISR);
</p></pre><h2 xmlns=""><a name="OS_CORE_FOR_TASK">OS_CORE_FOR_TASK</a></h2><p xmlns="">Returns the ID of the core on which the Task runs. Only available on multi-core. Can be passed a TaskType. Note there is no checking on the value of the TaskType passed.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">  CoreIdType core;
  core = OS_CORE_FOR_TASK(MyTask);
</p></pre><h2 xmlns=""><a name="OS_CORE_ID_0">OS_CORE_ID_0</a></h2><p xmlns="">The logical ID of CORE 0.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_CORE_ID_1">OS_CORE_ID_1</a></h2><p xmlns="">The logical ID of CORE 1. (etc.)</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_CORE_ID_MASTER">OS_CORE_ID_MASTER</a></h2><p xmlns="">The ID of the master core.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_CORE_isrname">OS_CORE_isrname</a></h2><p xmlns="">This macro contains the core (0,1...) that the named interrupt runs on. This is only emitted for multicore applications</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_CORE_timer_interrupt...</p></pre><h2 xmlns=""><a name="OS_CURRENT_IDLEMODE">OS_CURRENT_IDLEMODE</a></h2><p xmlns="">Returns the idle mode for the calling core.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="Os_Disable_x">Os_Disable_x</a></h2><p xmlns="">The Os_Disable_x macro will disable the named interrupt by adjusting its SRC register settings. The macro can be called using either the SRC name or the RTA-OS configured vector name. In the example, this is Os_Disable_STM_SRC0() and Os_Disable_Millisecond() respectively. You will need to #include the file "Os_DisableInterrupts.h" if you want to use these macros. They may not be used by untrusted code.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_Disable_STM_SRC0()
Os_Disable_Millisecond()
</p></pre><h2 xmlns=""><a name="Os_DisableAllConfiguredInterrupts">Os_DisableAllConfiguredInterrupts</a></h2><p xmlns="">The Os_DisableAllConfiguredInterrupts macro will disable all configured SRC interrupts by adjusting the SRC register settings. You will need to #include the file "Os_DisableInterrupts.h" if you want to use this macro. It may not be used by untrusted code.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_DisableAllConfiguredInterrupts()
Os_Enable_Millisecond()
</p></pre><h2 xmlns=""><a name="OS_DURATION_&lt;ScheduleTableID&gt;">OS_DURATION_&lt;ScheduleTableID&gt;</a></h2><p xmlns="">Constant definition of the duration of the ScheduleTable named ScheduleTableID in ticks of its Counter.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_ELAPSED_TIME_RECORDING">OS_ELAPSED_TIME_RECORDING</a></h2><p xmlns="">This macro is only defined if elapsed time recording is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_ELAPSED_TIME_RECORDING
Os_StopwatchTickType total_idle_time;
Os_StopwatchTickType total_taskA_time;
total_idle_time  = Os_GetIdleElapsedTime(OS_CORE_CURRENT);
total_taskA_time = Os_GetTaskElapsedTime(TaskA);
#endif
</p></pre><h2 xmlns=""><a name="Os_Enable_x">Os_Enable_x</a></h2><p xmlns="">The Os_Enable_x macro will re-enable the named interrupt at the priority it was configured with by adjusting its SRC register settings. The macro can be called using either the INTC vector name or the RTA-OS configured vector name. In the example, this is Os_Enable_STM_SRC0() and Os_Enable_Millisecond() respectively. You will need to #include the file "Os_DisableInterrupts.h" if you want to use these macros. They may not be used by untrusted code.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_Enable_STM_SRC0()
Os_Enable_Millisecond()
</p></pre><h2 xmlns=""><a name="Os_EnableAllConfiguredInterrupts">Os_EnableAllConfiguredInterrupts</a></h2><p xmlns="">The Os_EnableAllConfiguredInterrupts macro will enable all configured SRC interrupts by adjusting the SRC register settings. You will need to #include the file "Os_DisableInterrupts.h" if you want to use this macro. It may not be used by untrusted code.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_DisableAllConfiguredInterrupts()
...
Os_EnableAllConfiguredInterrupts()
</p></pre><h2 xmlns=""><a name="OS_EXTENDED_STATUS">OS_EXTENDED_STATUS</a></h2><p xmlns="">Defined when extended status is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_EXTENDED_STATUS
CheckStatusType = ActivateTask(Task1);
if (CheckStatusType == E_OS_LIMIT) {
   /* Log an error */
}
#else
ActivateTask(Task1);
#endif
</p></pre><h2 xmlns=""><a name="OS_FAST_TASK_TERMINATION">OS_FAST_TASK_TERMINATION</a></h2><p xmlns="">Defined when Fast task termination is configured (STANDARD status only).</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_INDEX_TO_ISRTYPE">OS_INDEX_TO_ISRTYPE</a></h2><p xmlns="">Macro that can convert an ISR-specific index in the range 0 to OS_NUM_ISRS-1 to a valid ISRType</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ISRType isr = OS_INDEX_TO_ISRTYPE(2);</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ISRRefType">ISRRefType</a><br /><a href="#OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a><br /></p><h2 xmlns=""><a name="OS_INDEX_TO_TASKTYPE">OS_INDEX_TO_TASKTYPE</a></h2><p xmlns="">Macro that can convert a task-specific index in the range 0 to OS_NUM_TASKS-1 to a valid TaskType</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">ActivateTask(OS_INDEX_TO_TASKTYPE(2));</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TaskRefType">TaskRefType</a><br /><a href="#OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a><br /></p><h2 xmlns=""><a name="Os_IntChannel_x">Os_IntChannel_x</a></h2><p xmlns="">The Os_IntChannel_x macro returns the address of the SRC register that is associated with the named interrupt. You can use this, for example, to trigger the interrupt through software.</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">  *Os_IntChannel_Millisecond = *Os_IntChannel_Millisecond + SRC_TRIGGER_BIT;
</p></pre><h2 xmlns=""><a name="OS_ISRTYPE_TO_INDEX">OS_ISRTYPE_TO_INDEX</a></h2><p xmlns="">Macro that can convert a valid ISRType to an ISR-specific index in the range 0 to OS_NUM_ISRS-1</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">extern Os_StopwatchTickType isr_time[OS_NUM_ISRS];
isr_time[OS_ISRTYPE_TO_INDEX(GetISRID())] = GetExecutionTime();</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#ISRRefType">ISRRefType</a><br /><a href="#OS_INDEX_TO_ISRTYPE">OS_INDEX_TO_ISRTYPE</a><br /></p><h2 xmlns=""><a name="OS_MAIN">OS_MAIN</a></h2><p xmlns="">Declare the main program. Use of OS_MAIN() rather than main() is preferred for portable code, because different compilers have different requirements on the parameters and return type of main().</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#include "Os.h"
OS_MAIN() {
  /* Initialize target hardware */
  StartOS(OSDEFAULTAPPMODE);
}
</p></pre><h2 xmlns=""><a name="OS_NO_TASKS">OS_NO_TASKS</a></h2><p xmlns="">This macro is used to initialize an empty Os_TasksetType. It can only be used when delayed task execution is configured. It must be used when there are more than 64 tasks in the system, but below this you can use the value zero.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TasksetType t1 = OS_NO_TASKS;</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SetDelayedTasks">Os_SetDelayedTasks</a><br /><a href="#Os_AddDelayedTasks">Os_AddDelayedTasks</a><br /><a href="#Os_RemoveDelayedTasks">Os_RemoveDelayedTasks</a><br /><a href="#OS_ADD_TASK">OS_ADD_TASK</a><br /><a href="#TASK_MASK">TASK_MASK</a><br /><a href="#Os_TasksetType">Os_TasksetType</a><br /></p><h2 xmlns=""><a name="OS_NOAPPMODE">OS_NOAPPMODE</a></h2><p xmlns="">The value returned by GetActiveApplicationMode() when the OS is not running.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_ALARMS">OS_NUM_ALARMS</a></h2><p xmlns="">The number of alarms declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_APPLICATIONS">OS_NUM_APPLICATIONS</a></h2><p xmlns="">The number of OS Applications declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_APPMODES">OS_NUM_APPMODES</a></h2><p xmlns="">The number of AppModes declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_CORES">OS_NUM_CORES</a></h2><p xmlns="">The number of Cores declared (OsNumberOfCores).</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_COUNTERS">OS_NUM_COUNTERS</a></h2><p xmlns="">The number of counters declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_EVENTS">OS_NUM_EVENTS</a></h2><p xmlns="">The number of Events declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_INTERVALS">OS_NUM_INTERVALS</a></h2><p xmlns="">The number of Trace Intervals declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_ISRS">OS_NUM_ISRS</a></h2><p xmlns="">The number of Category 2 ISRs declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_OS_CORES">OS_NUM_OS_CORES</a></h2><p xmlns="">The number of Cores that are configured for the OS.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_RESOURCES">OS_NUM_RESOURCES</a></h2><p xmlns="">The number of resources declared (excludes internal).</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_SCHEDULETABLES">OS_NUM_SCHEDULETABLES</a></h2><p xmlns="">The number of schedule tables declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_SPINLOCKS">OS_NUM_SPINLOCKS</a></h2><p xmlns="">The number of Spinlocks declared.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR_MULTICORE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_TASKS">OS_NUM_TASKS</a></h2><p xmlns="">The number of tasks declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_TASKTRACEPOINTS">OS_NUM_TASKTRACEPOINTS</a></h2><p xmlns="">The number of TaskTracepoints declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_TRACECATEGORIES">OS_NUM_TRACECATEGORIES</a></h2><p xmlns="">The number of Trace Categories declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_TRACEPOINTS">OS_NUM_TRACEPOINTS</a></h2><p xmlns="">The number of Tracepoints declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_NUM_TRUSTED_FUNCTIONS">OS_NUM_TRUSTED_FUNCTIONS</a></h2><p xmlns="">The number of Trusted functions declared.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OS_REGSET_&lt;RegisterSetID&gt;_SIZE">OS_REGSET_&lt;RegisterSetID&gt;_SIZE</a></h2><p xmlns="">This macro defines the size of the buffer needed to preserve Register Set &lt;RegisterSetID&gt; at run time. If no buffer is needed, then it is not declared. This can happen if no task/ISR that uses the register set can be preempted by another one that also uses it.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_REGSET_FP_SIZE
  fp_context_save_area fpsave[OS_REGSET_FP_SIZE];
#endif /* OS_REGSET_FP_SIZE */</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_Cbk_RegSetSave_&lt;RegisterSetID&gt;">Os_Cbk_RegSetSave_&lt;RegisterSetID&gt;</a><br /><a href="#Os_Cbk_RegSetRestore_&lt;RegisterSetID&gt;">Os_Cbk_RegSetRestore_&lt;RegisterSetID&gt;</a><br /></p><h2 xmlns=""><a name="OS_SCALABILITY_CLASS_1">OS_SCALABILITY_CLASS_1</a></h2><p xmlns="">Defined when AUTOSAR Scalability Class 1 is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_SCALABILITY_CLASS_1
ALARMCALLBACK(OnlyInSC1){
    ...
}
#endif
</p></pre><h2 xmlns=""><a name="OS_SCALABILITY_CLASS_2">OS_SCALABILITY_CLASS_2</a></h2><p xmlns="">Defined when AUTOSAR Scalability Class 2 is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#if defined(OS_SCALABILITY_CLASS_2) || defined(OS_SCALABILITY_CLASS_4)
StartScheduleTableSynchron(Table);
#endif
</p></pre><h2 xmlns=""><a name="OS_SCALABILITY_CLASS_3">OS_SCALABILITY_CLASS_3</a></h2><p xmlns="">Defined when AUTOSAR Scalability Class 3 is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#if defined(OS_SCALABILITY_CLASS_3) || defined(OS_SCALABILITY_CLASS_4)
FUNC(void, {memclass}) ErrorHook_MyApplication(StatusType Error){
 /* Handle OS-Application error */
}
#endif
</p></pre><h2 xmlns=""><a name="OS_SCALABILITY_CLASS_4">OS_SCALABILITY_CLASS_4</a></h2><p xmlns="">Defined when AUTOSAR Scalability Class 4 is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#if defined(OS_SCALABILITY_CLASS_3) || defined(OS_SCALABILITY_CLASS_4)
FUNC(void, {memclass}) ErrorHook_MyApplication(StatusType Error){
 /* Handle OS-Application error */
}
#endif
</p></pre><h2 xmlns=""><a name="OS_STACK_MONITORING">OS_STACK_MONITORING</a></h2><p xmlns="">This macro is only defined if stack monitoring is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">FUNC(boolean, {memclass}) Os_Cbk_Idle(void){
    #ifdef OS_STACK_MONITORING
        Os_StackSizeType Task1Stack, Task2Stack, Task3Stack;
        Task1Stack = Os_GetTaskMaxStackUsage(Task1);
        Task2Stack = Os_GetTaskMaxStackUsage(Task2);
        ...
        TaskNStack = Os_GetTaskMaxStackUsage(TaskN);
    #endif
    return TRUE;
}
</p></pre><h2 xmlns=""><a name="OS_STANDARD_STATUS">OS_STANDARD_STATUS</a></h2><p xmlns="">Defined when standard status is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_STANDARD_STATUS
ActivateTask(Task1);
#else
CheckStatusType = ActivateTask(Task1);
if (CheckStatusType == E_OS_LIMIT) {
   /* Log an error */
}
#endif
</p></pre><h2 xmlns=""><a name="OS_TASKTYPE_TO_INDEX">OS_TASKTYPE_TO_INDEX</a></h2><p xmlns="">Macro that can convert a valid TaskType to a task-specific index in the range 0 to OS_NUM_TASKS-1</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">extern Os_StopwatchTickType task_time[OS_NUM_TASKS];
TaskType this;
GetTaskID(&amp;this);
task_time[OS_TASKTYPE_TO_INDEX(this)] = GetExecutionTime();</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#TaskRefType">TaskRefType</a><br /><a href="#OS_INDEX_TO_TASKTYPE">OS_INDEX_TO_TASKTYPE</a><br /></p><h2 xmlns=""><a name="OS_TICKS2&lt;Unit&gt;_&lt;CounterID&gt;(ticks)">OS_TICKS2&lt;Unit&gt;_&lt;CounterID&gt;(ticks)</a></h2><p xmlns="">Converts ticks on CounterID to Unit where Unit is: NS (nanosecond), MS (Millisecond), US (Microsecond), SEC(Second).</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">time_in_ms = OS_TICKS2MS_SystemCounter(time);</p></pre><h2 xmlns=""><a name="OS_TIME_MONITORING">OS_TIME_MONITORING</a></h2><p xmlns="">This macro is only defined if time monitoring is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_TIME_MONITORING
Os_StopwatchTickType start,end,function_duration;
start = Os_GetExecutionTime();
#endif
ThirdPartyFunction(x,y);
#ifdef OS_TIME_MONITORING
end = Os_GetExecutionTime();
function_duration = end - start;
#endif
</p></pre><h2 xmlns=""><a name="OS_TRACE">OS_TRACE</a></h2><p xmlns="">This macro is only defined if tracing is enabled.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-TRACE</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_TRACE
  ...
#endif</p></pre><h2 xmlns=""><a name="OS_VEC_isrname">OS_VEC_isrname</a></h2><p xmlns="">This macro contains the vector number (1-255) that is assigned to the named interrupt</p><h4 xmlns="">Portability</h4><p xmlns="">TriCoreHighTec</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">#ifdef OS_VEC_timer_interrupt...</p></pre><h2 xmlns=""><a name="OSCYCLEDURATION">OSCYCLEDURATION</a></h2><p xmlns="">Duration of an instruction cycle in nanoseconds.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">time_in_ns = CycleMeasurement * OSCYCLEDURATION;</p></pre><h2 xmlns=""><a name="OSCYCLESPERSECOND">OSCYCLESPERSECOND</a></h2><p xmlns="">The number of instruction cycles per second.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">time_in_secs = CycleMeasurement / OSCYCLESPERSECOND;</p></pre><h2 xmlns=""><a name="OSErrorGetServiceId">OSErrorGetServiceId</a></h2><p xmlns="">Returns the identifier of the service that generated an error.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">OSServiceIdType WhatServiceFailed = OSErrorGetServiceId();
</p></pre><h2 xmlns=""><a name="OSMAXALLOWEDVALUE">OSMAXALLOWEDVALUE</a></h2><p xmlns="">Constant definition of the maximum possible value of the Counter called SystemCounter in ticks.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">SetAbsAlarm(MyAlarm,OSMAXALLOWEDVALUE,0)</p></pre><h2 xmlns=""><a name="OSMAXALLOWEDVALUE_&lt;CounterID&gt;">OSMAXALLOWEDVALUE_&lt;CounterID&gt;</a></h2><p xmlns="">Constant definition of the maximum possible value of the Counter called CounterID in ticks.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">SetAbsAlarm(MyAlarm,OSMAXALLOWEDVALUE_SomeCounter,0)</p></pre><h2 xmlns=""><a name="OSMEMORY_IS_EXECUTABLE">OSMEMORY_IS_EXECUTABLE</a></h2><p xmlns="">Check whether access rights indicate that memory is executable.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">rights = CheckTaskMemoryAccess(MyTask, &amp;datum, sizeof(datum));
if (OSMEMORY_IS_EXECUTABLE(rights)) {...}
</p></pre><h2 xmlns=""><a name="OSMEMORY_IS_READABLE">OSMEMORY_IS_READABLE</a></h2><p xmlns="">Check whether access rights indicate that memory is readable.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">rights = CheckTaskMemoryAccess(MyTask, &amp;datum, sizeof(datum));
if (OSMEMORY_IS_READABLE(rights)) {...}
</p></pre><h2 xmlns=""><a name="OSMEMORY_IS_STACKSPACE">OSMEMORY_IS_STACKSPACE</a></h2><p xmlns="">Check whether access rights indicate that memory is stack space.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">rights = CheckTaskMemoryAccess(MyTask, &amp;datum, sizeof(datum));
if (OSMEMORY_IS_STACKSPACE(rights)) {...}
</p></pre><h2 xmlns=""><a name="OSMEMORY_IS_WRITEABLE">OSMEMORY_IS_WRITEABLE</a></h2><p xmlns="">Check whether access rights indicate that memory is writeable.</p><h4 xmlns="">Portability</h4><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">rights = CheckTaskMemoryAccess(MyTask, &amp;datum, sizeof(datum));
if (OSMEMORY_IS_WRITEABLE(rights)) {...}
</p></pre><h2 xmlns=""><a name="OSMINCYCLE">OSMINCYCLE</a></h2><p xmlns="">Constant definition of the minimum number of ticks for a cyclic alarm on the Counter called SystemCounter.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">if (ComputedValue &lt; OSMINCYCLE) {
    SetAbsAlarm(MyAlarm,42,OSMINCYCLE);
} else {
    SetAbsAlarm(MyAlarm,42,ComputedValue);
}
</p></pre><h2 xmlns=""><a name="OSMINCYCLE_&lt;CounterID&gt;">OSMINCYCLE_&lt;CounterID&gt;</a></h2><p xmlns="">Constant definition of the minimum number of ticks for a cyclic alarm on the Counter called CounterID.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">if (ComputedValue &lt; OSMINCYCLE_SomeCounter) {
    SetAbsAlarm(MyAlarm,42,OSMINCYCLE_SomeCounter);
} else {
    SetAbsAlarm(MyAlarm,42,ComputedValue);
}
</p></pre><h2 xmlns=""><a name="OSSWTICKDURATION">OSSWTICKDURATION</a></h2><p xmlns="">Duration of a stopwatch tick in nanoseconds.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">time_in_ns = StopwatchMeasurement * OSSWTICKDURATION;</p></pre><h2 xmlns=""><a name="OSSWTICKSPERSECOND">OSSWTICKSPERSECOND</a></h2><p xmlns="">The number of stopwatch ticks per second.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">time_in_secs = CycleMeasurement / OSSWTICKSPERSECOND;</p></pre><h2 xmlns=""><a name="OSTICKDURATION">OSTICKDURATION</a></h2><p xmlns="">Duration of a tick of the Counter called SystemCounter in nanoseconds.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint32   RealTimeDeadline = 50000000; /* 50 ms */
TickType Deadline = (TickType)RealTimeDeadline / OSTICKDURATION;
SetRelAlarm(Timeout,Deadline,0);
</p></pre><h2 xmlns=""><a name="OSTICKDURATION_&lt;CounterID&gt;">OSTICKDURATION_&lt;CounterID&gt;</a></h2><p xmlns="">Duration of a tick of the Counter called CounterID in nanoseconds.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">uint32   RealTimeDeadline = 50000000; /* 50 ms */
TickType Deadline = (TickType)RealTimeDeadline / OSTICKDURATION_SomeCounter;
SetRelAlarm(Timeout,Deadline,0);
</p></pre><h2 xmlns=""><a name="OSTICKSPERBASE">OSTICKSPERBASE</a></h2><p xmlns="">Constant definition of the ticks per base setting of the Counter called SystemCounter in ticks.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="OSTICKSPERBASE_&lt;CounterID&gt;">OSTICKSPERBASE_&lt;CounterID&gt;</a></h2><p xmlns="">Constant definition of the ticks per base setting of  the Counter called CounterID in ticks.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h2 xmlns=""><a name="TASK">TASK</a></h2><p xmlns="">Macro that must be used to create the task's entry function.</p><h4 xmlns="">Portability</h4><p xmlns="">OSEK</p><p xmlns="">AUTOSAR3</p><p xmlns="">AUTOSAR4</p><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">TASK(MyTask) {...}</p></pre><h2 xmlns=""><a name="TASK_MASK">TASK_MASK</a></h2><p xmlns="">This macro is used to convert a TaskType to an Os_TasksetType. It may only be used when delayed task execution is configured.</p><h4 xmlns="">Portability</h4><p xmlns="">RTA-OS</p><h4 xmlns="">Example</h4><pre xmlns=""><p class="CodeExample">Os_TasksetType t1 = TASK_MASK(Task1);</p></pre><h4 xmlns="">See Also</h4><p xmlns=""><a href="#Os_SetDelayedTasks">Os_SetDelayedTasks</a><br /><a href="#Os_AddDelayedTasks">Os_AddDelayedTasks</a><br /><a href="#Os_RemoveDelayedTasks">Os_RemoveDelayedTasks</a><br /><a href="#OS_NO_TASKS">OS_NO_TASKS</a><br /><a href="#TASK_MASK">TASK_MASK</a><br /><a href="#Os_TasksetType">Os_TasksetType</a><br /></p></body></html>